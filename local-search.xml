<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>schedule（）</title>
    <link href="undefined2020/01/03/schedule%EF%BC%88%EF%BC%89/"/>
    <url>2020/01/03/schedule%EF%BC%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>#schedule( )</p><p>schedule定义在linux/kernel/sched.c中<br><br><strong>函数功能：</strong>schedule()函数负责选择系统中下一个运行的进程。它首先对所有任务（进程）进行检测，唤醒任何一个已经的到信号的任务。具体方法时针对任务数组中每一个任务，检查其报警定时值alarm，如果任务的alarm时间已经过期(alarm&lt;jiffies)，则在它的信号位图中设置SIGALRM，然后清alarm值。jiffies时系统从开机开始算起的滴答数（10ms/滴答）。在sched.h中定义。如果进程的信号位图中除去被阻塞的信号外还有其他信号，并且任务处于可中断睡眠状态（TASK_INTERRUPTIBLE），则置任务为就绪状态（TASK_RUNNING）。<br></p><pre><code>    void schedule(void)    {        int i,next,c;        struct task_struct **p;    //任务结构指针的指针    </code></pre><p>检测alarm（进程的报警定时值），唤醒任何已得到信号的可中断任务<br><br>从任务数组中最后一个任务开始循环检测alarm。在循环时跳过空指针项。</p><pre><code>        for(p=&amp;LAST_TASK;p&gt;&amp;FIRST_TASK;--p)                if(*p)                {</code></pre><p>如果设置过任务定时值alarm，并且已经过期(alarm&lt;jiffies)，则在信号位图中置SIGALRM(一个宏定义在include/sys/signal.h)信号，即向任务发送SIGALARM信号，然后清alarm。该信号的默认操作是终止进程,<br>jiffies是从系统开机开始算起的滴答数（10ms/滴答）。定义在sched.h中</p><pre><code>                    if((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm&lt; jiffies)                    {</code></pre><p>（*p）-&gt;signal是信号位图，每个比特代表一种信号，信号值=位偏移值+1，这就是执行1&lt;&lt;(SIGALRM-1的原因。</p><pre><code>                        (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); //SIGALRM被定义在signal.h中代表实时定时器报警                        (*p)-&gt;alarm =0;                    }</code></pre><p>如果信号位图中除被阻塞的信号外还有其他信号，并且任务处于可中断状态，则置任务为就绪<br>状态。其中~(BLOCKABLE &amp; (*p)-&gt;blocked)用于忽略被阻塞的信号，但SIGKILL和SIGSTOP不能被堵塞。<br><br>BLOCKABLE是一个宏，源码在下面<br></p><pre><code>                    if(((*p)-&gt;signal &amp; ~(BLOCKABLE &amp; (*p)-&gt;blocked))&amp;&amp;(*p)-&gt;state==TASK_INTERRUPTIBLE)                                                     //(*p)-&gt;blocked是进程信号屏蔽码（对应信号位图）。                        (*p)-&gt;state=TASK_RUNNING;    //置为就绪(可执行)状态。                }</code></pre><p>这里是调度程序的主要部分</p><pre><code>        while(1)        {            c = -1;            next = 0;            i = NR_TASKS;            p = &amp;task[NR_TASK];</code></pre><p>这段代码也是从任务数组的最后一个任务开始循环，并跳过不含任务的数组槽。比较每个就绪状态任务的<br>counter （任务运行时间的递减滴答计数）值，哪一个值大，运行的时间还不长。next就指向哪个任务号。</p><pre><code>            while(--i)            {                if(!*--p)    //没有执行任务进程执行continue                    continue;                if((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)                            c = (*p)-&gt;counter,next =i;            }</code></pre><p>如果比较得出有counter值不等于0的结果，或者系统中没有一个可运行的任务存在(此时c仍然为-1<br>，next =0)，则退出上面的while(1)循环，执行循环外的任务切换操作<br><br>否则(所有的任务进程的counter都为0)就根据每个任务的优先权值，更新每个任务的counter值，然后回到while重新比较。<br>counter值的计算方式为counter = counter/2 + priority 注意，这里计算进程不考虑进程的状态</p><pre><code>            if(c) break;            for(p = &amp;LAST_TASK; p&gt; &amp;FIRST_TASK; --p)                if(*p)                    (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1)+(*p) -&gt;priority;        }</code></pre><p>用下面的宏（定义在sched.h中）把当前任务指针current指向任务号next的任务，并切换到该任务中<br>运行。在上面代码中next被初始化为0.因此若系统中没有任何其他任务可运行时，则next始终为0.<br>因此调度函数会在系统空闲的适合取执行任务0，此时任务0仅仅执行pause()系统调用，并又会调用本函数。<br><br>switch_to()函数源码在下面<br></p><pre><code>            switch_to(next); //切换任务号为next的任务，并运行之。    }</code></pre><h2 id="BLOCKABLE"><a href="#BLOCKABLE" class="headerlink" title="BLOCKABLE"></a>BLOCKABLE</h2><p>定义在linux/kernel/sched.c中<br><br>SIGKILL和SIGSTOP是宏定义在include/sys/signal.h</p><pre><code>//该宏取信号nr在信号位图中对应位的二进制数值。信号编号1-32.比如信号5的位图数值等于//1&lt;&lt;(5-1) =16= 00010000b。#define S(nr) (1&lt;&lt;((nr)-1))//除了SIGKILL和SIGSTOP信号以外其他信号都是可阻塞的。(....1011,1111,1110,1111,1111b)#define BLOCKABLE(~(S(SIGKILL)| S(SIGSTOP)))</code></pre><h2 id="switch-to"><a href="#switch-to" class="headerlink" title="switch_to( )"></a>switch_to( )</h2><p>switch_to被定义在linux/include/linux/sched.h<br></p><p><strong>函数功能：</strong>switch_to(n)将切换当前任务到任务nr，即n，首先检测任务n是不是当前任务<br>如果是则什么也不做退出。如果我们切换到的任务最近（上一次使用过数学协处理器的话），则还需要复位控制寄存器cr0中的TS标志<br><br><strong>这里解释以下ljmp指令，格式是(ljmp cs1,eip1)，是吧cs1和eip1分别装入cs（16位）和eip（16或32位）寄存器。然后跳转过去<br><br>下面的语句是ljmp %0，是用__tmp中的内存数所以也可以近似看为(ljmp __tmp.b，__tmp.a) 刚好和__tmp中的a，b顺序反过来。</strong></p><pre><code>#define switch_to(n){ \struct {long a,b;}    __tmp; \__asm__(&quot;cmpl %%ecx,current \n\t&quot;\    //首先检测给得的任务n是不是当前任务    &quot;je 1f\n\t&quot; \    //如果是则什么也不做退出。    &quot;movw %%dx,%1\n\t&quot;\    //取新任务TSS的16位选择符存入__tmp.b中    //指令xchgl命令是交换两个寄存器的内容或者寄存器和内存变量的内容，两者都改变。    &quot;xchgl %%ecx,current\n\t&quot;\    // current=task[n];ecx = 被切换出的任务。    &quot;ljmp %0\n\t&quot; \                //执行长跳转*&amp;__tmp，造成任务切换。                                //在任务切换回来后才会继续执行下面的语句。    &quot;cmpl %%ecx,last_task_used_math\n\t&quot; \    &quot;jne 1f\n\t&quot;\    //cr0标志TS每次任务切换时将其置1，任务切换完毕则清0。    &quot;clts \n&quot;\    //清除CR0中的任务切换标志TS    &quot;1:&quot;\    ::&quot;m&quot;(*&amp;__tmp.a),&quot;m&quot;(*&amp;__tmp.b),\    &quot;d&quot;(_TSS(n)),&quot;c&quot;((long)task[n]));\}</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>free_page_tables（）和free_page ( )</title>
    <link href="undefined2020/01/03/free_page_tables%EF%BC%88%EF%BC%89%E5%92%8Cfree_page%20(%20)/"/>
    <url>2020/01/03/free_page_tables%EF%BC%88%EF%BC%89%E5%92%8Cfree_page%20(%20)/</url>
    
    <content type="html"><![CDATA[<h1 id="free-page-tables（）"><a href="#free-page-tables（）" class="headerlink" title="free_page_tables（）"></a>free_page_tables（）</h1><p>函数被定义在kernel/mm/memory.c中<br><br><strong>函数作用：</strong>free_page_tables( )用于释放指定线性地址和长度（页表个数）对应的物理内存页。首先判断指定的线性地址释放4M的边界上，若不是则显示出错信息，并死机，然后判断指定的地址值是否=0，若是，则显示出错信息“试图释放内核和缓冲区所占用的空间”，并死机；接着计算在页目录表中所占用的目录项数size，也即页表个数，并计算对应的起始目录项号，然后从对应的起始目录项开始，释放所占用的所以size个目录项；同时释放对应目录项所指的所有页表项和相应的物理内存页；最后刷新页变化高速缓冲。<br></p><p>下面的函数释放页表连续的内存块，“exit（）”需要该函数。与copy_page_tables(),类似，该函数仅处理4MB长度的内存块。<br></p><p>参数：from -起始线性基地址；size - 释放的字节长度。</p><pre><code>     int free_page_tables(unsigned long from, unsigned long size){    unsigned long *pg_table;    unsigned long *dir,nr;</code></pre><p>首先检测参数from给出的线性基地址是否在4MB的边界处，因为该函数只能处理这种情况。<br>若from=0，则出错。说明试图释放内核和缓冲所占空间。</p><pre><code>    if(from &amp; 0x3ffff)        panic(&quot;free_page_tables called with wrong alignment&quot;);    if(!from)        panic(&quot;Trying to free up swapper memory space&quot;);        size= (size+0x3fffff)&gt;&gt;22;        dir=(unsigned long*) ((from&gt;&gt;20) &amp; 0xffc);/*_pg_dir =0*/    for(;size--&gt;0；dir++)    {        if(!(1 &amp; *dir)) //1与目录项的p位相与，如果p=0（表示该目录项没有使用）则执行continue，否则则执行下一句。            continue;        pg_table = (unsigned long *)(0xfffff000 &amp; *dir);    //取页表地址        for(nr=0;nr&lt;1024;nr++) //这里free页表项中的1024项        {            if(1 &amp; pg_table)    //与页表项中的p位相与。                free_page(0xfffff000 &amp; *pg_table)    //释放*pg_table所指的物理地址页面的内存            *pa_table =0;            pg_table++;        }</code></pre><p>free_page（）源码在下面：</p><pre><code>        free_page(0xfffff000 &amp; *dir);    //这里是free页目录项dir项所指的页表的内容        *dir =0;    }    invalidate();    return 0;}</code></pre><h1 id="free-page"><a href="#free-page" class="headerlink" title="free_page ( )"></a>free_page ( )</h1><p>被定义在kernel/mm/memory.c<br><br>释放物理地址“addr”处的一页内存。用于函数“free_page_tables()”</p><pre><code>    void free_page(unsigned long addr)    {</code></pre><p>首先判断参数给定的物理地址addr的合理性。如果地址addr小于内存低端（1MB），<br>则表示在内核程序或高速缓冲中，对此不予处理。如果物理地址addr&gt;=系统所含物理内存最高端，则显示出错信息并且内核停止工作。</p><pre><code>        if(addr&lt;LOW_MEM) return;</code></pre><p>如果物理地址&gt;=系统所含物理内存最高端，则显示出错信息，并且内核停止工作</p><pre><code>        if(addr&gt;=HIGH_MEMORY)            panic(&quot;trying to free nonexistent page&quot;);</code></pre><p>如果参数addr验证通过，那么就根据这个物理地址换算出从内存地址低端开始计起的内存页面号。<br>页面=号=（addr-LOW_MEM)/4096。可见页面号从0号开始计算起。此时addr中存放页面号。<br>如果该页面号对应的页面映射字节不等于0，则减一返回此时该映射的字节为0则表示该页面已经被释放。<br>如果对应的页面字节原本就是0，表示物理页面本来就是空闲的，说明内核代码出问题，于是显示出错信息并停机。</p><pre><code>        addr -=LOW_MEM;        addr&gt;&gt;=12;        if(mem_map[addr]--) return;    //--a和a--的区别是前者返回a-1的值，后者返回值是a原始值。        mem_map[addr]=0;        panic(&quot;trying to free free page&quot;);    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>copy_page_table（）</title>
    <link href="undefined2020/01/03/copy-page-table%EF%BC%88%EF%BC%89/"/>
    <url>2020/01/03/copy-page-table%EF%BC%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="copy-page-table（）"><a href="#copy-page-table（）" class="headerlink" title="copy_page_table（）"></a>copy_page_table（）</h1><p>copy_page_table 被定义在linux/mm/memory.c<br><br><strong>函数功能：</strong>copy_page_table用于复制指定线性地址和长度（页表个数）对应的页目录项和页表，从而被复制的页目录和页表对应的原物理内存区被共享使用。该函数首先验证指定的源线性地址和目的线性地址是否都在4MB的内存边界上，否则就显示出错信息，并死机；然后由指定线性地址换算出对应的起始页目录项和页表项，复制到新的空闲目录项和页表项中。页目录表只有一个，而新进程的页表需要申请空闲内存页面来存放；此后再将原始和新的页目录和页表项都设置成只读的页面。当有写操作时就利用页异常中断调用，执行写时复制操作，最后对共享物理内存页对应的字节图数组mem_map[]的标志进行增1操作。<br><br>!!注意:当from=0，说明是在为第一次fork（）调用复制内核空间。<br>此时我们就不想复制整个页目录项对应的内存，因为这样做会导致内存严重浪费<br>我们只需要复制开头160个页面-对应640KB，即使复制这些页面也超出我们的需求，但这不会占用更多的内存-<br>在低1MB内存范围内我们不执行写时复制，所有这些页面可以与内核共享。<br></p><p>参数from，to是线性地址，size是需要复制（共享）的内存长度，单位是字节。</p><pre><code>int copy_page_table(unsigned long from,unsigned long to,long size){    unsigned long* from_page_table;    unsigned long*    to_page_table;    unsigned long this_page;    unsigned long*from_dir,*to_dir;    unsigned long nr;</code></pre><p>首先检测参数给出的源地址from和目的地址to的有效性。源地址和目的地址都需要在4MB<br>内存边界地址上，否则出错死机，做这样的要求是因为一个页表的1024项可管理4Mb内存。<br>源地址from和目的地址to，只有满足这个要求才能保证从一个页表的第一项开始复制页表项,并且新页表的最初所有项都是有效的(如果不满足证明给出来的地址不是页表的第一项)，然后取得源地址和目的地址的起始目的项指针<br>（from_dir和to_dir）。再根据参数给出的长度size计算要复制的内存块占用的页表数（即目录项数）。</p><pre><code>    if((from&amp;0x3fffff)||(to&amp;0x3fffff))    //正确情况下两个and操作应该都得到0，然后0||0        panic(&quot;copy_page_table called with wrong alignment&quot;);    from_dir = (unsigned long*)((from&gt;&gt;20)&amp;0xffc);    //这里是取源地址页目录项的偏移地址（即线性地址的31-22位）    to_dir=(unsigned long*)((to&gt;&gt;20)&amp;0xffc);        //这里是取目的地址页目录项的偏移地址</code></pre><p>为什么要加上0x3ffff?<br><br>因为复制时复制目录项数即（一目录项4MB）<br>当size&lt;=4MB时+0x3fffff再左移22位等于1（即复制一项），但是如果不加0x3fffff就等于0了（即不用复制了）<br>同理当(8MB&gt;size&gt;4MB)时size+0x3fffff再&gt;&gt;22等于2，复制两项。</p><pre><code>    size=((unsigned)(size+0x3fffff))&gt;&gt;22;    //计算需要复制的页目录项数</code></pre><p>在得到了源起始目录项指针from_dir和目的起始目录项指针to_dir以及需要复制的页表个数size后<br>下面开始对每个页目录项依次申请一页内存来保存对应的页表，并且开始页表项的复制操作，如果目的目录<br>项指定的页表已经存在（P=1），则出现死机，如果源目录项无效，即指定的页表不存在（P=0），<br>则继续循环处理下一个页目录项。</p><pre><code>    for(;size--&gt;0;from_dir++,to_dir++)    //页目录项的循环    {        if(1 &amp; *to_dir)    //检测目的目录项的标志位P。            panic(&quot;copy_page_tables:already exist&quot;);        if(!(1 &amp; *from_dir))    //检测源目录项的标志位P            continue </code></pre><p>在验证了当前源目录项和目的项正常之后，我们取源目录项中页表地址from_page_table。<br>为了保存目的目录项对应的页表，需要在主内存区中申请一页空闲内存页。如果取空闲页面<br>函数get_free_page()返回0，则说明没有申请到空闲内存页面，可能所内存不够，于是返回-1值退出<br><br>get_free_page()函数看篇：<a href="https://lexssama.github.io/2020/01/02/get-free-page%EF%BC%88%EF%BC%89/#mem-map-%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">get _free _page()源码分析</a></p><pre><code>        from_page_table=(unsigned long*)(0xfffff000 &amp; *from_dir);    //取源目录项的第from_dir项的值*from_dir                                                            //(如果还不懂的话去看看线性地址转换成物理地址那张图)        if(!(to_page_table = (unsigned long *) get_free_page()))    //申请一页物理内存，准备复制页表            return -1;</code></pre><p>如果找到了空闲页面我们就开始设置目录项信息，把最后3位置位，即当前目录项“或”上7，表示对应页表映射<br>的内存页面时用户级的，并且可读写，存在（usr，R/W，Present）。(如果U/S位是0，则R/W没有作用)。如果U/S位是1，而<br>R/W是0，那么运行在用户层的代码就只能读页面。如果U/S和R/W都置位，则就要读写的权限）。然后针对当前处理的页目录项<br>对应的页表，设置需要复制的页面项数。如果是在内核空间，则仅需复制160页对应的页表项（nr=160），对应于开始640KB物理内存<br>否则需要复制一个页表中的所有1024个页表项（nr=1024），可映射4MB物理内存。</p><pre><code>        *to_dir = ((unsigned long) to_page_table) | 7;        nr = (from==0) ?0xA0:1024;    //判断是不是第一次fork（）</code></pre><p>此时对于当前页面，开始循环指定的nr个内存页面表项。先取出源页面内容，如果<br>当前源页面没有使用，则不用复制该表项，继续处理下一项。否则复位页面项R/W标志<br>（位1置0），即让页表项对应的内存页面只读。然后将页表项复制到目的页表中。</p><pre><code>        for(; nr-- &gt;0 ; from_page_table++, to_pape_table++){    //页目录项循环内，页表项的循环。            this_page = *from_page_table;            if(!(1&amp;this_page))    //检测页表项P位，P=0证明没有使用。                continue;            this_page &amp;= ~2; //与上取反的2（~2），这里是把R/W标志复位。            *to_page_table = this_page;    //令目标页表项只读</code></pre><p>如果该页表所指物理页面的地址在1MB以上，则需要设置内存页面映射数组mem_map[]，<br>于是计算页面号，并以它为索引在页面映射数组相应项增加引用次数，而对于位于1MB<br>以下的页面，说明式内核页面，因此不需要对mem_map[]进行设置，因为mem_map[]仅用于<br>管理主内存区中的页面使用情况，因此对于内核移动到任务0中并用fork()创建任务1时（用于运行init（））<br>由于此时复制的页面还仍然都在内核代码区域，因此以下判断中的语句不会执行，任务0的页面仍然可以随时读写。<br>只有当调用fork（）的父进程代码处于主内存区（页面位置大于1MB）时才会执行，这种情况需要在进程调用<br>execve（）,并装载执行了新程序代码时才会出现。</p><pre><code>        if(this_page &gt; LOW_MEM)        {</code></pre><p>下面这行语句时让源页表项页设置为只读，因为现在开始有两个进程共用内存区了，若其中一个进程<br>需要进行写操作，则通过页异常写保护处理为执行写操作的进程分配一页新空闲页面，也即进行写时复制（copy on write）操作。</p><pre><code>            *from_page_table = this_page;  //令源页表项也只读            this_page -=LOW_MEM;            this_page &gt;&gt;=12;            mem_map[this_page]++;        }        }    }</code></pre><p>invalidate（）源码在下面</p><pre><code>    invalidate();    //刷新页变换高速缓冲。    return 0;}</code></pre><h2 id="invalidate（）源码"><a href="#invalidate（）源码" class="headerlink" title="invalidate（）源码"></a>invalidate（）源码</h2><p>函数被定义在kernel/mm/memory.c中<br>刷新页变换缓冲函数。<br>为了提高地址转换的效率，CPU将最近使用的页表数据存放在芯片高速缓冲中，在修改过页表信息之后<br>就需要刷新该缓冲区。这里使用重新加载页目录基址寄存器cr3的方法来进行刷新。<br>下面eax =0， 是页目录的基址。</p><pre><code>    #define invalidate() \__asm__(&quot;movl %%eax,%%cr3&quot;::&quot;a&quot;(0))</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>copy_mem（）</title>
    <link href="undefined2020/01/02/copy-mem%EF%BC%88%EF%BC%89/"/>
    <url>2020/01/02/copy-mem%EF%BC%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="copy-mem"><a href="#copy-mem" class="headerlink" title="copy_mem( )"></a>copy_mem( )</h1><p>copy_mem( )被定义在kernel/fork.c中<br><br>copy_mem( )函数的作用是：<br><br>复制内存页表（即把父进程的内存页表复制给新进程）<br><br>参数nr是新任务号；p是新任务数据结构指针。<br><br><strong>该函数为新任务在线性地址空间中设置代码段<br>和数据段基址，限长，并复制页表。</strong>由于Linux系统采用了写时复制（copy on write）技术<br>因此这里仅为新进程设置自己的页目录表项和页表项，而没有实际为新进程分配物理内存页面。此时新进程<br>与其父进程共享所有内存页面，操作成功返回0，否则返回出错号。</p><pre><code>int copy_mem (int nr,struct task_struct *p){    unsigned long old_data_base,new_data_base_limit;    unsigned long old_code_base,new_code_base_limit;</code></pre><p>首先取当前进程局部描述符表中代码段描述符和数据段描述符项中的段限长（字节数）。<br>0x0f是代码段选择符；0x17是数据段选择符。然后取当前进程代码段和数据段在线性地址<br>空间中的基地址。由于Linux-0.11内核还不支持代码和数据段分立的情况，因此这里需要<br>检测代码段和数据段基址和限长是否都分别相同。否则内核显示出错信息，并停止运行。<br>get_limit()和get_base()源码在下面<br></p><pre><code>    code_limit=get_limit(0x0f);    data_limit=get_limit(0x17);    old_code_base=get_base(current-&gt;ldt[1]);    old_data_base=get_base(current-&gt;ldt[2]);    if(old_data_base!=old_code_base)        panic(&quot;We don&#39;t support separate I&amp;D&quot;);    if(data_limit&lt;code_limit)        panic(&quot;Bad data_limit&quot;);</code></pre><p>然后设置创建中的新进程在线性地址空间中的基地址等于（64MB*其任务号），并用该值<br>设置新进程局部描述表中段描述符中的基地址，接着设置新进程的页目录表项和页表项，<br>即复制当前进程（父进程）的页目录表和页表项。此时子进程共享父进程的内存页面。<br>正常情况下copy_page_tables()返回0，否则表示出错，则释放刚申请的页表项。<br>set_base的源码在下面<br></p><pre><code>    new_data_base = new_code_base = nr*0x4000000;    //64MB*其任务号    p-&gt;start_code=new_code_base;    set_base(p-&gt;ldt[1],new_code_base);    //设置新进程的ldt表的代码段地址。    set_base(p-&gt;ldt[2],new_data_base);    //设置新进程的ldt表的数据段地址。</code></pre><p>接下来设置新进程的页目录表项和页表项<br><br>copy_page_table( )看这篇 <a href="https://lexssama.github.io/2020/01/03/copy-page-table%EF%BC%88%EF%BC%89/" target="_blank" rel="noopener">copy _page _table( )源码分析</a><br><br><br>free_page_table( )看这篇<a href="https://lexssama.github.io/2020/01/03/free_page_tables%EF%BC%88%EF%BC%89%E5%92%8Cfree_page%20(%20)/" target="_blank" rel="noopener">free _page _table( )源码分析</a><br></p><pre><code>    if(copy_page_table(old_data_base,new_data_base,data_limit))    {        free_page_table(new_data_base,data_limit);        return -ENOMEM;    }    return 0;}</code></pre><h2 id="get-limit-源码"><a href="#get-limit-源码" class="headerlink" title="get_limit()源码"></a>get_limit()源码</h2><p>get_limit()被定义在include/linux/sched.h<br><br><strong>函数目的是：取段选择符segment指定的描述符的段限长值</strong></p><pre><code>//指令lsl是Load Segment Limit缩写。它从指定段描述符中取出分散的限长比特位拼成完整的//段限长值放入指定寄存器中。所得的段限长是实际字节数减1，因此这里还需要加1(incl加1指令)才返回。#define get_limit(segment) ({\unsigned long __limit;\__asm__(&quot;lsll %1，%0\n\t incl %0&quot;:&quot;=r&quot;(__limit):&quot;r&quot;(segment));\__limit;})</code></pre><h2 id="get-base-源码"><a href="#get-base-源码" class="headerlink" title="get_base()源码"></a>get_base()源码</h2><p>get_base()被定义在include/linux/sched.h<br><br><strong>函数目的是：取局部描述符表ldt所指段描述符中的基地址</strong></p><pre><code>#define get_base(ldt) _get_base(((char *)&amp;(ldt)))</code></pre><p>_get_base（）</p><pre><code>#define _get_base(addr)({\unsigned long __base;\__asm__(&quot;movb %3,%%dh\n\t&quot;\        //取[addr+7]处基址高16位的高8位（位31-24）-&gt;dh        &quot;movb %2,%%dl\n\t&quot;\        //取[addr+4]处基址高16位的低8位（位23-16）-&gt;dl            &quot;shll $16,%%edx\n\t&quot;\    //基地址高16位移到edx中高16位处        &quot;movw %1,%%dx&quot;\            //取[addr+2]处基址低16位（位15-0）-&gt;dx。        :&quot;=d&quot;(__base)\            //从而edx中含有32位段基址。        :&quot;m&quot;(*((addr)+2))\         &quot;m&quot;(*((addr)+4))\         &quot;m&quot;(*((addr)+7)))__base;})</code></pre><h2 id="set-base"><a href="#set-base" class="headerlink" title="set_base( )"></a>set_base( )</h2><p>set_base( )被定义在include/linux/sched.h<br><br><strong>函数目的是：设置局部描述符表中ldt描述符的基地址字段</strong></p><pre><code>#define set_base(ldt,base) _set_base(((char *)&amp;(ldt)),base)</code></pre><p>_set_base( )源码如下：<br></p><pre><code>//设置位于地址addr处描述符中的各基地址字段（基地址是base）。#define _set_base(addr,base)\    __asm__(&quot;movw %%dx,%0\n\t&quot;\        //基址base低16位（位15~0）-&gt;[addr+2]        &quot;rorl $16,%%edx\n\t&quot;\    //edx中基址高16位（位31-16）-&gt;dx(循环左移)        &quot;movb %%dl,%1\n\t&quot;\        //基址高16位中的低8位（位23-16）-&gt;[addr+4]        &quot;movb %%dh,%2&quot;\            //基址高16位中的高8位（位31~24）-&gt;[addr+7]        ::&quot;m&quot;(*((addr)+2)),\          &quot;m&quot;(*((addr)+4)),\          &quot;m&quot;(*((addr)+7)),\          &quot;d&quot;(base)\          :&quot;dx&quot;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>get_free_page（）</title>
    <link href="undefined2020/01/02/get-free-page%EF%BC%88%EF%BC%89/"/>
    <url>2020/01/02/get-free-page%EF%BC%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="get-free-page"><a href="#get-free-page" class="headerlink" title="get_free_page()"></a>get_free_page()</h1><p>get_free_page()定义在kernel/mm/memory.c中<br><br><strong>get_free_page和free_page用来管理主内存区中物理内存的占用和空闲情况，与每个进程的线性地址无关<br></strong><br><strong>get_free_page（）函数的作用：</strong><br><br>get_free_page()函数用于主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。它首先扫描内存页面字节图数组mem_map[]，寻找值是0的字节项（0代表整个页面为空闲页面）。若无则返回0结束，表示物理内存已经使用完，若找到值为0的字节，则将其置1，并换算出对应空闲页面的起始地址。然后对该内存进行清零操作。最后返回该空闲页面的物理内存起始地址。<br></p><h2 id="mem-map-介绍"><a href="#mem-map-介绍" class="headerlink" title="mem_map[]介绍"></a>mem_map[]介绍</h2><p><strong>这里解释一下mem_map[]：</strong><br><br>对于内核代码和数据所占物理内存区域以外的内存（1MB以上的内存），内核使用了一个字节数组mem_map[]来表示物理内存页面的状态，每个字节描述一个物理内存页的占用状态。其中的值表示被占用的次数，0表示对于的物理内存空闲着。当申请一页物理内存时，就将对应字节的值增1。<br><br>在内存管理初始化过程中，系统首先计算出1MB以上内存区域对于的内存页面数(PAGING_PAGES)，并把mem_map[]<br>所有项都置为100（占用），然后把主内存区域中对应的mem_map[]项中的值清零。因此内核所使用的位于1MB地址以上的高速缓冲区以及虚拟磁盘区域（若有的话）都已经被初始化为占用状态。mem_map[]中对应主内存区域的项则在内存使用过程中进行设置或者复位。<br></p><p>mem_map[]定义在kernel/mm/memory.c<br></p><pre><code>#define PAGING_MEMORY (15*1024*1024)    //分页内存15MB。主内存取最多15MB#define PAGING_PAGES (PAGING_MEMORY&gt;&gt;12) //分页后的内存页面数(3840)//物理内存映射字节图（1字节代表1页内存）。每个页面对应的字节用于标志页当前被引用//（占用）次数。它最大可以映射15MB的内存空间。再初始化函数mem_init()中，对于不能用//主存页面的位置均都预先设置成USED（100）.static unsigned char mem_map[PAGING_PAGES]={0,};</code></pre><h2 id="get-free-page-1"><a href="#get-free-page-1" class="headerlink" title="get_free_page()"></a>get_free_page()</h2><p><strong>下面时get_free_page( )函数源码:</strong><br></p><pre><code>unsigned long get_free_page(void){</code></pre><p>这里定义了一个局部寄存器变量，该变量将被保存在eax寄存器中，以便高效的访问和操作。这种定义变量的方法主要用于内嵌汇编程序中，详细说明参见gcc手册“在指定寄存器中的变量”</p><pre><code>    register unsigned long __res asm(&quot;ax&quot;);</code></pre><p>std置方向位(DF=1),倒着遍历。<br><br>这里分别解释指令 repne和scasb。<br><br>repne（repeat not equal）：表示如果下一条指令的两个操作数不相等则循环，循环次数是ecx，每循环一次ecx减1。<br>scasb表示[%al]-[%di]也就是比较查询寄存器di中是否有al中的字符，每比较一次di自动变化（指向下一个单元还是上一个单元，由方向位DF决定，这里是指向上一个单元）</p><pre><code>    __asm__(&quot;std;repne;scasb\n\t&quot;            &quot;jne 1f\n\t&quot;    //ecx减到0如果没有相等的就跳到后面标志1：处执行。        &quot;movb $1,1(%%edi)\n\t&quot; //1-&gt;[1+%edi],将对应页面内存映像比特位置1。        // 这里为什么是[1+%edi]而非%edi呢是因为scasb执行后会将di根据方向位加1或者减1。因为scasb执行后减一，所有这里要加回来</code></pre><p>这里开始计算空闲物理页面的起始地址:</p><pre><code>        &quot;sall $12,%%ecx\n\t&quot;    //sall是左移指令，相当于ecx*4K=相对页面起始位置。        &quot;addl %2,%%ecx\n\t&quot;        //再加上低端内存地址，得到页面实际物理起始地址。        &quot;movl %%ecx,%%edx\n\t&quot;    //将页面实际起始地址-&gt;edx寄存器</code></pre><p>得到空闲物理页面的起始地址后准备开始清零操作。</p><pre><code>        &quot;movl $1024,%%ecx\n\t&quot;    //寄存器ecx置计数值1024        &quot;leal 4092(%%edx),%%edi\n\t&quot;    //将4092+edx的位置-&gt;edi（该页面的末端）。        &quot;rep ; stosl\n\t&quot;    //将edi所指内存清零（反方向，即将该页面清零）</code></pre><p>清零后返回页面的起始地址。</p><pre><code>        &quot;movl %%edx,%%eax\n&quot;    //将页面的起始地址-&gt;eax(返回值)        &quot;1:&quot;        :&quot;=a&quot;(__res)            :&quot;0&quot;(0),&quot;i&quot;(LOW_MEM),&quot;c&quot;(PAHING_PAGES),        &quot;D&quot;(mem_map+PAGING_PAGES-1)        :&quot;di&quot;,&quot;cx&quot;,&quot;dx&quot;        );    return __res;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>copy_process</title>
    <link href="undefined2020/01/02/copy-process/"/>
    <url>2020/01/02/copy-process/</url>
    
    <content type="html"><![CDATA[<h1 id="copy-process"><a href="#copy-process" class="headerlink" title="copy_process"></a>copy_process</h1><p>copy_process定义在kernel/fork.c中<br><br>在sys_fork中执行了find_empty_process找到空闲的任务结构后压入一些寄存器就执行copy_process<br><br>它的作用是：复制系统进程信息（task[nr]），并且设置必要的寄存器，它还整个地复制数据段。<br></p><p>sys_fork函数执行到copy_process时其栈内容如下图，正好对应copy_process函数的参数调用。<br><img src="https://i.imgur.com/Nuq10FZ.png" srcset="/img/loading.gif" alt></p><pre><code>int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,        long ebx,long ecx,long edx,        long fs,long es,long ds,        long eip,long cs,long eflags,long esp,long ss){    struct task_struct *p;    int i;    struct file *f;</code></pre><p>首先为新任务数据结构分配内存(get_free_page（）,用来取得空闲的一页物理页面（4KB）)。如果内存分配出错，则返回出错码并退出。不出错则将新任务结构指针放入任务数组的nr中，（其中nr为任务号，由前面find_empty_process()返回。）接着把当前进程任务结构内容复制到刚申请到的内存页面p开始处。<br><a href="https://lexssama.github.io/2020/01/02/get-free-page%EF%BC%88%EF%BC%89/" target="_blank" rel="noopener">get _free _page()源码分析</a></p><pre><code>    p = (struct task_struct *) get_free_page(); //返回空闲物理页面地址（若无空闲页面则返回0）    if (!p)        return -EAGAIN;    task[nr] = p;    *p = *current;    //这样做不会复制超级用户堆栈（只复制进程结构）</code></pre><p>随后对复制来的进程结构内容进行一些修改，作为新进程的任务结构。<br>先将新进程的任务状态置为不可中断等待状态（有点像关中断），以防止内核调度其执行<br>然后设置新进程的进程号pid和父进程号father，并初始化进程运行时间片值等于其priority值<br>（一般为15个嘀咕）。接着复位新进程的信号位图，报警定时器，会话（session）领导标志leader，<br>进程及其子进程在内核和用户态运行时间统计值，还设置进程开始运行的系统时间start_time</p><pre><code>    p-&gt;state = TASK_UNINTERRUPTIBLE;        p-&gt;pid = last_pid;    //新进程号。也由find_empty_process()得到    p-&gt;father = current-&gt;pid;    //设置父进程号    p-&gt;counter = p-&gt;priority;    //运行时间片值    p-&gt;signal = 0;    //信号位图置0    p-&gt;alarm = 0;    //报警定时值（滴答数）    p-&gt;leader = 0;        /* process leadership doesn&#39;t inherit （进程的领导权是不能被继承的*/    p-&gt;utime = p-&gt;stime = 0;    //用户态时间和核心态运行时间    p-&gt;cutime = p-&gt;cstime = 0;    //子进程用户态和核心态运行时间    p-&gt;start_time = jiffies;    //进程开始运行时间（当前时间滴答数）</code></pre><p>在修改任务状态段TSS数据，由于系统给任务结构p分配了一页新内存，所以（PAGE_SIZE+（long）p）让esp0<br>正好指向该页顶端。ss0:esp0用作程序在内核态执行时的栈，每个任务在GDT表中都有两个段描述符，一个是任务的TSS段描述符，一个是LDT表段描述符下面的p-&gt;tss.ldt = _LDT(nr)就是把GDT中本任务LDT段描述符的选择符保存在本任务的TSS段中当CPU执行切换任务时，会自动从TSS中把LDT段描述符的选择符加载到ldtr寄存器中</p><pre><code>    p-&gt;tss.back_link = 0;    p-&gt;tss.esp0 = PAGE_SIZE + (long) p;    //任务内核态栈指针=空闲物理页面地址+ PAGE_SIZE。    p-&gt;tss.ss0 = 0x10;    //内核态栈的段选择符    p-&gt;tss.eip = eip;    //指令代码指针    p-&gt;tss.eflags = eflags;    //标志寄存器    p-&gt;tss.eax = 0;    //这是当fork（）返回时新进程会返回0的原因所在    p-&gt;tss.ecx = ecx;    p-&gt;tss.edx = edx;    p-&gt;tss.ebx = ebx;    p-&gt;tss.esp = esp;    p-&gt;tss.ebp = ebp;    p-&gt;tss.esi = esi;    p-&gt;tss.edi = edi;    p-&gt;tss.es = es &amp; 0xffff;    //段寄存器仅16位有效    p-&gt;tss.cs = cs &amp; 0xffff;    p-&gt;tss.ss = ss &amp; 0xffff;    p-&gt;tss.ds = ds &amp; 0xffff;    p-&gt;tss.fs = fs &amp; 0xffff;    p-&gt;tss.gs = gs &amp; 0xffff;    p-&gt;tss.ldt = _LDT(nr);    //任务局部表描述符的选择符    p-&gt;tss.trace_bitmap = 0x80000000;    //高16位有效</code></pre><p>如果当前任务使用了协处理器，就需要保存其上下文（即还需要把协处理器的完整状态保存到新进程的tss.i387结构中）。因为要创建新进程就是copy旧进程所以如果current用到协处理器就还需要保存协处理器汇编指令clts用于清除控制寄存器CR0中的任务已交换（TS）标志。每当发生任务切换，CPU都会设置该标志，该标志用于管理数学协处理器如果该标志置位，那么每个ESC指令都会被捕获（异常7）。如果协处理器存在标志MP也同时置位的话，<br>那么WAIT指令也会捕获，因此任务切换发生在一个ESC指令开始执行之后，则协处理器中的内容就可能需要<br>在执行新的ESC指令之前保存起来。捕获处理句柄会保存协处理器的内容并复位TS标志。指令fnsave用于<br>把协处理器的所有状态保存到目的操作数指定的内存区域中（tss.i387）。<br><br>last_task_used_math定义在kernel/sched.c中<br><br>struct task_struct *last_task_used_math=NULL; //使用过协处理器的指针</p><pre><code>    if (last_task_used_math == current)        __asm__(&quot;clts ; fnsave %0&quot;::&quot;m&quot; (p-&gt;tss.i387));</code></pre><p>接下来复制进程页表。即线性地址空间中设置新代码段和数据段描述符中的基址和限长，并复制页表，如果出错（返回值不是0），则复位任务数组中相应项并释放为该新任务分配的用于任务结构的内存页。<br>copy_mem()看这篇<a href="https://lexssama.github.io/2020/01/02/copy-mem%EF%BC%88%EF%BC%89/" target="_blank" rel="noopener">copy _mem()源码分析</a><br><br>free_page()看这篇<a href="https://lexssama.github.io/2020/01/03/free_page_tables%EF%BC%88%EF%BC%89%E5%92%8Cfree_page%20(%20)" target="_blank" rel="noopener">free _page()源码分析</a></p><pre><code>    if (copy_mem(nr,p)) {    //返回不为0表示出错        task[nr] = NULL;        free_page((long) p);    //如果失败就释放申请的页面        return -EAGAIN;    }</code></pre><p>如果父进程中有文件是打开的，则将对应文件的打开次数增加1.因为这里创建的子进程会与父进程共享这些打开的文件，将当前进程（父进程）的pwd，root和executable引用次数均增加1，与上面同样的道理，子进程也引用了这些i节点。</p><pre><code>    for (i=0; i&lt;NR_OPEN;i++)     //NR_OPEN被定义在fs.h中 （#define NR_OPEN 20）打开文件数。        if ((f=p-&gt;filp[i]))            f-&gt;f_count++;    if (current-&gt;pwd)        current-&gt;pwd-&gt;i_count++;    if (current-&gt;root)        current-&gt;root-&gt;i_count++;    if (current-&gt;executable)        current-&gt;executable-&gt;i_count++;</code></pre><p>随后在GDT表中设置新任务TSS段和LDT段描述符。这两个段的限长均被设置成104字节<br>程序然后把新进程设置成就绪态，另外在任务切换时，任务寄存器tr由CPU自动加载。<br>最后返回新进程号。<br><br>set_tss_desc()和set_ldt_desc()定义在include/asm/system.h<br></p><pre><code>    set_tss_desc(gdt+(nr&lt;&lt;1)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));    set_ldt_desc(gdt+(nr&lt;&lt;1)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));    p-&gt;state = TASK_RUNNING;    /* do this last, just in case （最后才将新任务置成就绪态，以防万一）*/    return last_pid;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>find_empty_process</title>
    <link href="undefined2020/01/02/find-empty-process/"/>
    <url>2020/01/02/find-empty-process/</url>
    
    <content type="html"><![CDATA[<h1 id="find-empty-process"><a href="#find-empty-process" class="headerlink" title="find_empty_process"></a>find_empty_process</h1><p><strong>find_empty_process定义在kernel/fork.c中,函数的作用时为新进程取得不重复的进程号last_pid。函数返回任务数组中的任务号（数组项）</strong><br><br>首先获取新的进程号，如果last_pid增1后超出进程号的正数表示范围，则重新从1开始<br>使用pid号，然后再任务数组中搜索刚设置的pid号是否已经被任何任务使用。如果是则跳转<br>到函数开始处重新获得一个pid号。接着再任务数组中为新任务寻找一个空闲项，并<br>返回项号。last_pid是一个全局变量（定义在kernel/fork.c中，<em>long last_pid=0</em>）不用返回。如果此时任务数组中64个项64个项已经被全部占用，则返回出错码。<br></p><p>task[]定义在kernel/sched.c中是一个指针数组，即数组里的值都是指针，NR_TASK=64，第一项是进程0的任务结构的地址。这里不展开讲。</p><pre><code>struct task_struct *task[NR_TASKS]={&amp;(init_task.task),} </code></pre><p><strong>/—————————————————————————————–</strong></p><pre><code>int find_empty_process(void){    int i;    repeat:        if((++last_pid)&lt;0)  last_pid=1;   //long last_pid=0        for(i=0;i&lt;NR_TASKS;++i) //这里循环一遍是为了检测得到的last_pid是否被用，如果正在被用则goto repeat再找一个last_pid。            if(task[i]&amp;&amp;task[i]-&gt;pid==last_pid) goto repeat;        for(i=1;i&lt;NR_TASKS;i++) //如果来到这一步就证明找到一个没有正在被用的last_pid            if(!task[i])          //这个循环是为了新任务找出一个空闲项            return i;       //有空闲项则返回空闲项项号（即数组号）            return -EAGAIN; //没有空闲项则返回出错码 #define EAGAIN        11（定义在include/errno.h）。}</code></pre><p><strong>/——————————————————————————–</strong></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fork（）函数解析</title>
    <link href="undefined2020/01/02/fork%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <url>2020/01/02/fork%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><strong>这里主要用Linux-0.11源码中的main.c中使用的fork来讲解</strong><br>#fork（）<br>在main.c中经过函数move_to_user_mode()后进入用户模式（进程0开始执行）。<br><br>进程0开始执行后马上进入fork()函数，目的是创建出子进程1。<br><br><strong>在main.c中需要注意的是fork函数是用内联函数（inline）的方式实现的！</strong><br><br><strong>为什么要用内联的方式实现呢？</strong><br><br>因为在创建新进程init（即进程1）的过程中，系统对其进行了一些特殊的处理。进程0和进程1实际上同时使用着内核代码区内（小于1MB的物理内存）相同的代码和数据物理内存页面（640KB），只是执行的代码不在一处，因此实际上它们也同时使用着相同的用户堆栈区。在为新进程init复制其父进程（进程0）的页目录和页表项时，进程0的640KB页表项属性没有改动过（仍然可读写），但是进程1的640KB对应的页表项却被设置成了只读，因此进程1开始执行时，其对用户栈的出入栈操作将导致页面写保护异常，从而会使内核的内存管理程序为进程1在主内存区分配一内存页面，并且把从任务0栈中相应页面内容复制到此新页面上。从此时起，任务1的用户态栈开始有自己独立的内存页面，即从任务1执行过出/入栈操作后，任务0和任务1的用户栈开始有变成独立的栈，为了不出现冲突问题，就必须要求任务0在任务1执行栈操作之前禁止使用到用户堆栈区域，而让进程init能单独使用堆栈，所以用到内联函数inline<br><br>因为在内核调度进程运行时序是随机的，有可能任务0创建了任务1后仍然先允许任务0，因此任务0执行fork（）操作后，随后的pause函数也必须采用内联函数形式来实现，以避免任务0在任务1之前使用用户栈。<br></p><h2 id="内联fork（）函数"><a href="#内联fork（）函数" class="headerlink" title="内联fork（）函数"></a>内联fork（）函数</h2><p>定义在init/main.c内</p><pre><code>static inline _syscall0(int,fork);</code></pre><p>_syscall0是一个宏，定义在include/unistd.h中<br><br>static inline _syscall0(int,fork)宏展开后的模样：</p><pre><code>static inline int fork(void){    long _res;    _asm_ volatile (&quot;int 0x80&quot; :&quot;=a(_res)&quot; :&quot;0&quot;(__NR_fork););    if(_res&gt;=0)    return (int)_res;    errno = -_res;    return -1;}</code></pre><p>int $0x80指令属于软中断(software interrupt)。软中断又叫做编程异常(programmed exception)，是异常的一种。<br>该指令的作用是以0x80作为索引值，用于在中断描述符表IDT中查找存储了中断处理程序信息的描述符。<br></p><p><strong>IDT表的0x80项被设定为&amp;system_call这里不展开讲</strong></p><pre><code>set_system_gate(0x80,&amp;system_call);</code></pre><p><strong>用户态的fork()API通过int0x80这个编译异常，可以从用户态进入到内核态。具体的说由用户态进入内核时，CPU的保护机制检测到特权级发生了变化，会自动将用户态程序在执行int0x80时的ss，esp，eflags，cs，eip这5个寄存器的值顺序压入进程0的内核栈中</strong><br><br>此时进程0的内核栈的模样：<br><br><img src="https://i.imgur.com/FGKK9r0.png" srcset="/img/loading.gif" alt><br>##system_call<br><strong>system_call被定义在linux/kernel/system_call.s中,<br>int 0x80 –linux系统调用的入口点(调用中断int0x80，eax是调用号)</strong><br></p><p><strong>-———————————————-</strong></p><pre><code>system_call:    cmpl $nr_system_call-1,%eax #调用号如果超出范围的话就在eax中置-1，并退出。     ja bad_sys_call #（eax-nr_system_call+1）如果大于则跳转到bad_sys_call</code></pre><p><strong>nr_system_call定义在linux/kernel/system_call.s,代表linux-0.11内核中的系统调用总数nr_system_call=72</strong><br><br><strong>bad_sys_call定义在linux/kernel/system_call.s<br></strong></p><pre><code>bad_sys_call:            movl $-1,%eax   #eax中置-1，退出中断            iret</code></pre><p><strong>-——————————————————-</strong></p><pre><code>    push %ds    //保存原段寄存器的值    push %es    push %fs    #一个系统调用最多可带3个参数，也可也不带参数，下面入栈的ebx，ecx，edx中    #放着系统调用相应的C语言函数（见94行）的调用参数，这几个寄存器的入栈顺序    #是由GNU GCC规定的，eax=调用号，ebx中可存放第一个参数，ecx中存放第二个参数，edx存放第三个参数    #系统调用语句可以参见头文件include/unistd.h中第133到183行的系统调用宏。    push %edx    push %ecx    push %ebx</code></pre><p>此时栈内的内容如下:<br><br><img src="https://i.imgur.com/mbMBI5E.png" srcset="/img/loading.gif" alt><br></p><p><strong>-————————————————————-</strong></p><pre><code>    movl $0x10,%edx # ds，es指向内核代码段    mov %dx,%ds    mov %dx,%es    #fs指向LDT的数据段，即指向执行本次系统调用的用户程序的数据段。    #注意，在Linux 0.11中内核给任务分配的代码和数据内存段是重叠的，它们    #的段基址和段限长相同。    #参见fork.c程序中copy_men()函数    movl $0x17,%edx    mov %dx,%fs    call sys_call_table(,%eax,4)    #间接调用指定功能的C函数    pushl %eax        #把系统调用返回值压栈。</code></pre><p><strong>sys_call_table(,%eax,4) 这句操作数的含义是：调用地址=[_sys_call_tale + %eax * 4]。AT&amp;T的寻址方式。 <br><br>sys_call_table[]是一个指针数组，定义在include/linux/sys.h中，该指针数组中设置了72个系统调用C处理函数的地址。</strong></p><pre><code>fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_Smknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid,sys_setregid };</code></pre><p><strong>fn_ptr是int类型指针定义在include/linux/sched.h中</strong>    <br></p><pre><code>typedef int (\*fn\_ptr)();</code></pre><p><strong>所以 call sys_call_table(,%eax,4) 也就相当于call sys_fork,（此时%eax=2，内联函数中设置），进入sys_fork()<br><br>sys_fork函数的源码定义在kernel/system_call.s<br></strong></p><pre><code> sys_fork:        call find_empty_process #为新建进程找到pid号和task数组存放新建进程PCB地址的位置后，返回进程号也即（task数组，的数组号）。        test1 %eax,%eax         #在eax中返回进程号。若返回负数则退出，负数说明返回了-EAGAIN(错误码)。        js  1f  #js跳转指令：sf位（符号位）被置位就跳转。        push    %gs        pushl   %esi        pushl   %edi        pushl   %ebp        pushl   %eax</code></pre><p><strong>此时栈内容为如下接着call copy_process,开始为新进程复制父进程的代码段和数据段:<br></strong><br><img src="https://i.imgur.com/Vz9o1Wk.png" srcset="/img/loading.gif" alt><br><br>copy_process 看这一篇：<a href="https://lexssama.github.io/2020/01/02/copy-process/" target="_blank" rel="noopener">copy_process （）源码分析</a></p><pre><code>        call    copy_process    #调用C函数copy_process()(kernel/fork.c,68)。        addl    $20,%esp        #丢弃这里所有sys_fork内压入栈中的内容。    1:  ret</code></pre><p><strong>/———————————————————————-</strong></p><pre><code>    #下面96-100行查看当前任务的运行状态，如果不在就绪状态（state 不能与0）就去执行调度程序。    #如果任务在就绪状态，但其时间片已用完（counter=0），则也去执行调度程序。    #例如当后台进程组中的进程执行控制终端读写操作时，那么默认条件下该后台进程组所有进程    #会收到SIGTTIN或SIGTTOU信号，导致进程组中所有进程处于停止状态。而当前进程会立刻返回。     movl current,%eax   #取当前任务（进程）数据结构地址-&gt;eax。    cmpl $0,state(%eax)        # state 调用地址=[%eax+state]，因为eax为current所指的task_struct的地址。    jne reschedule    cmpl $0,counter(%eax)        # counter    je reschedule</code></pre><p><strong>reschedule定义在system_call.s中</strong><br></p><pre><code>.align 2reschedule:    pushl $ret_from_sys_call    //保存system_call中标志ret_from_sys_call的地址    jmp schedule        //跳到函数schedule处执行.align 2</code></pre><p>schedule函数看这篇。。。<br><br><strong>-———————————————————————-</strong></p><pre><code>#以下这段代码执行从系统调用C函数返回后，对信号进行识别处理。其他中断服务退出时也将跳转到这里进行#处理后才退出中断过程，例如后面131行上的处理器出错中断int 16。ret_from_sys_call:#首先判别当前任务是否时初始任务task0，如果是则不必对其进行信号量方面的处理，直接返回。#下面的task对应C程序中的task[]数组，直接引用task相当于引用task[0]。    movl current,%eax        # task[0] cannot have signals    cmpl task,%eax    je 3f       #先前（forward）跳转到标号3处退出中断处理#通过对原调用程序选择符的检查来判断调用程序是否是用户任务。如果不是则直接退出中断#这是因为任务在内核态执行时不可抢占。否则对任务进行信号量的识别处理。这里比较选择符是否#为用户代码段的选择符0x000f (RPL=3，局部表，第1个段(代码段))来判断是否为用户任务，如#果不是则说明是某个中断服务程序跳转到第ret_from_sys_call，于是跳转退出中断程序。如果#原堆栈段选择符不为0x17（即原堆栈不在用户段中），也说明本次系统调用的调用者不是用户任务，则也退出。    cmpw $0x0f,CS(%esp)        # was old code segment supervisor ?(CS被定义为0x20就在这个函数的同一个文件内，%esp+0x20正好指向被压入的cs)     jne 3f    cmpw $0x17,OLDSS(%esp)        # was stack segment = 0x17 ?(同CS，OLDSS被定义为0x2C)    jne 3f#下面这段程序用于处理当前任务中的信号。首先去当前任务结构中的信号位图（32位，#每位代表1种信号），然后用任务结构中的信号阻塞（屏蔽）码，阻塞不允许的信号位，取得数值#最小的信号值，再把原信号位图中该信号对应的位复位（置 0），最后将该信号值作为参数之一调用#do_signal()。do_signal()在（kernel/signal.c,82）中，其参数包括13个入栈的信息。    movl signal(%eax),%ebx  #取信号位图-&gt;ebx，每一位代表一种信号，共有32个信号。    movl blocked(%eax),%ecx #取阻塞（屏蔽）信号位图-&gt;ecx。    notl %ecx   #每位取反    andl %ebx,%ecx  #获得许可的信号位图    bsfl %ecx,%ecx  #从低位（位0）开始扫描位图，看是否1的位，                    #若有，则ecx保留该为的偏移值（即第几位0-31）。    je 3f           #如果没有信号则向前跳转退出    btrl %ecx,%ebx  #复位该信号（ebx含有原signal位图）    movl %ebx,signal(%eax)  #重新保存signal位图信息-&gt;current-&gt;signal。      incl %ecx               #将信号调整为从1开始的数（1-32）。    pushl %ecx              #信号值入栈作为调用do_signal的参数之一    call do_signal          #调用C函数信号处理程序（kernel/signal.c，82）    popl %eax               #弹出入栈的信号值。3:    popl %eax               #这个eax中含有入栈的系统调用返回值。    popl %ebx    popl %ecx    popl %edx    pop %fs    pop %es    pop %ds    iret</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>move_to_user_mode（）</title>
    <link href="undefined2019/12/19/move-to-user-mode%EF%BC%88%EF%BC%89/"/>
    <url>2019/12/19/move-to-user-mode%EF%BC%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="move-to-user-mode-源码"><a href="#move-to-user-mode-源码" class="headerlink" title="move_to_user_mode() 源码"></a>move_to_user_mode() 源码</h1><p><strong>move_to_user_mode()被定义在include/asm/system.h</strong><br></p><p>函数move_to_user_mode()是用于内核在初始化结束时人工切换（移动）到初始进程（任务0）去执行，即从特权级0转移到特权级3的代码去执行。所使用的方法是模拟中断调用返回过程，即利用iret指令来实现特权级的变更和堆栈的切换，从而把CPU执行控制流移动到初始任务0的环境中运行。(标志位NT已经在sched_init()中被复位。在NT复位时执行iret指令不会造成CPU执行任务切换操作)</p><p><img src="https://i.imgur.com/9NDo5iM.png" srcset="/img/loading.gif" alt><br></p><pre><code>#define move_to_user_mode() \_asm_( &quot;movl %%esp,%%eax\n\t&quot;\        //保存堆栈指针esp到eax寄存器中，esp=&amp;user_stack[PAGE_SIZE&gt;&gt;2]在head.s中已经被设置好。        &quot;pushl $0x17\n\t&quot;\            //首先将堆栈段选择符（SS）入栈    （ss其实也head.s被设置成0x10但是这里不用）。</code></pre><p><strong>这里解析以下ss其实也head.s被设置成0x10（00010000）也即RPL=0（内核态），TI=0（GDT）偏移地址是0x10。<br><br>但是这里把SS设置为0x17（00010111B）也即是RPL=3（用户态），TI=1（LDT表）,偏移地址是0x10(LDT表中的第三项)，又任务0的LDT表在<a href="https://lexssama.github.io/2019/12/18/sched-init/" target="_blank" rel="noopener">sched_init()</a>中已经被设置好了，代码如下</strong></p><pre><code>set_tss_desc(gdt+FIRST_TSS_ENTRY，&amp;(init_task.task.tss));set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</code></pre><p><strong>设置完后的GDT表的内容：</strong><br><br><img src="https://i.imgur.com/TnrGIX6.png" srcset="/img/loading.gif" alt><br><br><strong>init_task.task.tss和init_task.task.ldt的内容如下：</strong></p><pre><code>{ \        {0,0}, \/* ldt */    {0x9f,0xc0fa00}, \        {0x9f,0xc0f200}, \    }, \/*tss*/    {0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\     0,0,0,0,0,0,0,0, \     0,0,0x17,0x17,0x17,0x17,0x17,0x17, \     _LDT(0),0x80000000, \        {} \    },</code></pre><p>用一张图来表示：<br><br><img src="https://i.imgur.com/uTmwcwS.png" srcset="/img/loading.gif" alt></p><pre><code>        &quot;pushl %%eax\n\t&quot;\            //将保存的堆栈指针值（esp）入栈        &quot;pushfl\n\t&quot;\                    //将标志寄存器（eflags）内容入栈。        &quot;pushl $0x0f\n\t&quot;    \            //将Task0代码段选择符（cs入栈）</code></pre><p><strong>这里CS=0x0f也即（00001111B），RPL=3，TI=1（LDT），偏移地址是0x01（LDT表中的第二项）。</strong></p><pre><code>        &quot;pushl $1f\n\t&quot;\                //将下面标号1的偏移地址（eip）入栈</code></pre><p><strong>！！！注意：这里是$1f而不是$0x1f，$1f表示内联汇编后面的标号1：处的地址。（扩展：参考到本地标签需要后缀f或b，具体取决于您是要向后还是向前 - 即1f引用向后方向上的下一个1:标签。）</strong></p><pre><code>        &quot;iret\n&quot;\                        //执行中断返回指令，则会跳转到下面标号1处</code></pre><p><strong>iret后进入任务0执行，其任务0的主要寄存器图如下：（与上面那张有些许不同。）<br></strong><br><img src="https://i.imgur.com/m3M33uV.png" srcset="/img/loading.gif" alt></p><pre><code>        &quot;1:\tmovl $0x17,%%eax\n\t&quot;\    //此时开始执行任务0。        &quot;movw %%ax,%%ds\n\t&quot;\        //初始化段寄存器指向本局部表的数据段        &quot;movw %%ax,%%es\n\t&quot;\        &quot;movw %%ax,%%fs\n\t&quot;\        &quot;movw %%ax,%%gs&quot;\        : : : &quot;ax&quot;)</code></pre><p><strong>iret指令相当于：</strong><br></p><pre><code>popl eippopl cspopl eflagpopl esppopl ss</code></pre><p><strong>执行完iret后CPU重新取址执行。则跳到1:\tmovl $0x17,%%eax\n\t处执行</strong><br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sched_init()</title>
    <link href="undefined2019/12/18/sched-init/"/>
    <url>2019/12/18/sched-init/</url>
    
    <content type="html"><![CDATA[<h1 id="sched-init"><a href="#sched-init" class="headerlink" title="sched_init()"></a>sched_init()</h1><pre><code>//sched_init()源码： int i;struct desc_struct *p;  //描述符结构指针。</code></pre><p><strong>desc_struct 结构被定义在include/linux/head.h中,具体如下:<br></strong></p><pre><code>typedef struct desc_struct {   //定义了段描述符的数据结构，该结构仅说明每个描述符    unsigned long a,b;  //符由8个字节直接构成，每个描述符表共有256项}desc_table[256];</code></pre><p>Linux 系统开发之初，内核不成熟。内核代码会经常被修改<br><br>linus怕自己无意中修改了这些关键性的数据结构，造成POSIX标准<br><br>的不兼容。这里加入的这个判断语句并无必要，纯粹是为了提醒自己<br><br>以及其他修改内核代码的人。<br></p><pre><code>//sched_init()源码：if(sizeof(struct sigaction)!=16)    //sigaction是存放有关信号状态的结构panic(&quot;Struct sigaction MUST be 16 bytes&quot;);</code></pre><p><strong>panic定义在kernel/panic.c</strong></p><pre><code>void sys_sync(void);//该函数用来显示内核中出现的重大错误信息，并且运行文件系统同步函数，//然后进入死循环-&gt;死机。如果当前进程是任务0的话，还说明是交换任务出错//并且还没有运行文件系统同步函数。函数名前的关键字volatile用于告诉编译器gcc//该函数不会返回。这样可让gcc产生更好一些的代码，更重要的是这个关键字可以避免//某些（未初始化变量的）假警告信息。//等同于现在gcc的函数属性说明：void panic（const char *s）_attribute_((noreturn));volatile void panic(const char *s){    printk(&quot;Kernel panic: %s\n\r&quot;,s);    if(current==task[0])    printk(&quot;In swapper task - not syncing\n\r&quot;);    else    sys_sync();    for(;;);}</code></pre><p>在全局描述符表中设置初始任务（任务0）的任务状态段描述符和局部数据描述符。<br><br><strong>FIRST_TSS_ENTRY(#define FIRST_TSS_ENTRY 4   //全局表中第一个任务状态段（TSS）描述符的选择索引号)</strong><br><br><strong>FIRST_LDT_ENTRY(#define FIRST_LDT_ENTRY （FIRST_TSS_ENTRY+1） //全局表中第1个局部描述符表（LDT）描述符的选择符索引号)值分别是4和5定义在include/linux/sched.h中</strong>；<br><br>gdt是一个描述符表数组（include/linux/head.h），实际上对应程序head.s中的<br>234行上的全局描述符表基址（_gdt）。<br><br>因此gdt+FIRST_TSS_ENTRY即为gdt[FIRST_TSS_ENTRY]即为gdt[4]),也即gdt数组第4项的地址，参见include/asm/system.h，第65行开始。<br></p><pre><code>//sched_init()源码：set_tss_desc(gdt+FIRST_TSS_ENTRY，&amp;(init_task.task.tss));set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</code></pre><p><strong>下面的三个define都是定义在include/asm/system.h。</strong></p><pre><code>////在全局表中设置任务状态段/局部表描述符。状态段和局部表段的长度均被设置成104字节//参数：n -在全局表中的描述符项n所对应的地址；addr -状态段/局部表所在的基地址。//      type - 描述符中的标志类型字节。//%0 -eax(地址addr)；%1 -(描述符项n的地址)；%2 -(描述符项n的地址偏移2处)；//%3 -（描述符项n的地址偏移4处）；%4 -（描述符项n的地址偏移5处）；//%5 -（描述符项n的地址偏移6处）；%6 -（描述符项n的地址偏移7处）；#define set_tssldt_desc (n,addr,type) \ //这里对比计算机系统基础第302页 段描述符图就更好理解_asm_ (&quot;movw $104,%1\n\t&quot;\  //将TSS（或LDT）长度放入描述符长度域【界限】（第0-1字节）       &quot;movw %%ax,%2\n\t&quot;\  //将基地址的低字放入描述符第2-3字节。       &quot;rorl $16,%%eax\n\t&quot;\    //将基地址高字右循环移入ax中（低字则进入高字处）。       &quot;movb %%al,%3\n\t&quot;\  //将基地址高字中低字节移入描述符第4字节。       &quot;movb $&quot;type&quot;,%4\n\t&quot;\   //将标志类型字节移入描述符的第5字节       &quot;movb $0x00,%5\n\t&quot;\ //描述符第6字节置0。       &quot;movb %%ah,%6\n\t&quot;\  //将基地址高字中高字节移入描述符第7个字节。       &quot;rorl $16,%%eax&quot;\    //在右循环16比特，eax恢复原值。       :: &quot;a&quot;(addr),&quot;m&quot;(*(n)),&quot;m&quot;(*(n+2)),&quot;m&quot;(*(n+4)), \       &quot;m&quot;(*(n+5)),&quot;m&quot;(*(n+6)),&quot;m&quot;(*(n+7))\       )////在全局表中设置任务状态段描述符。// n - 是该描述符的指针；addr - 是描述符项中段的基地址。//任务段描述符（TSS）的类型是0x89#define set_tss_desc(n,addr) _set_tssldt_desc(((char *)(n)),addr,&quot;0x89&quot;);////在全局表中设置局部表描述符。// n - 是该描述符的指针；addr -是描述符中段的基地址值。//局部表段描述符(ldt)的类型是0x82。#define set_ldt_desc(n,addr) _set_tssldt_desc(((char *)(n)),addr,&quot;0x82&quot;);</code></pre><p><strong>init_task.task.tss和init_task.task.ldt则是定义在kernel/sched.c</strong></p><pre><code>union task_union {    struct task_struct task;    char stack[PAGE_SIZE];};static union task_union init_task = {INIT_TASK,};</code></pre><p><strong>其中INIT_TASK是被定义在include/linux/sched.h中</strong></p><pre><code>#define INIT_TASK \/* state etc */    { 0,15,15, \/* signals */    0,{{},},0, \/* ec,brk... */    0,0,0,0,0,0, \/* pid etc.. */    0,-1,0,0,0, \/* uid etc */    0,0,0,0,0,0, \/* alarm */    0,0,0,0,0,0, \/* math */    0, \/* fs info */    -1,0022,NULL,NULL,NULL,0, \/* filp */    {NULL,}, \    { \        {0,0}, \/* ldt */    {0x9f,0xc0fa00}, \        {0x9f,0xc0f200}, \    }, \/*tss*/    {0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\     0,0,0,0,0,0,0,0, \     0,0,0x17,0x17,0x17,0x17,0x17,0x17, \     _LDT(0),0x80000000, \        {} \    }, \}</code></pre><p>清任务数组和描述符表项（注意i=1开始，所以刚刚设置初始任务的描述符还在）.</p><pre><code>//sched_init()源码：p=gdt+2+FIRST_TSS_ENTRY;    //不清除前面的6个描述符所以+2for(i=1,i&lt;NR_TASKS;i++){    task[i]=NULL;    p-&gt;a=p-&gt;b=0; //这里是清除TSS    p++;    p-&gt;a=p-&gt;b=0; //P++后这里清除LDT    p++;}</code></pre><p><strong>take[]被定义在include/linux/head.h中</strong><br></p><pre><code>extern struct task_struct *task[NR_TASKS];</code></pre><p><strong>task_struct结构也是被定义在include/linux/head.h中</strong><br></p><pre><code>struct task_struct {/* these are hardcoded - don&#39;t touch */    long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */    long counter;    long priority;    long signal;    struct sigaction sigaction[32];    long blocked;    /* bitmap of masked signals *//* various fields */    int exit_code;    unsigned long start_code,end_code,end_data,brk,start_stack;    long pid,father,pgrp,session,leader;    unsigned short uid,euid,suid;    unsigned short gid,egid,sgid;    long alarm;    long utime,stime,cutime,cstime,start_time;    unsigned short used_math;/* file system info */    int tty;        /* -1 if no tty, so it must be signed */    unsigned short umask;    struct m_inode * pwd;    struct      * root;    struct m_inode * executable;    unsigned long close_on_exec;    struct file * filp[NR_OPEN];/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */    struct desc_struct ldt[3];/* tss for this task */    struct tss_struct tss;};</code></pre><p>清除标志寄存器中的位NT，这样以后就不会有麻烦<br><br>NT标志用于扩展程序的递归调用（Nested Task）。当NT置位时，那么当前中断<br><br>任务执行iret指令时就会引起任务切换。NT指出TSS数据结构中的back_link字段是否有效<br></p><pre><code>//sched_init()源码// pushf 是把堆栈指针esp减去2，使其指向堆栈顶部的空字单元，然后将16位标志寄存器的//内容送向esp指向的字的单元。//pushl作用与pushf一样但却是把32位标志寄存器（标志寄存器原本就是32位）//popf和popfl是弹出。_asm_(&quot;pushfl ; andl $0xffffbfff,(%esp);popfl&quot;); //复位NT标志。</code></pre><p>将任务0的TSS段选择符加载到任务寄存器tr。将局部描述符表段选择符加载到局部描述符表段选择符加载到局部描述符寄存器ldtr中。<br><br>！！注意是将GDT中相应的LDT描述符选择符加载到ldtr。只明确加这一次，以后新任务LDT的加载，是CPU根据TSS中的/LDT项自动加载。<br></p><pre><code>//sched_init()源码ltr(0);     lldt(0);</code></pre><p><strong>下面的4个#define定义在include/linux/sched.h</strong><br></p><pre><code>// 宏定义，计算全局表中第n个任务的TSS段描述符的选择符值（偏移量）。// 因每个描述符占8字节，因此FIRST_TSS_ENTRY&lt;&lt;3表示描述符在GDT表中的起始偏移位置//因为每个任务都使用一个TSS和一个LDT描述符，共占用16个字节因此需要n&lt;&lt;4来表示对应//TSS起始位置，该宏得到的值页正好是该TSS的选择符值。#define _TSS(n) ((((unsigned long)n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3))#define _LDT(n) ((((unsigned long)n)&lt;&lt;4)+(FIRST_LDT_ENTRY&lt;&lt;3))// ltr指令是系统指令，作用是把TSS段选择符加载到任务寄存器中（TR：16位）#define ltr(n) _asm_(&quot;ltr %%ax&quot;::&quot;a&quot;(_TSS(n)))// lldt指令是系统指令，作用是把LDT段选择符加载到任务寄存器中（LDTR：16位）#define lldt(n) _asm_(&quot;lldt %%ax&quot;::&quot;a&quot;(_LDT(n))) </code></pre><p>下面代码用于初始化8253定时器(不懂8253定时器可以看这篇博客：<a href="https://lexssama.github.io/2019/12/16/8253%E5%AE%9A%E6%97%B6%E5%99%A8-%E8%AE%A1%E6%95%B0%E5%99%A8/" target="_blank" rel="noopener">8253定时器/计时器</a>)。通道0，选择工作方式3（方波发生器），二进制计数方式<br><br>通道0的输出引脚接在中断控制主芯片的IRQ0上，它每10毫秒发出一个IRQ请求。<br><br>LATCH是初始定时计数器。<br><br>0x36（00110110）[00（选择计数器0） 11（16位，先读/写低字节，然后再读/写高字节） 011（方式3） 0（2进制计数）]是参数，0x43是端口，写控制字给8253</p><pre><code>//sched_init()源码outb_p(0x36,0x43); //写8253定时器控制字</code></pre><p>这里&amp;与&amp;&amp;区分，&amp;是把两个数转化成二进制数运算，&amp;&amp;是两个值都为true的时候 整体为True<br><br>LATCH &amp; 0xff得到的就是LATCH的低8位，而且8253定时器一次只能传入8位。<br><br>LATCH也是定义在这个函数同一个文件下#define LATCH (1193180/HZ)<br><br>这里的HZ是// HZ定义在include/linux/sched.h头文件中 #define HZ 100<br><br>这里解释以下为什么LATCH要是1193180/HZ（1193180/100）因为8254芯片的时钟输入频率是1.193180MHZ<br><br>而linus希望系统每10ms就发出一个时钟中断请求（IRQ0）信号，所以需要设置计数器的值为1193180/100<br></p><pre><code>//sched_init()源码outb_p(LATCH &amp; 0xff,0x40);    //写定时值低字节outb(LATCH&gt;&gt;8,0x40);    //定时值高字节</code></pre><p><strong>定义在include/asm/io.h</strong></p><pre><code>//硬件端口字节输出函数。//参数：value -欲输入字节；port -端口。#define outb(value,port)\_asm_(&quot;outb %%al,%%dx&quot;::&quot;a&quot;(value),&quot;d&quot;(port))////硬件端口字节输入函数。//参数：port - 端口。返回读取的字节。#define inb(port)（{\unsigned char _v;\_asm_volatile (&quot;inb %%dx,%%al&quot;:&quot;=a&quot;(_v):&quot;d&quot;(port));\_v;\})// 带延迟的硬件端口字节输出函数，使用两条跳转语句来延迟一会（为什么？）// 参数：value -欲输出字节；port -端口。#define outb_p(value,port)\_asm_(&quot;outb %%al,%%dx\n&quot;\   //这里的outb是吧%al的内容写到%dx端口去。            &quot;\tjmp lf\n&quot;\   //向前跳转到标号1处（即下一条语句处）            &quot;1:\tjmp lf\n&quot;\ //先前跳转到标号1处            &quot;1:&quot;::&quot;a&quot;(value),&quot;d&quot;(port))//// 带延迟的硬件端口字节输入函数。使用两条跳转语句来延迟一会。//参数：port -端口，返回读取的字节#define inb_p(port)({\unsigned char _v;\_asm_volatile(&quot;inb %%dx,%%al\n&quot;\                &quot;\tjmp 1f\n&quot;\                &quot;1:\tjmp 1f\n&quot;\                &quot;1:&quot;:&quot;=a&quot;(_v):&quot;d&quot;(port));\                _v;\                })</code></pre><p>设置时钟中断处理程序句柄（设置时钟中断门），修改中断控制器屏蔽码，允许时钟中断。<br><br>然后设置系统中断门，这两个设置中断描述符表IDT中描述符的宏定义<br><br>在文件include/asm/system.h中第33行，39行处，两者的区别参见system.h文件开始处的说明<br><br>设置int0x20中断时时钟中断<br>    //sched_init()源码<br>    set_intr_gate (0x20，&amp;timer_interrupt);</p><p> ~ ：取反运算符，按二进制位进行”取反”运算， &amp;:与指令 <br><br>这里就是读8259A上的IMR(中断屏蔽寄存器)的当前屏蔽字，然后与上11111110B( ~ 0x01)，然后再写OCW1<br></p><pre><code>//sched_init()源码outb(inb_p(0x21)&amp;~0x01,0x21);</code></pre><p>设置int0x80是系统调用中断</p><pre><code>//sched_init()源码set_system_gate(0x80,&amp;system_call);</code></pre><p><strong>设置门描述符宏，定义在include/asm/system.h</strong></p><pre><code>//根据参数中的中断或异常处理过程地址addr，门描述符类型type和特权级信息dpl，设置//位于地址gate_addr处的门描述符。（注意：下面“偏移”值是相对与内核代码或数据来说的）//参数：gate_addr -描述符地址，type-描述类型域值；dpl-描述符特权级，addr -偏移地址#define _set_gate(gate_addr,type,dpl,addr)\_asm_(&quot;movw %%dx,%%ax\n\t&quot;\&quot;movw %0,%%dx\n\t&quot;\&quot;movw %%eax,%1\n\t&quot;\&quot;movl %%edx,%2&quot;\:\:&quot;i&quot;((short)(0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))),\&quot;o&quot;(*((char*)(gate_addr))),\&quot;o&quot;(*(4+(char*)(gate_addr))),\&quot;d&quot;((char*)(addr)),&quot;a&quot;(0x00080000))////设置中断门函数（自动屏蔽随后的中断）。//参数：n -中断号；addr -中断程序偏移地址。//&amp;idt[n]是中断描述符表中中断号n对应项的偏移值；中断描述符的类型是14，特权级是0。#define set_intr_gate(n,addr)\        _set_gate(&amp;idt[n],14,0,addr)////设置陷阱门函数//参数： n -中断号；addr -中断程序偏移地址。//&amp;idt[n]是中断描述符表中 中断号n对应项的偏移值；中断描述符的类型是15，特权级是0#define set_trap_gate(n,addr)        _set_gate(&amp;idt[n],15,0,addr)////设置系统陷阱门函数//上面的set_trap_gate()设置的描述符的特权级是0，而这里是3，因此set_system_gate()//设置的中断处理过程能够被所有的程序执行。例如单步调试，溢出出错和边界超出出错处理//参数：n -中断号；addr -中断程序偏移地址。//&amp;idt[n]是中断描述符表中中断号对应项的偏移地址；中断描述符的类型是15，特权级是3#define set_system_gate(n,addr)\        _set_gate(&amp;idt[n],15,3,addr)</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8253定时器/计数器</title>
    <link href="undefined2019/12/16/8253%E5%AE%9A%E6%97%B6%E5%99%A8-%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <url>2019/12/16/8253%E5%AE%9A%E6%97%B6%E5%99%A8-%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>感谢：《微机原理与接口技术》 主编：陈光军 傅越千<br>和<a href="https://blog.csdn.net/u013007900/article/details/50408903" target="_blank" rel="noopener">SuPhoebe的博客《可编程定时/计数器 8253/8254》</a></strong></p><h1 id="8253定时器-计时器"><a href="#8253定时器-计时器" class="headerlink" title="8253定时器/计时器"></a>8253定时器/计时器</h1><p>微机应用系统常常需要为处理机和外部设备提供实时时钟，以实现延时控制和定时或对外部输入脉冲进行计数，实现这种功能的器件称为定时器/计数器。</p><h2 id="8253的功能与引脚"><a href="#8253的功能与引脚" class="headerlink" title="8253的功能与引脚"></a>8253的功能与引脚</h2><h3 id="8253的基本功能"><a href="#8253的基本功能" class="headerlink" title="8253的基本功能"></a>8253的基本功能</h3><ol><li>8253的基本功能是对外部输入脉冲进行计数，若外部输入的脉冲式连续而均匀的则利用脉冲个数乘以脉冲周期可以计算出时间，从而实现了定时功能。若外部输入脉冲式不均匀的，不连续的非周期脉冲，则8253起计时作用，8253芯片内具有3个独立的16位减法计数器（或称为计数通道），每个计数器性能如下：<br>（1）.最高计数频率2.6MHZ<br>（2）.可编程设定为二进制计数或BCD码计数，有6种工作方式，可编程确定是哪一种工作方式。<h3 id="8253的内部结构"><a href="#8253的内部结构" class="headerlink" title="8253的内部结构"></a>8253的内部结构</h3><img src="https://i.imgur.com/xYyeNcX.png" srcset="/img/loading.gif" alt="8253的内部结构"><br></li><li>数据总线缓存器（Data Bus Buffer）：该缓冲器为8位双向三态，是CPU与8253内部之间的数据传输通道。<br></li><li>读写逻辑电路（Read/Write Logic）：接收CPU送来的读写，片选及地址信号，对8253内部各部件进行操控。<br></li><li>控制字寄存器（Contorl Word register）：每个计数器（count0~count2）都有一个控制字寄存器，用来接收CPU写入的控制字，控制字是8位的只能写不能读，三个计数器的控制字寄存器共用一个控制端口，由写入的控制字的最高两位指明控制字属于哪个通道。<br></li><li>计数器0 ~ 2（count0 ~ count2）：8253包含3个相互独立的、内部结构完全相同的16位减法计数器。每个计数器均包含一个8位的控制字寄存器（Contorl Word register），<strong>一个16位的计数初值寄存器CR，一个16位的减1计数器CE和一个16 位输出锁存寄存器OL</strong><br><br><img src="https://i.imgur.com/SAuNsaM.png" srcset="/img/loading.gif" alt="计数器结构"><br><br>计数器的工作原理：<br><br>写入计数器的初始值保存在计数初值寄存器种，由CLK脉冲的一个上升沿和一个下降沿将其装入减1计数器，减1计数器在CLK脉冲（GATE允许）作用下进行递减计数，直至计数值为0，输出OUT信号。输出锁存寄存器的值跟随减1计数器变化，仅当写入锁存控制字时，它锁存减1计数器的当前值（减1计数器可以继续计数），CPU读取后它自动解除锁存状态，又跟随减1计数器变化。所以在计数过程中，CPU随时可以用指令去任一计数器当前的计数值，这一操作对计数没有影响。</li></ol><h3 id="8253的引脚"><a href="#8253的引脚" class="headerlink" title="8253的引脚"></a>8253的引脚</h3><p><img src="https://i.imgur.com/JOXqHhd.png" srcset="/img/loading.gif" alt="8253的引脚"><br><br>8253为24引脚双列直插式封装结构，其引脚按功能分为与CPU接口引脚和与外设接口引脚，分别如下：<br></p><h4 id="1-与CPU的接口引脚："><a href="#1-与CPU的接口引脚：" class="headerlink" title="1). 与CPU的接口引脚："></a>1). 与CPU的接口引脚：<br></h4><p>D<sub>0</sub>~D<sub>7</sub>:三态双向数据线，与CPU数据总线直接相连。<br><br>\overline{WR}:写控制信号，低电平有效，当\overline{WR}为低电平时表示CPU正在对8253进行写操作。<br><br>\overline{RD}：读控制信号，输入，低电平有效，当\overline{RD}为低电平时表示CPU正在对8253的一个计数器进行读操作。<br><br>A1,A0:地址线，用于端口选择，8253需要占用4个连续的端口地址，这4个端口地址分别对应8253内部的控制寄存器（接收并存放工作方式控制字）和三个计数通道的计数值寄存器（接收并存放计数初值）。具体如下:<br><br>A<sub>1</sub>A<sub>0</sub>=11，选中控制寄存器端口，可以向8253送控制字。<br><br>A<sub>1</sub>A<sub>0</sub>=00，01，10，分别表示选择计数器0，1，2可以对它们读/写计数值&lt;br。<br><br>\overline{CS}:片选信号，低电平有效，当\overline{CS}=0时，8253被选中，允许CPU对其进行读写操作。<br></p><h4 id="2-与外设的接口引脚"><a href="#2-与外设的接口引脚" class="headerlink" title="2).与外设的接口引脚"></a>2).与外设的接口引脚</h4><p>CLK<sub>0</sub> ~ CLK<sub>2</sub>：计数器0、1、2的外部计数时钟输入端。<br><br>GATK<sub>0</sub> ~ GATK<sub>2</sub>：计数器0、1、2的门控信号输入端，门控信号用来禁止，允许或重新开始一个新的计数过程，详情见各工作方式。<br><br>OUT<sub>0</sub> ~ OUT<sub>2</sub>：计数器0、1、2的计数输出端。当定时/计数时间到时，该端输出标志信号。<br></p><h2 id="8253的工作方式"><a href="#8253的工作方式" class="headerlink" title="8253的工作方式"></a>8253的工作方式</h2><p><strong>1.方式0 计数结束产生中断</strong><br><br>采用方式0，当写入控制字CW（Control Word Register）后，OUT信号变为低电平，当将计数初值写入计数初值寄存器CR后，利用下一个CLK脉冲的下降沿将CR的内容装入计数执行单元CE中，再从下一个CLK脉冲的下降沿开始，CE执行减1计数过程，在计数期间，输入OUT一直保持低电平，直到CE的数组讲到0时，OUT变为高电平，以向CPU发送中断申请， 其工作波形如下图所示：<br><br><img src="https://i.imgur.com/oLU4E9L.png" srcset="/img/loading.gif" alt><br><br>当写入控制字后，计数器的输出OUT变成低电平，若门控信号GATE变为高电平，计数器开始减1计数并维持OUT为低电平，当计数器减到0时，输出端OUT变成高电平，并且一直保持到重新装入初值或复位时为止。<br><br>门口信号GATE可以暂停计数，当GATE=0时计数停止，GATE恢复为高电平后继续计数，所以，如果计数过程中，有段时间GATE变为低电平，那么输出端OUT的低电平持续时间会因此而延长相应的长度。<br><br>在计数过程中可以改变计数值，若是8位数，在写入新的计数值后立即开始按新值重新开始计数，若是16位数，写入第一个字节后计数停止，写入第二个字节后立即按新值重新计数（计数的初值的位数由控制字决定）<br><br><strong>2.方式1 可编程单稳态</strong><br><br><strong>3.方式2 分频器</strong><br><br><strong>4. 方式3 方波发生器</strong><br><br><strong>5.方式4 软件触发选通脉冲</strong><br><br><strong>6.方式5 硬件触发选通脉冲</strong><br><br><strong>仅介绍方式0，其他的详细去看书《微机原理与接口技术》 主编：陈光军 傅越千</strong><br><br><img src="https://i.imgur.com/NIcz1fW.png" srcset="/img/loading.gif" alt="8253工作方式"><br><br><strong>注意：（适用于所有工作方式）</strong><br><br><strong>1. 当控制字写入计数器后，所有控制逻辑电路立即处于复位状态（原始状态），计数器输出端OUT进入规定的初始状态。<br></strong><br><strong>2. 计数初值写入计数初值寄存器后，要经过一个时钟周期，计数器才开始计数。<br></strong><br><strong>3. 在时钟脉冲的上升沿对门控信号GATE进行采样。<br></strong><br><strong>4. 计数器真正开始计数时在时钟脉冲的下降沿。<br></strong></p><h2 id="8253的控制字与编程"><a href="#8253的控制字与编程" class="headerlink" title="8253的控制字与编程"></a>8253的控制字与编程</h2><p><strong>1. 工作方式控制字<br></strong><br>8253的控制字的由与CPU链接的引脚D<sub>0</sub>~D<sub>7</sub>送来:<br><br><img src="https://i.imgur.com/nySExdQ.png" srcset="/img/loading.gif" alt="工作方式控制字"></p><p><strong>2.初始化编程<br></strong><br>初始化编程步骤如下图：<br><br><img src="https://i.imgur.com/OOkVsAd.png" srcset="/img/loading.gif" alt="初始化编程"><br><br>关于计数初值，需要说明以下几点：<br></p><ol><li>使用任一计数通道（计数器），首先要向该通道写入方式控制字，以确定该通道的工作方式，写入控制字存入通道对应的控制寄存器中，当控制字D<sub>0</sub>=0时，即二进制计数，初值可以在0000H ~ FFFFH之间选择，初值为0表示最大值65536（2<sup>16</sup>）；当控制字D<sub>0</sub>=1时装入初值为BCD码格式其值可在0000 ~ 9999之间选择，初值为0表示最大值10000（10<sub>4</sub>），在写入指令中还必须写成十六进制数，例如计数初值为79，采用BCD计数，则指令中79必须写操79H.<br></li><li>控制字D<sub>4</sub>D<sub>5</sub>位决定控制字的位数（8位或16位），若为”01”,则只需写入计数值低8位，高8位自动置0，若为“10”，则需要写入计数值的高8位，低8位自动置0；若为“11”，则计数值位16位，分两次写入，必须写低8位，后写高8位。<br></li><li>计数初值要写入各计数器对应的端口地址，计数器0对应A<sub>1</sub>A<sub>0</sub>=00的端口位置，计数器1对应A<sub>1</sub>A<sub>0</sub>=01的端口位置，计数器2对应A<sub>1</sub>A<sub>0</sub>=10的端口位置。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
      <category>main（）函数</category>
      
      <category>sched_init()函数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux-0.11源码分析</tag>
      
      <tag>main（）函数</tag>
      
      <tag>sched_init()函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件类型，属性和目录项</title>
    <link href="undefined2019/12/03/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95%E9%A1%B9/"/>
    <url>2019/12/03/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="文件的类型和属性"><a href="#文件的类型和属性" class="headerlink" title="文件的类型和属性"></a>文件的类型和属性</h1><p>UNIX 类操作系统中的文件通常可分为6类。如果在shell下执行“ls -l”命令我们就可以从所列出的文件状态信息中知道文件的类型。见下图<br><br><img src="https://i.imgur.com/PXvmEXz.png" srcset="/img/loading.gif" alt><br><br>文件类型有“- ，d ，s ，p ，c ，b”六种类型。<br><br><strong>正规文件“-”</strong>：是一类文件系统对其不作解释的文件，包括有任何长度的字节流。例如源文件，二进制执行文件，文档，以及脚本文件。<br><br><strong>目录（d）：</strong>在UNIX文件系统中也是一种文件，但文件系统管理会对其内容进行解释，以使人们可以看到有哪些文件包含在一个目录中，以及它们使如何组织在一起构成一个分层次的文件系统的。<br><br><strong>符号连接（s）：</strong>用于使用一个不同文件名来引用另一个文件。符号连接可以跨越一个文件系统而连接到另一个文件系统中的一个文件上，删除一个符号连接并不影响被连接的文件。另外的还有一种连接方式称为<strong>“硬连接”</strong> 。它与这里所说的符号连接中的被连接文件的抵为相同，被作为一般文件对待，但是不能跨越文件系统，（一个磁盘上可以有多个文件系统）或设备进行连接，并且会递增文件的<strong>连接计数值</strong>（下面解释什么是连接计数值）。<br><br><strong>命名管道（p）：</strong> 文件是系统创建有名管道时建立的文件，可以用于无关进程之间的通信。（还不是很懂，懂了回来解释）<br><br><strong>字符设备（c）：</strong>文件用于以操作文件的方式访问字符设备，例如tty终端，内存设备以及网络设备。（也不是很懂，懂了回来补充）<br><br><strong>块设备（b） ：</strong> 文件用于访问像硬盘，软盘等的设备。在UNIX类操作系统中，块设备文件和字符设备文件一般均存放在系统的/dev目录中。<br></p><p><strong>“rwd”分别表示对文件可读，可写和可执行的许可权。</strong><br></p><p>图中的<strong>“链接计数”位表示文件被硬连接引用的次数。当计数减为零时，该文件即被删除。</strong><br><br>用户名表示该文件宿主的名称。<br><br>组名表示该用户所属组的名称。<br></p><h1 id="文件系统目录项结构"><a href="#文件系统目录项结构" class="headerlink" title="文件系统目录项结构"></a>文件系统目录项结构</h1><p>linux-0.11系统采用的是MINIX文件系统1.0版本。它的<strong>目录结构</strong>和<strong>目录项结构</strong>与传统的UNIX文件的目录项结构相同，定义在include/linux/fs.h文件中。<br><br>在文件系统的一个目录中，其中<strong>所有文件名信息对应的目录项</strong> 存储在<strong>该目录文件名文件的数据块</strong>中。<br><br>例如，目录名root/下的所有 <strong>文件名的目录项</strong> 就保存在 <strong>root/目录名文件的数据块</strong> 中，而文件系统根目录下的所有文件名信息则保存在指定i节点（即1号i节点）的数据块中<br></p><p>这里解释一下：<strong>一个文件（目录文件）由目录项，inode和数据块组成</strong>&lt;可以把Linux中的所有文件都看成目录文件&gt;。<br><br><strong>目录项 :</strong>包括文件名和inode节点（下图的Inode Number）（这个inode节点和inode是两个东西，inode节点是用来在inode table中寻找inode）目录项结构如下图：<br><br><img src="https://i.imgur.com/8dBQ6OI.png" srcset="/img/loading.gif" alt><br><br><strong>inode：（inode table 中的每一项就是一个inode）</strong>又称为文件索引节点，包括文件的基础信息，以及数据块的指针。<br><br><strong>数据块：（Data Blocks）</strong> 包括文件的具体内容。<br><br><img src="https://i.imgur.com/FqhA69j.png" srcset="/img/loading.gif" alt><br></p><p>在打开一个文件时，文件系统会根据给定的文件名找到其i节点号，从而通过其对应i节点号信息找到文件所在的磁盘块位置，见下图，例如对于要查找文件名/usr/bin/vi 的i节点号(如下简略图)，文件系统首先会从具有固定i节点号（1）的根目录开始操作，即从i节点号1的数据块中查找到名称为usr的目录项，从而的得到文件/usr的i节点号。根据文件/usr的i节点号文件系统可以顺利地取得目录/usr的数据块，并在其中可以查找到文件名bin的目录项，这样就知道/usr/bin的i节点号，因而我们就知道目录/usr/bin的目录（数据块）所在的位置，并在该目录中查找到vi文件的目录项，就可以得到文件路径是/usr/bin/vi的i节点号，从而可以在磁盘上的到该i节点号对应的inode（i节点）结构结构信息，。<br><br><img src="https://i.imgur.com/h6qgCRu.png" srcset="/img/loading.gif" alt><br></p><p>通过对用户程序指定的文件名，我们可以找到对应的目录项，根据目录项的i节点就看也找到到i节点表中的相应的i节点结构。<br><br><img src="https://i.imgur.com/iZcIpCz.png" srcset="/img/loading.gif" alt><br><br><strong>每个i节点结构都有一个链接计数器字段i_nlinks记录着指向该节点的目录项数，即文件的硬链接计数值</strong>上图中该字段值为2.在执行删除操作文件时，只有i节点链接计数值为零，内核才会真正删除磁盘文件上该文件的数据。<br></p><p>在每个目录中还包括两个特殊的文件目录项，它们的名称分别是“.”和“..”。<br><br><strong>“.”目录项给出当前目录的i节点号，而”..”目录项给出了当前目录父目录的i节点号(根据在Linux终端上的cd .和 cd ..命令细细体会)</strong><br><br><img src="https://i.imgur.com/q3Ls1dK.png" srcset="/img/loading.gif" alt><br><br>图中示出了我们在i节点号为56的目录中建立了一个mydir子目录，该子目录的i节点号是123，在mydir子目录中的”.”目录项指向自己的i节点123，而其”..”目录项则指向其父目录的i节点56.可见，由于一个目录的目录项本身总数会有两个链接，若其中总是会有两个链接（一个自己，一个父亲），若其中再包括子目录（x，y，z…….等等），那么这些子目录的父目录的i节点链接数就等于2+子目录数。<br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
      <category>文件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux-0.11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统（fs）概述</title>
    <link href="undefined2019/12/02/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88fs%EF%BC%89%E6%A6%82%E8%BF%B0/"/>
    <url>2019/12/02/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88fs%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>本博客大部分搬运于《Linux内核完全注释》赵烔编著，小部分增加一些自己阅读源码过程中遇到问题的解答。<br><br>目的是：希望在自己搬运的过程中，可以加深对Linux-0.11内核的理解和印象。</strong><br></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="总体功能"><a href="#总体功能" class="headerlink" title="总体功能"></a>总体功能</h2><p><img src="https://i.imgur.com/1O1Rf5s.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/Si6oQuQ.jpg" srcset="/img/loading.gif" alt><br><br>FS目录中的各程序中函数之间的引用关系，我们可也把它们从功能上分为四个部分加以讨论：<br><br>第一部分： 是关于高速缓冲区的管理程序，主要实现了对硬盘等块设备进行数据高速存取的函数，该部分内容集中在buffer.c程序中实现。<br><br>第二部分： 代码描述了文件系统的低层通用函数，说明了文件索引节点的管理，磁盘，数据块的分配和释放以及文件名与i节点的转换算法。<br><br>第三部分：程序是有关对文件中数据进行读写操作，包括对字符设备，管道，块读写文件中的数据的访问。<br><br>第四部分： 程序主要涉及文件的系统调用接口的实现，主要涉及文件的打开，关闭，创建以及有关文件目录操作等的系统调用。<br></p><h2 id="MINIX文件系统"><a href="#MINIX文件系统" class="headerlink" title="MINIX文件系统"></a>MINIX文件系统</h2><p>在开发Linux-0.11内核文件时，使用的时1.0版本的MINIX文件系统。<br><br><img src="https://i.imgur.com/82rmjHk.png" srcset="/img/loading.gif" alt><br><br>对于一个360K的软盘，图中整个磁盘被划分为以1KB为单位的磁盘块，因此上图中共有360个磁盘块，每个方格表示一个磁盘块，在MINIX1.0文件系统中，其中磁盘块大小与逻辑块大小正好是一样的，也是一个字节，因此360KB的盘片也含有，在后面的讨论中有时会混合使用。<br></p><p>这里解释一下什么是逻辑块什么是磁盘块：<br><br><strong>磁盘块（block）：</strong>一个block由一个或者多个扇区（sector）组成，是软件（OS，文件系统）中的最小操作单位。<br><br><strong>逻辑块：</strong>逻辑块与物理块的关系类似于虚拟内存中的页与物理内存中的页面的关系。逻辑块的大小必须是物理块大小的整数倍，一般说来，两者是一样大<br><br><img src="https://i.imgur.com/pNwsdtp.jpg" srcset="/img/loading.gif" alt><br></p><h3 id="MINIX文件系统中各块"><a href="#MINIX文件系统中各块" class="headerlink" title="MINIX文件系统中各块"></a>MINIX文件系统中各块</h3><h4 id="引导块（Boot-Sector）"><a href="#引导块（Boot-Sector）" class="headerlink" title="引导块（Boot Sector）"></a>引导块（Boot Sector）</h4><p><strong>引导块是计算机加电启动时可由ROM BIOS自动读入的执行代码和数据。</strong>但并非所有盘都用于作为引导设备，所以对于不用于引导的盘片，这一盘块中可也不含代码，但任何盘片必须含有引导块空间，以保持MINIX文件系统格式的统一。即文件系统只是在块设备上空出一个存放引导块的空间，如果你把内核映像文件放在文件系统中，那么你就可以在文件系统所在设备的第一个块（即引导块空间），存放实际的引导程序，并由它来取得加载文件系统中 的内核映像。<br></p><p><strong>对于硬盘块设备</strong>通常在其上会划分处几个分区，并且在每个分区中都可存放一个不同的完整文件系统。<br><br><img src="https://i.imgur.com/pRGBPCl.png" srcset="/img/loading.gif" alt><br><br>硬盘的第一扇区是主引导扇区，其中存放着<strong>硬盘引导程序（MBR）</strong> 和 <strong>分区表信息</strong>。<br><br>分区表中的信息指明了硬盘上每个分区的类型，在硬盘中起始位置参数和结束位置参数以及占用的扇区总数，参见kernel/blk_drv/hd.c文件后的硬盘分区表结构。<br></p><h4 id="超级块-360KB软盘"><a href="#超级块-360KB软盘" class="headerlink" title="超级块(360KB软盘)"></a>超级块(360KB软盘)</h4><p>超级块用于存放盘设备上文件系统的结构信息，并说明各部分的大小。如下图<br><br><img src="https://i.imgur.com/2RShlbL.png" srcset="/img/loading.gif" alt><br><br>s_ninodes ：记录的这个文件系统上的i节点总数。<br><br>s_nozones ：表示设备上以逻辑块为单位的总逻辑块数。<br><br>s_imap_blocks ：表示i节点位图所占用的磁盘块数（i节点位图（inode bitmap）用来记录使用和未使用的inode表号）<br><br>s_zmap_blocks ：表示逻辑块位图所占用的磁盘块数。(逻辑块位图用于描述每个数据盘的使用情况)<br><br>s_firstdatazone ：表示文件系统上数据区开始处占用的第一个逻辑块块号。<br></p><h4 id="逻辑块位图-360KB软盘"><a href="#逻辑块位图-360KB软盘" class="headerlink" title="逻辑块位图(360KB软盘)"></a>逻辑块位图(360KB软盘)</h4><p><strong>逻辑块位图</strong>用于描述每个数据盘块的使用情况，除了第一个比特位（位0）以外，逻辑块位图中每个比特位依次代表盘上数据区中的一个逻辑块。因此逻辑块位图的比特位1代表盘上数据区中第一个数据盘块，而非盘上的第一各磁盘块（引导快）。当一个数据盘块被占用时，则逻辑块位图中相应比特位被置位。由于当所有磁盘数据盘块都被占用时查找空闲盘块的函数会返回0值，因此逻辑位图最低比特位（位0）闲置不用，并且在创建文件系统时会预先将其设置为1。<br></p><h4 id="i节点位图-360KB软盘"><a href="#i节点位图-360KB软盘" class="headerlink" title="i节点位图(360KB软盘)"></a>i节点位图(360KB软盘)</h4><p><strong>i节点位图</strong>用于说明i节点是否被使用，同样时每个比特位代表一个i节点。对于1k大小的盘块，一个盘块就可表示8192个i节点的使用情况，与逻辑块位图的情况类似，由于所有i节点都被使用时查找空闲i节点的函数会返回0值，因此i节点位图第一个字节的最低比特位（位0）和对应的i节点0都闲置不用，并且在创建文件系统时会预先将i节点0对应比特位图中的比特位置1，因此第一个i节点位图块只能表示8191个i节点的状况。<br></p><h4 id="i节点（360KB软盘）"><a href="#i节点（360KB软盘）" class="headerlink" title="i节点（360KB软盘）"></a>i节点（360KB软盘）</h4><p><strong>注意与i节点位图区分！两者不是同一个东西</strong><br><br>盘上的i节点部分存放着<strong>文件系统中文件或目录名的索引节点</strong> ，每个文件或者目录名都有一个i节点，每个i节点结构存放着对应文件的相关信息。<strong>一个i节点32字节</strong>  如下图<br><br><img src="https://i.imgur.com/V6xk127.png" srcset="/img/loading.gif" alt><br><br><strong>这里重点讲一下i_zone[9]：</strong><br><br>文件中的数据是放在磁盘块的数据区中的，而<strong>一个文件名则通过对应的i节点与这些数据磁盘块相联系，而一个文件则通过它对应的i节点与这些数据磁盘块相联系</strong> ，这些盘块的号码就存放在i节点的逻辑块数据i_zone[]中，其中i_zone[0]~~i_zone[6]用于存放文件开始的7个磁盘号，称为直接块，若文件小于等于7K字节则根据i节点可以很快就找到它所使用的盘块，若文件打一些时，就需要用到<strong>一次间接块</strong>（一次间接块是一个名词）了，这个盘块上存放附加的盘块号。对于MINIX文件系统它可以存放512个盘块号，因此可以寻址512个盘块。若文件还要大，则需要使用二次间接盘块（i_zone[8]），二次间接块可以寻址512<em>512个盘块,如下图<br><br><img src="https://i.imgur.com/t39qaNq.png" srcset="/img/loading.gif" alt><br><br>当所有i节点都被使用的时，查找空闲i节点的函数会返回值0，*</em>因此i节点位图最低比特位和i节点0都不使用，i节点0的结构被初始化成全零**，并在创建文件系统时将i节点0的比特位置位。<br></p><p>对于PC机来讲，一般以一个扇区的长度（512字节）作为块设备的数据块长度，而MINIX文件系统则将两个扇区（1024字节）作为一个数据块来处理，称之为一个磁盘块或盘块，其长度与高速缓冲区的缓冲块长度相同。编号从第一个盘块算起，也即引导快是0号盘块，而上述的逻辑块或区块则是盘块的2的幂次倍数，一个逻辑块长度可以等于1，2，4或8个盘块的长度。对于linux-0.11，逻辑块的长度等于盘块的长度，<strong>因此在代码注释中这两个术语含有相同，但是术语数据逻辑块（或数据盘块）则是指盘设备上数据部分中，从第一个数据盘块开始编号的盘块</strong><br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
      <category>文件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux-0.11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>head.s源码分析</title>
    <link href="undefined2019/11/24/head-s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>2019/11/24/head-s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><strong>感谢：《Linux内核完全注释》作者：赵烔。</strong><br><br><strong>感谢:“ARM的程序员敲着诗歌的梦”的博客：<a href="https://blog.csdn.net/longintchar/article/details/79513086" target="_blank" rel="noopener">https://blog.csdn.net/longintchar/article/details/79513086</a></strong></p><h1 id="head-s程序"><a href="#head-s程序" class="headerlink" title="head.s程序"></a>head.s程序</h1><p>head.s程序在被编译后，会被连接成system模块的最前面的开始部分，这也就是为什么称其为头部（head）程序的原因。从这里开始，内核完全都是在保护模式下运行了。head.s汇编程序与前面的语法格式不同，它采用的是AT&amp;T的汇编语言格式，并且需要使用GNU的gas和gld进行编译连接，因此需要注意代码的赋值的方向是从左到右。<br><br>这段程序实际上处于内存绝对地址（物理地址）0处开始的地方，这个程序的功能比较单一。<br></p><ol><li>首先是加载各个数据段寄存器，重新设置中断描述符表idt，共256项，并使各个表项均指向一个只报错误的哑中断程序。<br></li><li>然后重新设置全局描述符表gdt.<br></li><li>接着使用物理地址0与1M开始处的内容相比较的方法，检测A20地址线是否真的开启（如果没有开启，访问高于1MB物理内存地址使CPU实际上只会访问（IP MOD 1MB）地址的内容）<br></li><li>然后程序测试PC机是否含有数学协处理器芯片（80287，80387，或其兼容芯片），并在控制寄存器（CR0）中设置相应的标志位<br></li><li>接着设置管理内存的分页机制，将页目录表放在绝对物理地址0开始处（也就是本程序所处的物理内存位置，因此这段程序将被覆盖掉（覆盖一部分）），紧随其后面放置共可以寻址16MB内存的4个页表，并分别设置它们的表项。<br></li><li>最后利用返回指令将预先放置在堆栈中的/init/main.c程序入口地址弹出，去运行main（）程序。<br></li></ol><h2 id="1-设置各个数据段寄存器"><a href="#1-设置各个数据段寄存器" class="headerlink" title="1.设置各个数据段寄存器"></a>1.设置各个数据段寄存器</h2><pre><code>.text.globl idt,gdt,pg_dir,tmp_floppy_area_pg_dir:        # 页目录将会存放在这里，把这里的代码覆盖掉.globl startup_32startup_32:    movl $0x10,%eax    mov %ax,%ds    mov %ax,%es    mov %ax,%fs    mov %ax,%gs#lss add，%esp，add是一个内存地址，lss指令会把add内存地址指向的前4个字节装入esp寄存器，把后两个字节装入ss段寄存器。    lss _stack_start,%esp    #lss指令表示把_stack_start地址指向的内容装入ss:esp中，设置系统堆栈</code></pre><p>_stack_start定义在kernel/sched.c中<br></p><pre><code># kernel/sched.c中的\_stack\_start定义，上面的lss指令应该是把&amp; user_stack [PAGE_SIZE&gt;&gt;2]装入esp中把0x10装入ss中。long user_stack [ PAGE_SIZE&gt;&gt;2 ] ;struct {    long * a;    short b;    } stack_start = { &amp; user_stack [PAGE_SIZE&gt;&gt;2] , 0x10 };</code></pre><h2 id="2-设置中断描述符"><a href="#2-设置中断描述符" class="headerlink" title="2.设置中断描述符"></a>2.设置中断描述符</h2><pre><code>call    setup_idt    # 调用设置中断描述符表子程序</code></pre><p> <img src="https://i.imgur.com/lbtwuzL.png" srcset="/img/loading.gif" alt> </p><pre><code>setup_idt:    lea        ignore_int,%edx    #lea是传地址指令，将ignore_int的有效地址送到edx寄存器中    movl    $0x00080000,%eax    #此时 %eax=0x00080000    movw    %dx,%ax    #这里把%dx（ignore_int地址值的0~15位）的值赋给ax也就是eax的0~15位，此时eax=0x00080000+(ignore_int地址值的0~15位)    movw    $0x8E00,%dx      #重新设置edx的0~15位，interrupt gate：dpl=0, present     lea        idt,%edi      # 取idt的偏移给edi （edi目标地址的偏移值）    mov        $256,%ecx     # 循环256次rp_sidt:    movl     %eax,(%edi)     # eax -&gt; [edi]    movl    %edx,4(%edi)    # edx -&gt; [edi+4]    addl    $8,%edi         # edi + 8 -&gt; edi    dec        %ecx    #ecx减一    jne        rp_sidt    lidt    idt_descr       # 加载IDTR（48bit）    ret</code></pre><br><pre><code>idt_descr:    .word 256*8-1       # idt contains 256 entries    .long idt           # IDT 的线性基地址</code></pre><br><pre><code>_idt:     .fill 256,8,0       # idt is uninitialized# 这里idt表没有被初始化共有256项，每项8字节，填0（上面运行setup_idt就是初始化）#  .fill 语法：.fill repeat, size, value，含义是反复拷贝 size个字节，重复 repeat 次# 其中 size 和 value 是可选的，默认值分别为 1 和 0.</code></pre><h2 id="3-设置全局描述符表"><a href="#3-设置全局描述符表" class="headerlink" title="3.设置全局描述符表"></a>3.设置全局描述符表</h2><p>没什么好说的和IDT差不多。<br></p><pre><code>call    setup_gdt    # 调用设置全局描述符表的子程序</code></pre><br><pre><code>setup_gdt:    lgdt gdt_descr # 加载GDTR    ret</code></pre><br><pre><code>gdt_descr:    .word 256*8-1           .long gdt       </code></pre><br><pre><code>gdt:        .quad 0x0000000000000000    /* NULL descriptor */    .quad 0x00c09a0000000fff    /* 16Mb */ #代码段最大长度16MB    .quad 0x00c0920000000fff    /* 16Mb */ #数据段最大长度16MB    .quad 0x0000000000000000    /* TEMPORARY - don&#39;t use */    .fill 252,8,0              /* space for LDT&#39;s and TSS&#39;s etc */</code></pre><h2 id="4-重新加载段寄存器"><a href="#4-重新加载段寄存器" class="headerlink" title="4.重新加载段寄存器"></a>4.重新加载段寄存器</h2><pre><code>movl $0x10,%eax        # reload all the segment registersmov %ax,%ds         # after changing gdt. CS was already。mov %ax,%es         # reloaded in &#39;setup_gdt&#39;mov %ax,%fsmov %ax,%gslss stack_start,%esp</code></pre><p>这里为什么要重新设置一次所有的段寄存器呢（百思不得其姐~想了好久，嘿嘿嘿。）<br><br>原因是：这6个16位的段寄存器（CS,DS,ES,FS,GS,SS）对应着6个描述符高速缓存器。讲到描述符高速缓存器就要说到用户不可见寄存器。<br><br><strong>用户不可见寄存器</strong><br><br>为了支持IA-32的分段机制，除了提供6个段寄存器外，还提供了多个用户不可直接访问的内部寄存器，它们包括描述符cache（也就是上面提到的6个描述符高速缓存器），任务寄存器（TR），局部描述符表寄存器（LDTR），全局描述表寄存器（GDTR）和中断描述符表寄存器（IDTR），如下图。<br><br><img src="https://i.imgur.com/zFxgaFU.jpg" srcset="/img/loading.gif" alt><br><br>虚线内的寄存器就是用户不可见寄存器。<br><br>描述符cache是一组用来存放当前段描述符信息的高速缓存，<strong>每当段寄存器装入新的段选择符时，处理器将段选择符时，处理器将段选择符指定的一个段描述符中的部分信息装入相应的描述符cache中。（这就是为什么要更新段寄存器的原因，没有更改的段寄存器对应的描述符cache中装的时setup.s程序中临时设置的gdt表信息，现在重新设置了gdt表，所以需要更新描述符cache中装的信息）</strong><br><br>这样在进行逻辑地址到线性地址（没有开启分页机制的时候这里就是物理地址）转化的过程中，MMU就直接对应的描述符cache中保存的段地址来形成线性地址LA，而不用每次都去主存访问段表，从而大大节省访问存储器的时间。<br></p><p>这样看来这里就漏了CS没有更新，但是这里不更新CS也是可以的，因为setup.s中的代码段描述符和head.s程序中重新设置的代码段描述符除了段限长（原来的是8MB，现在是16MB）以外其他的部分都相同，8MB的限长在内核初始化阶段不会有问题，而且以后内核执行段间跳转时会重新加载CS，因此这里没有更新CS并没有让程序出错。<br></p><h2 id="检测地址A20线有没有被选通"><a href="#检测地址A20线有没有被选通" class="headerlink" title="检测地址A20线有没有被选通"></a>检测地址A20线有没有被选通</h2><p>下面程序用来测试A20线是否已经被开启。采用的方法时向内存地址0x000000处写入任意一个数值，然后看内存地址0x100000（1M）处是否也是这个数值(如果A20没有打开则，访问0x100000就会回卷，也就相当于访问0x000000)，如果一直相同的化，就一直比较下去，即是死循环，表示地址A20线没有被选通，结果内核就不能使用1MB以上内存<br></p><pre><code>xorl %eax,%eax1:  incl %eax           # check that A20 really is enabled    movl %eax,0x000000  # loop forever if it isn&#39;t    cmpl %eax,0x100000    je 1b</code></pre><h2 id="检查数学协处理器芯片"><a href="#检查数学协处理器芯片" class="headerlink" title="检查数学协处理器芯片"></a>检查数学协处理器芯片</h2><p>下面这段程序用于检查数学协处理器芯片是否存在,方法是修改控制寄存器CR0,<strong>在假设存在协处理器的情况下执行一个协处理器指令</strong>,如果出错的话就说明协处理器芯片不存在,需要设置CR0中的协处理器仿真位EM(位2),并复位协处理器存在标志MP(位1)[如果出错就把EM设为1，MP设为0]<br></p><p>中文维基百科：辅助处理器（英语：Coprocessor），也译作协处理器，这是一种协助中央处理器完成其无法执行或执行效率、效果低下的处理工作而开发和应用的处理器。这种中央处理器无法执行的工作有很多，比如设备间的信号传输、接入设备的管理等；而执行效率、效果低下的有图形处理、声频处理等。为了进行这些处理，各种辅助处理器就诞生了。需要说明的是，由于现在的计算机中，整数运算器与浮点运算器已经集成在一起，因此浮点处理器已经不算是辅助处理器。而内建于CPU中的协处理器，同样不算是辅助处理器，除非它是独立存在。<br></p><p><img src="https://i.imgur.com/7oD2N6J.png" srcset="/img/loading.gif" alt><br><br>PE 指示是否开启保护模式。<br><br>PG 指示是否开启分页<br><br><img src="https://i.imgur.com/Pgdvb1A.png" srcset="/img/loading.gif" alt><br><br>这张图表示协处理器存在的时候设置EM=0，MP=1<br><br>不存在的时候EM=1，MP=0<br></p><pre><code>movl %cr0,%eax          # check math chipandl $0x80000011,%eax  # Save PE ET PGorl $2,%eax                # set MP=1,orl:或&quot; | &quot;指令 0|0=0; 0|1=1; 1|0=1; 1|1=1.movl %eax,%cr0call check_x87jmp after_page_tables</code></pre><br><pre><code>check_x87:    fninit     # 向协处理器发出初始化命令    fstsw %ax  # 把FPU的状态字保存到AX中# fninit向协处理器发出初始化命令，它会将协处理器置于一个未受以前操作影响的已知状态。# 设置控制字为默认值，清除状态字和所以浮点栈式寄存器（非等待形式下的这条指令还会让协处理器终止执行当前正在执行的任何先前的算术操作）#fstsw指令取协处理器的状态字，如果系统存在协处理器的话，fninit指令执行后其状态字低字节肯定为0    cmpb $0,%al    je 1f      # 存在则跳转到标号1处    movl %cr0,%eax        xorl $6,%eax       # 把 eax 的值和 0110b 异或    movl %eax,%cr0    ret    .align 2    #这里.align 2的含义指存储边界对齐调整，“2”表示调整到地址最后两位为0，即按                # 4字节方式对齐内存地址，对齐的目的主要作用式提高CPU的寻址效率。1:  .byte 0xDB,0xE4 /* fsetpm for 287, ignored by 387 */# 0xDB,0xE4这两个字节是 80287 协处理器指令 fsetpm 的机器码。其作用是把 80287 设置为保护模式。# 80387 无需该指令，它会把该指令看作是空操作。    ret</code></pre><h2 id="设置页表，准备开启分页机制"><a href="#设置页表，准备开启分页机制" class="headerlink" title="设置页表，准备开启分页机制"></a>设置页表，准备开启分页机制</h2><p>检查完协处理是否存在后根据下面这条指令跳到 after_page_tables 处设置页目录表和页表准备开启分页机制。<br></p><pre><code>jmp after_page_tablesafter_page_tables:    pushl $0       # main函数的参数envp    pushl $0      # main函数的参数argv    pushl $0      # main函数的参数argc    pushl $L6      # 这个main函数的返回地址，main函数永远不会返回，如果main函数返回就是死循环。    pushl $_main    #main函数的代码的地址。    jmp setup_paging # 设置页目录和页表，并开启分页L6:    jmp L6          # main should never return here, but                    # just in case, we know what happens.</code></pre><br>这个子程序通过控制寄存器CR0的标志（PG位31）来启动对内存的分页处理功能，并设置各个页表项的内容，以恒等映射前16M的物理内存。分页器假定不会产生非法的地址映射<pre><code>setup_paging:    movl $1024*5,%ecx      # 每个页表占用1024个双字（4B），共5个页表    xorl %eax,%eax          # eax = 0    xorl %edi,%edi          # edi = 0    cld;rep;stosl# cld指令是用来操作方向的指令，cld使DF=0让串操作向高地址增加。# rep指令使重复指令，重复ecx次。# stosl指令使串操作指令，将eax中的数据送到目的地址（目的地址默认为es：edi）#这里的目的是首先将5页内存（1页目录+4页页表）清零。#--------接下来这4句用来设置页目录中的项-------------------#因为我们共有4个页表所以页表项也只设置4项就够了，页目录项和页表项结构很相似（图在下方）。#4个字节为一项“$pg0+7”表示0x00001007，是页目录表中的第一项# 则第一个页表所在的地址为=0x00001007&amp;0x00000fff=0x1000；# 第一个页表的属性标志=0x00001007&amp;0x00000fff=0x7，表示该页存在，用户可读可写。    movl $pg0+7,pg_dir     /*pg0，pg1，pg2，pg3 的代码在下面 */    movl $pg1+7,pg_dir+4           movl $pg2+7,pg_dir+8           movl $pg3+7,pg_dir+12      # ------下面6行开始填写4个页表中的所有页表项的内容--------#每项的内容是：当前项映射的物理内存地址+该页标志（这里均为7）.# 这里填写的顺序是从最后一个页表项的最后一项倒退顺序填写。    movl $pg3+4092,%edi        # 这是第4张页表的最后一项    movl $0xfff007,%eax        /*  16Mb - 4096 + 7 (r/w user,p) */    std    # 和cld想对也是控制串操作方向的指令，现在是倒退递减顺序。1:  stosl           /* fill pages backwards - more efficient :-) */    subl $0x1000,%eax    jge 1b    #小于0说明填好了。    xorl %eax,%eax      /* pg_dir is at 0x0000 */    movl %eax,%cr3      /* cr3 - page directory start ，把页目录表的位置送到CR3*/        movl %cr0,%eax    orl $0x80000000,%eax    movl %eax,%cr0      /* set paging (PG) bit （设定PG位开启分页模式）*/    ret         /* this also flushes prefetch-queue */# 在改变分页处理标志后，要求使用转移指令刷新指令队列，这里用的是返回指令ret。# 该返回指令的另一个作用是将堆栈中的main程序的地址弹出，并开始运行/init/main.c程序。#本程序到此为止就真正结束了。</code></pre><br>页目录项和页表项图<br><p><img src="https://i.imgur.com/Lkz8hSe.png" srcset="/img/loading.gif" alt><br></p><p>前12个字节是这个表项对应的页的一些信息：<br></p><p>P: P=1表示页表或者页在主存中，P=0表示不再主存中，此时页故障（缺页异常），需要将页故障线性地址记录在CR2中，操作系统在处理页故障时会将缺失的页表或页从硬盘装入主存中，并重新执行页故障的指令。</p><p>R/W:该位为0时表示页表或者页只能读不能写，为1时表示可读可写。</p><p>U/S：该为为0时表示用户进程不能访问，为1时允许用户进程访问，该位可以保护操作系统所使用的页不受用户进程的破坏。</p><p>PWT: 用来控制页表对应的cache写策略时全写还是回写。</p><p>PCD：用来控制页表或者页能否被缓存到cache中。</p><p>A: A=1表示页或者页表被访问过，初始化时操作系统将其清0，利用该标志，操作系统可以清楚的了解哪些页表或者页正在使用，一般选择长期未用的页或者最少使用的页调出主存。</p><p>D :脏位或者叫修改位，该位在页目录项中没有意义，在页表项中有意义，D=1表示该页被修改过，D=0表示没有被修改过，修改过的页，操作系统在把该页清理出主存时会把它回写到硬盘中。</p><pre><code># .ORG伪指令用来表示起始的偏移地址，紧接着ORG的数值就是偏移地址的起始值。# ORG伪操作常用来指定数据的存储地址，有时也用来指定代码段的起始地址。.org 0x1000   #从偏移 0x1000 处开始放第1个页表 pg0:.org 0x2000   #从偏移 0x2000 处开始放第2个页表pg1:.org 0x3000   #从偏移 0x3000 处开始放第3个页表pg2:.org 0x4000   #从偏移 0x4000 处开始放第4个页表pg3:.org 0x5000   #定义下面的内存数据块从偏移 0x5000 处开始tmp_floppy_area:    #这个是有什么用还不是很懂。。。。。    .fill 1024,1,0  #共保留1024项，每项1字节，填充数值0</code></pre>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>setup.s程序分析</title>
    <link href="undefined2019/11/23/setup-s%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <url>2019/11/23/setup-s%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><strong>感谢：《Linux内核完全注释》作者：赵烔。</strong></p><h1 id="Setup-s程序"><a href="#Setup-s程序" class="headerlink" title="Setup.s程序"></a>Setup.s程序</h1><ol><li>Setup.s程序的主要作用是利用ROM BIOS中断读取系统数据，并将这些数据保存在0x90000开始的位置（覆盖掉了bootsect程序所在的地方），所取得的参数和保留的内存位置如下图。这些参数将被内核中相关的程序使用。<br><br><img src="https://i.imgur.com/eASugFV.jpg" srcset="/img/loading.gif" alt><br></li><li>然后setup.s程序将system模块从0x10000-0x8ffff（当时认为内核系统模块system模块的长度不会超过此值：512KB）整块下移到内存绝对地址0x00000处。</li><li>接下来加载中断描述符寄存器（IDTR）和全局描述符表寄存器（GDTR），开启A20地址线，重新设置两个中断控制芯片8259A(主芯片和从芯片)将硬件中断号重新设置为0x20-0x2f。<br></li><li>最后设置CPU控制器CR0（也称机器状态字），从而进入32位保护模式运行，并跳转到位于system模块最前面部分的head.s程序。<br></li></ol><p>为了能让head.s在32位保护模式下运行，setup.s程序中临时设置了中断描述符表（IDT）和全局描述符表（GDT），并在GDT中设置了当前内核代码段的描述符和数据段描述符，当进去head.s程序中会根据内核需要重新设置这些描述符表<br><br>因此在进入保护模式之前，必须首先设置好要用的段描述符，例如全局描述符表GDT，然后使用指令LGDT把描述符表的基地址告知CPU（GDT表基地址存入GDTR寄存器），再将机器状态字的保护模式标志置位即可进入32位保护模式。<br></p><pre><code>INITSEG = 0x9000         ! 原来的bootsect所处的段SYSSEG = 0x1000          ！system 在 0x10000（64KB）处SETUPSEG = 0x9020      ！本程序所在的段地址.globl begtext , begdata , begbss , endtext , enddata , endbss.text                     !代码段begtext：.data                     !数据段begdata:.bss                        ！未初始化数据段begbss:.textentry startstart:</code></pre><br><h2 id="读光标位置"><a href="#读光标位置" class="headerlink" title="读光标位置:"></a><strong>读光标位置:</strong></h2><pre><code>mov    ax,#INITSEGmov    ds,axmov    ah,#0x03    ! BIOS中断0x10的读光标功能号 ah=0x03。输入：bh=页号；xor        bh,bhint        0x10        ! 返回：ch=扫描开始线；cl=扫描结束线；dh=行号（0x00最顶端）；dl=列号（0x00最左端）mov    [0],dx        ! 把dx的存入ds：0，长度为两个字节。</code></pre><h2 id="读取扩展内存大小"><a href="#读取扩展内存大小" class="headerlink" title="读取扩展内存大小:"></a><strong>读取扩展内存大小:</strong></h2><pre><code>mov    ah,#0x88    ! 调用BIOS中断0x15，功能号：ah=0x88；获取从1M处开始的扩展内存的大小（KB）int        0x15        ! 返回：ax=从0x100000（1M）处开始的扩展内存的大小。mov    [2],ax        ! 将扩展内存大小存储到 ds：[2];</code></pre><h2 id="取显示卡当前的显示模式："><a href="#取显示卡当前的显示模式：" class="headerlink" title="取显示卡当前的显示模式："></a><strong>取显示卡当前的显示模式：</strong></h2><pre><code>mov    ah,#0x0f        ! 调用 BIOS 中断 0x10，功能号 ah = 0x0fint    0x10            ! 返回： ah=字符列数； al=显示模式；bh=当前显示页mov    [4],bxmov    [6],ax</code></pre><h2 id="检查显示方式-EGA-VGA-并获取参数"><a href="#检查显示方式-EGA-VGA-并获取参数" class="headerlink" title="检查显示方式(EGA/VGA)并获取参数"></a><strong>检查显示方式(EGA/VGA)并获取参数<br></strong></h2><p>返回的：<br></p><ol><li>bh=显示状态（0x00-&gt;彩色模式,I/O端口=0x3dX；0x01-&gt;单色模式，I/O端口=0x3bX）；<br></li><li>bl=安装的显示内存（0x00-&gt;64k，0x01-&gt;128k，0x02-&gt;192k，0x03-&gt;256k）；<br></li><li>cx = 显示卡特性参数</li></ol><pre><code>mov    ah,#0x12    mov    bl,#0x10        ! 调用 BIOS 中断 0x10，功能号： ah = 0xl2，子功能号： bl = 0xl0int        0x10        ! 返回：bh=显示状态；bl=安装的显示内存；cx显卡特性参数mov    [8],axmov    [10],bxmov    [12],cx</code></pre><h2 id="取第硬盘信息-Get-hd0-data"><a href="#取第硬盘信息-Get-hd0-data" class="headerlink" title="取第硬盘信息(Get hd0 data)"></a><strong>取第硬盘信息(Get hd0 data)<br></strong></h2><p>取第一个硬盘的信息（复制硬盘参数表），第一个硬盘参数表的首地址是中断向量0x41的向量值(<strong>注意：中断向量0x41存放并不是中断服务向量服务程序的地址</strong>)，第二个硬盘参数表紧接第一个表的后面，中断向量0x46的向量值也指向这第2个硬盘的参数的参数表首地址，表总共的长度是16个字节(0x10)。下面两段程序分别复制BIOS有关两个硬盘的参数表，0x90080处存放第一个硬盘的表，0x90090处存放第2个硬盘的表。<br></p><pre><code>! Get hd0 datamov    ax,#0x0000mov    ds,axlds        si,[4*0x41]     ! hd0参数表的地址：-&gt; ds:si。                        ! LDS DI,[BX]指令的功能是把BX所指的32位地址指针的段地址送入DS,偏移地址送入DI.                        ! 这里等于si&lt;-[4*0x41]mov    ax,#INITSEGmov    es,axmov    di,#0x0080mov    cx,#0x10rep                movsb    !  move string byte，意思是搬移一个字节，它是把 DS:SI 所指地址的一个字节搬移到 ES:DI 所指的地址上! Get hd1 datamov    ax,#0x0000mov    ds,axlds        si,[4*0x46]mov    ax,#INITSEGmov    es,axmov    di,0x0090mov    cx,#0x10repmovsb</code></pre><p>接下来就是检查系统是否存在第2个硬盘，如果不存在则第2个表（0x90090）清零<br><br>利用BIOS中断调用0x13的取盘类型功能。功能号ah=0x15；<br><br><strong>输入：</strong>dl=驱动器号（0x8X是硬盘：0x80指第1个硬盘，0x81指第2个硬盘）<br><br><strong>返回：</strong>ah=类型码（00-没有这个盘，CF置位），01-是软驱，没有change-line支持；02-是软驱（或者其他可移动设备），有change-line 支持；03-硬盘。<br></p><pre><code>mov    ax,#0x01500mov    dl,#0x81int        0x13jc        no_disk1    ! 如果进位标志位（CF）被置位则跳转，即CF被置为1则跳转。表示没有第2个硬盘。cmp        ah,#3je        is_disk1    !如果ah=3则跳转证明是硬盘。</code></pre><p>如果没有硬盘2：<br></p><pre><code>no_disk1:    mov    ax,#INITSEG    mov    es,ax    mov    di,#0x0090    mov    cx,#0x10    mov    ax,#0x00    rep    ! rep和stosb配合使用就是把ax中的内容复制到es：di中，重复cx次。    stosb    </code></pre><p>如果存在硬盘2：<br><br>如果存在硬盘2那就要开始移动system模块移动正确的位置。<br><br>bootsect引导程序是将system模块读入到0x10000（64KB）开始的位置。由于当时的假设system模块最大长度不会超过0x80000（512KB）,即其末端不会超过内存地址0x90000，所以bootsect会将自己移动到0x90000开始的地方，然后把setup加载到它的后面。下面这段程序的用途是再把整个system模块移动到0x00000位置，即把从0x10000到0x8ffff的内存数据块（512KB），整块地向内存低端移动了 0x10000（64KB）的位置。<br></p><pre><code>is_disk1:    cli    !关中断    mov    ax,#0x0000        cld        !cld相对应的指令是std，二者均是用来操作方向标志位DF（Direction Flag）。! cld使DF 复位，即是让DF=0，std使DF置位，即DF=1.这两个指令用于串操作指令中。! 通过执行cld或std指令可以控制方向标志DF，决定内存地址是增大（DF=0，向高地址增加）还是减小（DF=1，向地地址减小）。do_move:    mov    es,ax    ! es=0x0000    add        ax,#0x1000    cmp        ax,#0x9000    jz        end_move     ! 如果零标志被置位就跳转（即ZF=1跳转）,如果已经把0x8000开始的64KB代码移动完就跳转。    mov    ds,ax    ! ds=0x    sub        di,di    sub        si,si    mov    cx,#8000    !每次移动0x8000个字（64KB个字节）    rep    movsw    jmp        do_move</code></pre><p>lidt指令用于加载中断描述符（idt）寄存器，它的操作数是6个字节<br><br>lgdt指令用来加载全局描述符表（gdt）寄存器，其操作数格式与lidt指令相同。全局描述符表中的每个描述符项（8B）描述了保护模式下数据和代码块的信息。<br><br><img src="https://i.imgur.com/JbRKVfW.png" srcset="/img/loading.gif" alt></p><pre><code>end_move    mov    ax,#SETUPSEG    mov    ds,ax    lidt        idt_48    ! 把idt_48的内容装入IDTR寄存器中（48bit）    lgdt        gdt_48    !  把gdt_48的内容装入GDTR寄存器中（48bit）</code></pre><p>idt_48和gdt_48在实际代码中并不是紧随在end_move我为了好看所以提上来。<br><br>.word<br><br>Syntax: .word expressions<br><br>This directive expects zero or more expressions, of any section, separated by commas. For each expression, as emits a 16-bit number for this target.<br><br>我对.word的理解是放一个expression或者多个expression在idt_48(gdt_48)的位置，每个expression用逗号隔开，每个expression占16个bit。<br></p><pre><code>idt_48:    .word     0    ! idt limit=0    .word    0,0    ! idt base=0Lgdt_48:    .word    0x800    !    gdt limit=2048, 256 GDT entries.    .word    512+gdt,0x9    ! 按照GDTR寄存器顺序写入512+gdt在16~32为，0x9在33~47位，那就是相当于0x900...(16个0)+512+gdt。</code></pre><p><img src="https://i.imgur.com/Cq5niWc.jpg" srcset="/img/loading.gif" alt></p><h2 id="开启A20地址线"><a href="#开启A20地址线" class="headerlink" title="开启A20地址线"></a>开启A20地址线</h2><p>在8086/8088中，只有20根地址总线，所以可以访问的地址是2<sup>20</sup>=1M,但由于8086/8088是16位地址模式（16根数据线，20根地址总线），能够表示的地址范围是0-64K，所以为了在8086/8088下能够访问1M内存，inter采取了分段的模式：16位段基地址：16位偏移。其绝对地址（物流地址）的计算方法为：16位基地址左偏移4位+16位偏移=20位地址。<br></p><p>但是这种方式引起了新的问题，通过上述的分段模式，能够表示的最大内存为：FFFFh：FFFFh=FFFF0h+FFFFh=10FFEFh=1M+64K-16Bytes.(1M多余出来的部分被称作高端内存区HMA)。但是8086/8080只有20位地址线，<strong>当程序员给出超过1M（100000h-10FFEFh）地址时系统并不认为其访问越界产生异常，而是自动重新从0开始计算，也就是说系统计算实际地址的时候是按照1M求模的方式进行的</strong>，这种技术被称为wrap-around<br></p><p>到了80286，系统地址总线发展为24根，这样能够访问的内存可达到2<sup>24</sup>。intel 在设计80286时提出的目标是，在实地址模式下，80286以及后续系列，应该和8086/8088完全兼容，但最终80286芯片却存在一个BUG：如果程序员访问100000h-10FFEFh之间内存时，系统将实际访问这块内存，而不是像8086/8088一样重新从0开始。这就存在不兼容问题了<br></p><p>为了解决上述问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数时第20根线），被称作A20Gate：如果A20Gate被打开，则当程序员给出100000h-10FFEFh之间的地址的时候，系统将真正访问这块区域；如果A20Gate被禁止，则程序员给出100000h-10FFEFh之间的地址时，系统仍然使用8086/8088的方式（回卷）<br></p><p><strong>开启A20Gate对保护模式的意义：</strong><br><br>从80286开始，系统出现了一种新的机制，被称作保护模式。到了80386，保护模式得到了进一步的完善和发展，并且对80386以后的芯片，保护模式的变化就非常小了。<br></p><p>如果要访问更多的内存，则必须进入保护模式（<strong>16位寻址变为32位寻址</strong>），那么在保护模式下，A20Gate对内存访问有什么影响？<br></p><p>为了搞清楚这一点，我们先来看一看A20的工作原理，A20其实它就是对于20-bit(从0开始数)的特殊处理（也就是第21根地址线的处理）如果A20Gate被禁止，对于80286来说其地址是24bit，其地址表示为EFFFFF（A20gate被禁止，20位只能为0）；对于80386及其随后的32-bit芯片来说，其地址表示为FFEFFFFF（A20gate被禁止，20位只能为0）。这种表示的意思是如果A20Gate被禁止，则其第20-bit在CPU做地址访问的时候是无效的，永远只能被作为0；如果A20Gate被打开，则其第20-bit是有效的，其值即可以是0，又可以是1.<br></p><p>所以若保护模式下A20被关闭其访问的内存范围：<br><br>0000 00000<del>0000 FFFFF=[0</del>1M-1]bytes<br><br>0010 00000<del>0010 FFFFF=[2</del>2M+1M-1]bytes<br><br>0100 00000<del>0100 FFFFF=[4</del>4M+1M-1]bytes<br><br>0110 00000<del>0110 FFFFF=[6</del>6M+1M-1]bytes<br><br>…………<br><br>综上所述：可以访问的内存范围是：<br><br>0<del>1M,2M</del>3M-1,4M<del>5M-1,6M</del>7M-1<br></p><p><strong>下面程序不认识0x64和0x60端口的可以参考这篇博客：</strong><a href="https://lexssama.github.io/2019/11/20/%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8/" target="_blank" rel="noopener" title="键盘控制器（8042）">键盘控制器（8042）</a></p><pre><code>call    empty_8042    ! 等待输入缓冲器空，只有当输入缓冲器空的时才可以写命令。mov        al,#0xD1    ! 写0x64端口 0xD1命令码，表示准备写Output端口。随后通过60h端口写入的字节，会被放置在Output Port中。out        #64,al    call    empty_8042    ! 等待输入缓冲器空mov        al,#0xDFout        #0x60,al    !通过60h端口写的0xDF被放置再output port中，output port 第二位（1号位）为1代表A20开启call    empty_8042    !输入缓冲器为空，则表示A20地址线已经被开通</code></pre><p>下面是empty_8042,源代码中两者不是相连的<br></p><pre><code>empty_8042:        .word    0x00eb,0x00eb    ! 这是两个跳转指令的机器码（跳转到下一句）作为延时空操作! 这是一道命令，功能是读键盘控制器（8042）状态寄存器，把键盘控制器（8042）的状态寄存器读入al        in    al,#0x64! 测试8042状态寄存器的第二位（位1）该位的功能是：判断键盘的输入缓存器是否满了，满了置1，取走了则是0        text    al,#2        jnz    empty_8042    !输入缓存器满了就跳转回到程序开始，再执行一遍，直到输入缓存器位置0.        ret    </code></pre><h2 id="设置8259芯片"><a href="#设置8259芯片" class="headerlink" title="设置8259芯片"></a>设置8259芯片</h2><p>可编程中断控制器（8259）：具体看这篇博客：<a href="https://lexssama.github.io/2019/11/19/8259A/" target="_blank" rel="noopener">https://lexssama.github.io/2019/11/19/8259A/</a><br></p><pre><code>--------写ICW1----------mov    al,#0x11        ! 0x11表示初始化命令开始是ICW1命令字，表示边沿触发，多片8259级联，最后要发ICW4命令字out        #0x20,al    !写8259A主芯片.word    0x00eb,0x00eb    ! 两条跳转指令，跳到下一条指令，起延时作用out        #0xA0,al    ! 写8259A从芯片.word    0x00eb,0x00eb-------写ICW2----------mov    al,#0x20    out        #0x21,al    ! 写8259A主芯片，送主芯片ICW2命令字，起始中断号，送奇地址.word    0x00eb,0x00ebmov    al,#0x28out        #0xAl,al    ! 写8259A从芯片，送从芯片ICW2命令字的起始中断号.word    0x00eb,0x00eb------写ICW3----------mov    al,#0x04out        #0x21,al    !送主芯片ICW3命令字，主芯片的IR2连从芯片INT .word    0x00eb，0x00ebmov    al,#0x02    out        #0xA1,al    ! 写8259A从芯片，送从芯片ICW2命令字的起始中断号.word    0x00eb,0x00eb-------写ICW4---------mov    al,#0x01out        #0x21,al    ! 送主芯片ICW4命令字。8086模式;普通EOI方式.word    0x00eb,0x00ebout        #0xA1,al    ! 送从芯片ICW4命令字，内容同主芯片.word    0x00eb,0x00eb------写OCW1---------mov    al，#0xFF    out        #0x21，al    ! 屏蔽主芯片所有中断请求.word    0x00eb,0x00ebout        #0xA1，al    ! 屏蔽从芯片所有的中断请求--------end-----------</code></pre><h2 id="进入保护模式跳转到system模块"><a href="#进入保护模式跳转到system模块" class="headerlink" title="进入保护模式跳转到system模块"></a>进入保护模式跳转到system模块</h2><p>这里要设置进入32位保护模式运行。首先要加载机器状态字也称控制寄存器CR0，其比特位0置为1将导致CPU进去保护模式工作。<br></p><pre><code>mov    ax，#0x0001    !保护模式比特位（PE）lmsw    ax    ! lmsw把ax内容装入控制寄存器(CR0)jmpi    0,8    ! 跳转到system模块，这个跳转是保护模式下的跳转和实模式的跳转不同。</code></pre><p><img src="https://i.imgur.com/mMkHGDB.jpg" srcset="/img/loading.gif" alt><br><br>x86_32的CR0为32bit。X86_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit 4其他所有位都是可读可写的。</p><p>Protected-Mode Enable (PE) Bit. Bit0. PE=0,表示CPU处于实模式; PE=1表CPU处于保护模式，并使用分段机制。</p><p>Paging Enable (PG) Bit. Bit 31. 该位控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>键盘控制器</title>
    <link href="undefined2019/11/20/%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <url>2019/11/20/%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>本博客大部分内容来自博客：</strong><a href="http://liurugongzi.blog.sohu.com/158803381.html" target="_blank" rel="noopener">关于键盘的方方面面之一（总论8042）</a><br><br><strong>作者：道恒无名</strong><br><br><strong>小部分是记录自己学习时不明白知识点的查阅和分析</strong><br></p><p><strong>感谢《微型计算机接口技术》<br><br>作者：邓亚平, 陈昌志</strong></p><p>#键盘总论<br>说到键盘就不得不说“键盘控制器”。只有明确键盘的工作原理和其组成之后，才能进一步开始使用代码的形式用信息控制的方式表达。单片微处理器8042，大多集成在南桥中，控制整个键盘的工作。包括加电自检，键盘扫描码的缓冲以及与主板的通讯，8042分输出缓冲和输入缓冲，数据传输在I/O口的60h端口和64和h端口进行，前者是数据口，后者是命令和状态口。<br><br><img src="https://i.imgur.com/r3VFqr4.jpg" srcset="/img/loading.gif" alt><br></p><p>从键盘输入道CPU读取，中间要经历很多过程，但具体可以分为两大块：外设+内部组件，外设指的是键盘，键盘有自己的芯片（8048）。内部组件则是8042和CPU，8048和8042是联通内外的桥梁，也就是说CPU是通过8042与键盘沟通的，8048从外界得到信息输入，通过8042告诉CPU，同样CPU也将直接向8042发送命令，8042在给8048传递，8048的主要工作就是检索来自key matrix的外界输入，所产生的扫描码，将其存放于键盘自身的内部缓冲，而扫描码也因为厂商版本的差异而各自不同，8042的作用还有一个就是用来控制A20 GATE以决定CPU是否可以访问以MB为单位的偶数内存，以及想系统发送reset信号，让主机重新启动，8042还同样支持ps/2类型鼠标。<br></p><p>ps/s类型插口:<br><br><img src="https://i.imgur.com/5aILkQf.jpg" srcset="/img/loading.gif" alt><br></p><p>在键盘系统中，有两根线，Data line和 Clock line，用来对Scan code的检索和传递。如果Data line和Clock line都处于高电平状态，则8048每次检索到一个Scan code ，就会立即将其送到8042芯片，如果Data line 为高电平，而Clock line为低电平，则每次8048每次检索到一个Scan code，不会立即将其发送到8042芯片，而是先将其存放在键盘的内部缓存中，等Clock line 变成高电平后，再将缓冲中的Scan code发送给8042。<strong>如果Data line为低电平，则8048停止对Scan code的检索，转而等待接收来自8042的命令，这种情况下，如果Clock line为高电平，8048则会将接收到的命令的回复数据发送给8042，否则，则无法回复这些命令。所以8042需要向8042发送命令时，必须保证Clock line为高电平。</strong><br></p><p>如果8042芯片收到一个来自于8048芯片的Scan code或者命令回复字节，经处理后（可能存在的解码操作），会将其放入8042的Output buffer中，8042芯片会首先将状态寄存器（Status register）的OBF（Output Buffer Full）标志设置，随后将Output prot的IBF（bit -4）设为1，表示将产生一个IRQ1(中断请求信号，发给8259A)，然后将Clock line置为低电平，以禁止8042进一步接收8048的数据；然后发送一个IRQ1给Inter 8059A可编程中断控制器，由它将中断提交给CPU，CPU收到IRQ后，将调用IRQ对应的ISR（中断服务程序，这就是我们键盘Driver的一个重要部分）。随后此ISR可以从8042的数据端口60H中将Output buffer数据读取出来，并进行进一步的处理。当Output buffer 中的数据被读取出来之后，8042会将状态寄存器的OBF标志清0，然后将Clock line置位高电平，以允许进一步接收8048发送来的数据。<br><br><img src="https://i.imgur.com/vpJSVhT.jpg" srcset="/img/loading.gif" alt> <br><br><img src="https://i.imgur.com/ni1kY9b.png" srcset="/img/loading.gif" alt><br></p><p>8042自身有少量的RAM,以及一些ROM,这些内存与我们常说的内存（称为系统内存）没有任何关系，它们和系统内存不使用相同的地址空间，这些RAM和ROM是8042芯片处理器自身运算的需要。8042还有三个内部端口：<br><strong>Input port</strong>，<strong>Output port</strong>，和<strong>Test port</strong>。<br><br>Output port有System Reset 和A20 Gate 两个与键盘无关的重要的控制位，其他的位都是向8048芯片输出，让8048芯片参考的控制位，程序员最好不要动这些除了System Reset和A20 Gate之外的控制位。IBM AT 和IBM PS/2的这3个端口格式有些许不同，主要因为在IBM PS/2上，8048同时支持PS/2鼠标。<br></p><p><img src="https://i.imgur.com/k6RuTKU.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/DA0MQM4.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/Jnt3UfH.png" srcset="/img/loading.gif" alt><br></p><p>8042本身就是一个小的处理器，有4个8 比特的寄存器，status register （状态寄存器），output buffer（输出缓冲器），input buffer（输入缓存器），control register（控制寄存器）<br></p><p>Status Register （状态寄存器）：状态寄存器是一个8位只读寄存器，任何时刻均可被CPU读取，其作用也如名称一样，是随时用来判断情况的。其各位如下：<br></p><pre><code>Bit7: PARITY-EVEN(P_E): 从键盘获得的数据奇偶校验错误Bit6: RCV-TMOUT(R_T): 接收超时，置1Bit5: TRANS_TMOUT(T_T): 发送超时，置1Bit4: KYBD_INH(K_I): 为1，键盘没有被禁止。为0，键盘被禁止。Bit3: CMD_DATA(C_D): 为1，输入缓冲器中的内容为命令，为0，输入缓冲器中的内容为数据。Bit2: SYS_FLAG(S_F): 系统标志，加电启动置0，自检通过后置1Bit1: INPUT_BUF_FULL(I_B_F): 输入缓冲器满置1，i8042 取走后置0BitO: OUT_BUF_FULL(O_B_F): 输出缓冲器满置1，CPU读取后置0</code></pre><p>control Register （控制寄存器）：是一个可读可写的8 bit寄存器，是用来控制的，其各位的定义如下：<br><br>command byte 不能直接通过60h和64端口读取，若要访问它，必须首先通过64h端口向8042发布相应的命令，然后再通过60h存取；<br></p><pre><code>Bit7: 保留，应该为0Bit6: 将第二套扫描码翻译为第一套Bit5: 置1，禁止鼠标Bit4: 置1，禁止键盘Bit3: 置1，忽略状态寄存器中的 Bit4Bit2: 设置状态寄存器中的 Bit2Bit1: 置1，enable 鼠标中断BitO: 置1，enable 键盘中断</code></pre><p>Output buffer:输出缓冲器是一个8位只读寄存器，驱动从这个寄存器读取数据，这些数据包括：扫描码，送往8042命令的响应。间接的发往8048命令的响应，output buffer 被存放可以通过60h端口读取的数据。这些数据分为两大类：一类是通过64h端口发送的，被用来控制8042芯片的命令的返回结果；另一类则是8048芯片发过来的数据，后者又可以分为Scan code，和对哪些通过60h端口发送给8048的命令回复结果。<br></p><p>Input buffer：<br>输入缓存器是一个8位只写寄存器，缓冲驱动发送来的内容发往8042的命令，通过8042间接发往8048的命令，以及作为命令参数的数据。Input buffer 被用来向8042芯片发送命令与数据，以控制8042芯片和8048芯片。Input buffer 可以通过60h端口和64h端口写入，其中通过64h端口写入时用来控制8042芯片的命令，通过60h端口写入的数据又两种：一种是用来控制8042芯片的命令所需要的进一步数据；另一种是直接发给键盘用来控制8048芯片的命令。<br></p><p>两个I/O端口：60h和64h<br></p><p><img src="https://i.imgur.com/eAioB7w.png" srcset="/img/loading.gif" alt><br></p><p><strong>更多关于键盘的知识可以看这个网站：</strong><a href="https://docs.huihoo.com/gnu_linux/own_os/driver-keyboard_2.htm" target="_blank" rel="noopener">https://docs.huihoo.com/gnu_linux/own_os/driver-keyboard_2.htm</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>键盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8259A</title>
    <link href="undefined2019/11/19/8259A/"/>
    <url>2019/11/19/8259A/</url>
    
    <content type="html"><![CDATA[<p><strong>转载</strong>：<br><br><strong>原作者：ARM的程序员敲着诗歌的梦</strong><br><br><strong>文章源地址</strong><a href="https://blog.csdn.net/longintchar/article/details/79439466" target="_blank" rel="noopener">https://blog.csdn.net/longintchar/article/details/79439466</a>，小部分添加了自己阅读时不明白地方的查阅补充<br></p><h1 id="可编程中断控制器（8259A）"><a href="#可编程中断控制器（8259A）" class="headerlink" title="可编程中断控制器（8259A）"></a>可编程中断控制器（8259A）</h1><p>维基的定义：In computing, a programmable interrupt controller (PIC) is a device that is used to combine several sources of interrupt onto one or more CPU lines, while allowing priority levels to be assigned to its interrupt outputs. When the device has multiple interrupt outputs to assert, it asserts them in the order of their relative priority. Common modes of a PIC include hard priorities, rotating priorities, and cascading priorities.[citation needed] PICs often allow the cascading of their outputs to inputs between each other.<br></p><p>可编程中断控制器（PIC-Programmable Interrupt Controller）就是一个用来把几个不同的中断源集中连接到CPU上的一个装置<br></p><p>可编程中断控制器（PIC）是微机系统（微型计算机，简称“微机系统”，由微型计算机、显示器、输入输出设备、电源及控制面板等组成的计算机系统。配有操作系统、高级语言和多种工具性软件等。）中管理设备中断请求的管理者，当PIC向处理器的INT引脚发出一个中断信号时，处理器会立刻停下当时所做的事情，并询问PIC需要执行哪个中断服务请求。PIC则通过向数据总线发出与中断请求对应的中断号来告知处理器要执行哪个中断服务程序的过程，处理器则根据读取的中断号通过查询中断向量表（32位下是中断描述符）取得相关设备的中断向量（即中断服务程序的地址）并开始执行中断服务程序，当中断服务程序执行结束，处理器就继续执行被中断信号打断的程序。<br></p><h2 id="8259A的级联"><a href="#8259A的级联" class="headerlink" title="8259A的级联"></a>8259A的级联</h2><p>在80x86微机系统中采用了8259A可编程中断控制器芯片，每个8259A芯片可以管理8个中断源，通过多片级联方式，8259能构成最多管理64个中断向量的系统。<br></p><p>在PC/AT系列兼容机中，使用了两片8259A芯片，共可管理15级中断向量，其级联示意图如下：<br><br>级联（cascade）在计算机科学里指多个对象之间的映射关系，建立数据之间的级联关系提高管理效率<br><br><img src="https://i.imgur.com/FYoNuYo.png" srcset="/img/loading.gif" alt></p><p>其中从芯片（从芯片，主芯片两个芯片）的INT引脚上连接到主芯片的IR2引脚上，即8259A从芯片发出的中断信号将作为8259A主芯片的IRQ2输出信号。（我想这就是级联）<br></p><p>IRQ9引脚的作用与IRQ2相同，即PC/AT机利用硬件电路把IRQ2引脚重新定向到PIC的IRQ9引脚上，并利用BIOS中的软件的中断int 71  重新定向到IRQ2的中断0x0A的中断处理过程，这样一来可使任何使用IRQ2的PC/XT的8位设配卡在PC/AT机下面仍然可以正常使用，做到了PC机的向下兼容。<br></p><p><strong>为什么要把IRQ2重定位到IRQ9上？</strong></p><blockquote><p>早期的IBM PC/XT只有一个8259A，这样就只能处理8种IRQ，但很快就发现这根本不能满足需求，所以到了IBM PC/AT 又以级联的方式增加了一个8259A，这样就可以处理多7种IRQ，原来的8259A被称作Master PIC（主PIC），新增的被叫做 Slave PIC （额,奴隶PIC? NO！是从PIC），但由于CPU只有一根中断线，Slave PIC不得不级联在Master PIC 上，占用IRQ2，那么IBM PC/XT 上使用IRQ2的设备将 无法再使用它，但又新的系统又必须和原有系统保持兼容，怎么办?<br><br>由于新增加的Slave PIC再原有系统中不存在，所以设计者从Slave PIC 在IRQ9，要求软件设计者将原来的IRQ2重定向到IRQ9上，也就是说，IRQ9的中断服务程序需要去掉而用IRQ2的中断服务程序，这样将原来接在IRQ2上的设备现在接在IRQ9上，在软件上只需要增加IRQ9的中断服务程序，由它调用IRQ2的中断服务程序，就可以就可以和原有系统保持兼容，而在当时，增加的IRQ9中断服务程序是由PC开发商开发的BIOS提供的，不需要用户另外设置，所以从根本上保证了兼容。<br></p></blockquote><p><strong>IBM_PC_XT：</strong><br><br><img src="https://i.imgur.com/CmR9TSr.jpg" srcset="/img/loading.gif" alt="IBM_PC_XT"><br></p><p><strong>IBM_PC_AT：</strong><br><br><img src="https://i.imgur.com/aL2YX1m.jpg" srcset="/img/loading.gif" alt></p><h2 id="8259A的工作原理"><a href="#8259A的工作原理" class="headerlink" title="8259A的工作原理"></a>8259A的工作原理</h2><p>在总线控制器的控制下，8259A芯片可以处于编程状态和操作状态,编程状态CPU使用IN或OUT指令对8259A芯片进行初始化编程的状态，一旦完成初始化编程，芯片即进入操作状态,此时芯片即可随时响应外部设备提出的中断请求（IRQ0~IRQ15），同时系统还可以使用操作命令字随时修改其中其中断处理方式，通过中断判优选择，芯片将选中当前最高优先级的中断请求作为中断服务对象，然后通过CPU引脚INT通知CPU中断请求的到来，CPU响应后，芯片从数据总线D7-D0将编程设定在当前服务对象的中断号送出，CPU由此获取对应的中断向量值，并执行中断服务程序。<br></p><p><strong>一个8259A芯片的逻辑框图：</strong><br><br><img src="https://i.imgur.com/Jrc0cac.png" srcset="/img/loading.gif" alt><br><br>图中：<br><br>中断请求寄存器IRR（Interrupt Request Register）：用来保存中断请求输入引脚上的所有请求，寄存器的8个比特位（D7-D0）分别对应引脚IR7-IR0<br><br>中断屏蔽寄存器IMR（Interrupt Mask Register）：用于保存被屏蔽的中断请求线对应的比特位，哪个比特位被置1就屏蔽哪一级中断请求，即IMR对IRR进行处理，其每个比特位对应IRR的每个请求比特位。<strong>对高优先级输入线的屏蔽并不会影响低优先级中断请求线的输入。</strong><br><br>优先级解析器PP(Priority Resolver)：用于确定IRR中所设置的比特位的优先级，选通最高优先级的中断请求到正在服务寄存器ISR（In-Service Register）中。<br><br>ISR中保存着正在接受服务的中断请求等级。<br></p><p>Interrupt request register (IRR) ：<br><br>It stores all the interrupt level which are requesting for Interrupt services.<br><br>Interrupt service register (ISR) ：<br><br>It stores the interrupt level which are currently being executed.<br><br>Interrupt mask register (IMR) ：<br><br>It stores the interrupt level which have to be masked by storing the masking bits of the interrupt level.<br></p><p><strong>中断请求过程：</strong><br><br>来自各自设备的中断请求线分别连接在8259A的IR0-IR7引脚上，当这些引脚上有一个或者多个中断请求信号<strong>INTR（Interrupt Request,注意与后面的INTA区分）</strong>到来时，中断请求寄存器IRR中相应的比特位被置位锁存，此时若中断屏蔽寄存器IMR中对应位被置位，则相应的中断请求就不会发送到优先级解析器(PP)中。未屏蔽的中断请求会被送到优先级解析器，优先级最高的中断请求会被选出，此时8259A就会想CPU发送一个INT信号，而CPU则会在执行完当前的一条指令之后向8259A发送一个INTA(中断响应信号)来响应中断信号。8259A在收到这个响应信号之后就会把所选出的最高优先级中断请求保存到正在服务寄存器ISR中，即ISR中的对应比特被置位，与此同时，中断请求寄存器中的对应的比特位被复位，表示该中断请求开始被处理。此后CPU会向8259A发出第2个INTA脉冲信号，该信号用于通知8259A送出中断号，在该脉冲信号期间，8259A就会把一个代表中断号的8位数据发生到数据总线上供CPU读取。<br><br><img src="https://i.imgur.com/QcvFGx4.png" srcset="/img/loading.gif" alt><br><br>到此为止，CPU中断周期结束，如果8259A使用的是自动结束中断（AEOI ,Automatic End of Interrupt）方式，那么在第二个INTA脉冲信号的结尾处，正在服务寄存器ISR中的当前服务中断比特位就会被复位，若8259A使用非自动结束方式，那么中断服务程序结束时，程序就需要向8259A发生一个结束中断（EOI）命令以复位ISR中的比特位，如果中断请求来自级联的第2个8259A芯片，那就需要向两个芯片都发送EOI命令，此后8259A就会去判断下一个最高优先级的中断，并重复上述处理过程。<br></p><p><strong>这几张图要好好看一看</strong><br><strong>8259A芯片引脚图：</strong><br><br><img src="https://i.imgur.com/mD8tUNU.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/npyAFY5.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/4QWN1uF.png" srcset="/img/loading.gif" alt><br><br><strong>8259A芯片引脚的功能图</strong><br><br><img src="https://i.imgur.com/AAXy1yz.png" srcset="/img/loading.gif" alt><br><br><strong>8259A实际图片：</strong><br><br><img src="https://i.imgur.com/F68WRcF.jpg" srcset="/img/loading.gif" alt><br><br>这里解释以下</p><h2 id="8259A的中断优先级"><a href="#8259A的中断优先级" class="headerlink" title="8259A的中断优先级"></a>8259A的中断优先级</h2><h3 id="固定优先级的方式"><a href="#固定优先级的方式" class="headerlink" title="固定优先级的方式"></a>固定优先级的方式</h3><p>在固定优先级方式中，IR7~IR0的中断优先级是由系统决定的，优先级的高低顺序是：IR0，IR1，IR2（如果IR2级联了从芯片则从芯片上的8个中断的优先级也是高于IR3及以后的）….IR7。</p><h3 id="自动循环优先级方式"><a href="#自动循环优先级方式" class="headerlink" title="自动循环优先级方式"></a>自动循环优先级方式</h3><p>在自动循环优先权方式中，IR7~IR0的优先级是可以改变的，而且是自动改变的，其变化规律是：当某一个中断请求IRi服务结束后，该中断的优先级自动降低为最低，而其紧跟在后的中断请求IR（i+1）的优先级自动升级为最高。<br><br>例如，在初始状态IR4有请求，CPU为其服务完毕，IR4的优先级自动将为最低，而其后的IR5的优先级升为最高<br><br>如下图所示：<br><br><img src="https://i.imgur.com/rGw98XR.png" srcset="/img/loading.gif" alt><br></p><p>开始的时候，优先级从高到低是<code>IR0，IR1，IR2,.....,IR7</code>,某时刻，IR4正在被CPU处理。处理完成后，IR4的优先级变为最低，而IR5的优先级变成最高，新的优先级是：<code>IR5,IR6,IR7,IR0,IR1,IR2,IR3,IR4</code>。<br></p><p>在自动循环优先级方式中，又分为：<br></p><ol><li>普通自动循环：IR0~IR7中的初始最低优先级由系统指定，即指定IR7的优先级最低。<br></li><li>特殊自动循环：IR0~IR7中的最低优先级由用户自己指定（通过OCW2寄存器）<br></li></ol><h2 id="中断嵌套方式"><a href="#中断嵌套方式" class="headerlink" title="中断嵌套方式"></a>中断嵌套方式</h2><p>8259A的嵌套方式又分为普通嵌套（normal nested mode）和特殊完全嵌套（The Special Fully Nest Mode）两种<br></p><h3 id="普通嵌套方式"><a href="#普通嵌套方式" class="headerlink" title="普通嵌套方式"></a>普通嵌套方式</h3><p>也叫做完全嵌套或者普通完全嵌套，此方式是8259A在初始化时默认选择的方式。其特点是：IR0优先级最高 ，IR7优先级最低。在CPU中断服务期间，若又新的中断请求到来，只允许比当前服务的优先级更高的中断请求进去，对应于“同级”或“低级”的请求则禁止响应<br></p><h3 id="特殊完全嵌套方式"><a href="#特殊完全嵌套方式" class="headerlink" title="特殊完全嵌套方式"></a>特殊完全嵌套方式</h3><p>其特点是：IR7~IR0的优先级顺序与普通嵌套方式相同；不同之处是CPU中断服务期间，除了允许高级别的中断请求进入外，还允许同级请求进入，从而实现了对同级请求的特殊嵌套。<br></p><p>在多片8259A级联的情况下，主片通常设置为特殊的完全嵌套方式，从片设置为普通嵌套方式，当主片响应某一个从片的中断请求时，从片中的IR0 ~ IR7的请求都是通过某个IRi请求引入，因此从片的IR7 ~ IR0对于主片IR来说，他们属于同级，只有主片工作于特殊完全嵌套状态下，从片才能实现完全嵌套。<br></p><p><strong>我的理解：</strong>主片是：特殊的完全嵌套方式，从片是普通嵌套方式<br><br>则当CPU在处理一个从片的一个IR4请求时，传来一个从片的比IR4优先级高的请求，这时因为从片的请求都要经过主片的IR2，所以对于CPU来说从片的IR3和IR4都是同级，所以不会被主片的优先级排除，所以可以实现从片的高优先级嵌套到从片的低优先级<br></p><h2 id="中断屏蔽方式"><a href="#中断屏蔽方式" class="headerlink" title="中断屏蔽方式"></a>中断屏蔽方式</h2><p>中断屏蔽方式是对8259A的外部中断源IR7~IR0实现屏蔽的一种中断管理方式，又普通屏蔽方式和特殊屏蔽方式两种<br></p><h3 id="普通屏蔽方式"><a href="#普通屏蔽方式" class="headerlink" title="普通屏蔽方式"></a>普通屏蔽方式</h3><p>写入操作命令字OCW1（是一个寄存器，用于对8259A中，中断屏蔽寄存器IMR进行读/写操作），将中断屏蔽寄存器（IMR）的Di位置1，以达到对IRi（i=0~7）中断请求的屏蔽（就是把OCW1寄存器中的数据写入IMR（中断屏蔽寄存器）中）<br></p><p><img src="https://i.imgur.com/SPftWxK.png" srcset="/img/loading.gif" alt><br><br>若Mi=1，则屏蔽对应中断请求级IRi；若Mi=0，则允许相应的IRi，另外屏蔽高优先级不会影响低优先级的中断请求<br></p><h3 id="特殊屏蔽方式"><a href="#特殊屏蔽方式" class="headerlink" title="特殊屏蔽方式"></a>特殊屏蔽方式</h3><p>8259A工作在特殊屏蔽方式时，所有未被屏蔽的优先级中断请求（较高的和较低的）均可在某个中断过程中被响应，即低优先级的中断可以打断正在服务的高优先级中断<br><br>在特殊屏蔽方式中，可在中断服务子程序中用中断屏蔽命令屏蔽当前正在处理的中断级，同时可使其在ISR中的对应位清零，这样一来不仅屏蔽了当前正在处理的中断级，而且也真正开放了较低级别的中断请求，在这种情况下，虽然CPU仍然继续执行较高级别的中断服务子程序，但是由于ISR中对应位已经清零，就如同没有响应该中断一样，此时对于较低级别的中断请求指令，CPU可以响应。<br></p><p><strong>我的理解：</strong>在特殊屏蔽方式中，在中断服务子程序（假设这个正在执行的中断服务程序为“A”）中用一个中断屏蔽命令把IMR的A对应级别置1（屏蔽掉），而在ISR中把A对应的Di位清零（开放），这样就如图没有响应A级别中断一样，就可以响应比A级别高的或者比A级别低的请求<br></p><h2 id="中断结束方式"><a href="#中断结束方式" class="headerlink" title="中断结束方式"></a>中断结束方式</h2><p>中断结束方式是指CPU为某个中断请求服务结束后，应及时清除中断服务标志位，否则就意味着中断服务还在继续，致使比它优先级低的中断请求无法得到响应。中断服务标志位存放在中断服务寄存器（ISR）中，当某个中断源IRi被响应后，ISR中的Di位被置1，服务完毕应及时清除，8259A提供了三种中断结束方式。<br><br>###自动结束方式<br>当ICW4（一个寄存器）中的自动中断结束（AEOI）比特位 置位时，通过CPU发出的第二个中断响应信号INTA脉冲的后沿，将ISR中的中断服务标志位清除，这种中断服务结束方式是由硬件自动完成的<br></p><p>需要注意的是：ISR中为“1”位的清除是在中断响应过程中完成的，并非中断服务子程序的真正结束，因8259A并没有保存任何标志来表示当前服务尚未结束，此时，若有中断请求出现，且IF（标志寄存器EFLAGS中的一位）=1，则无论其优先级如何（比本级高，低或相同）都会得到响应，尤其是当某一个中断请求信号被CPU响应后，如不及时撤销，就会被再次响应（二次中断），这样可能会打乱正在服务的程序，因此这种方式只适用在中断请求信号的持续时间有一定限制，且没有中断嵌套的场合<br></p><h3 id="普通结束方式"><a href="#普通结束方式" class="headerlink" title="普通结束方式"></a>普通结束方式</h3><p>普通结束方式是通过在中断服务子程序编程写入操作命令字OCW2,向8259A传送一个普通中断结束（EOI，end of interrpt） 命令（命令中不指定要复位的中断级）来清除ISR中优先级别最高的置位。<br></p><p>由于这种结束方式是清除ISR中优先级别最高的那个置位，适合在使用完全嵌套方式下，因为在完全嵌套的方式下，中断优先级是固定的，8259A总是响应优先级最高的中断，保存在ISR中的最高优先级的对应位，一定对应于正在执行的服务程序。<br></p><h3 id="特殊结束方式"><a href="#特殊结束方式" class="headerlink" title="特殊结束方式"></a>特殊结束方式</h3><p>特殊结束方式是通过中断服务程子程序中编程写入操作字OCW2，向8259A传送一个特殊的EOI命令（命令中指出要复位的中断级别）来清除ISR中的指定位。<br></p><p>在某些情况下，中断请求的响应顺序并不遵从固定的优先级，比如8259A工作在特殊的屏蔽方式时，低优先级中断可以打断正在服务的高优先级中断，高优先级中断也可以打断正在服务的低优先级中断，此时根据ISR的内容无法确定出刚刚所处理的中断，这就需要EOI命令中指定要复位的中断级。<br></p><h2 id="中断触发方式"><a href="#中断触发方式" class="headerlink" title="中断触发方式"></a>中断触发方式</h2><p>8259中断请求输入端IR7~IR0的触发方式有电平触发和边沿触发两种，由初始化命令字ICW1中的LTIM位来设定<br></p><h3 id="电平触发方式"><a href="#电平触发方式" class="headerlink" title="电平触发方式"></a>电平触发方式</h3><p>当LTIM=1时（寄存器LCW1中的一位）为电平触发方式，当8259A检测到IRi端有高电平时产生中断。在这种触发方式中，要求触发电平必须保持到中断响应信号INTA有效为止，在CPU响应中断后，应及时撤销该请求信号，以防CPU再次响应，出现重复中断现象。<br></p><h3 id="边沿触发方式"><a href="#边沿触发方式" class="headerlink" title="边沿触发方式"></a>边沿触发方式</h3><p>当LTIM=0时，为边沿触发方式，当8259A检测到IRi端有由低到高的跳变（上升沿）信号时产生中断。<br></p><p>##数据总线的连接方式<br>8259A的数据线于系统数据总线的连接有缓冲和非缓冲两种方式<br><br>与缓存有关的引脚：SP/EN：<br><br>SLAVE PROGRAM/ENABLE BUFFER: This is a dual function pin.<br>When in the Buffered Mode it can be used as an output to control<br>buffer transceivers (EN). When not in the buffered mode it is used as<br>an input to designate a master (SP e 1) or slave (SP e 0).</p><h3 id="缓冲方式"><a href="#缓冲方式" class="headerlink" title="缓冲方式"></a>缓冲方式</h3><p>如果8259A通过总线驱动器和系统数据总线连接，则应选择缓冲方式，此时EN为输出引脚，在8259A输出中断类型号时候，EN输出一个低电平，用此信号作为总线驱动器的启动信号。<br><br>在缓冲方式下，由ICW4的M/S位来标识本8259A是主片还是从片<br><br><img src="https://i.imgur.com/SaldsUy.png" srcset="/img/loading.gif" alt><br></p><h3 id="非缓冲方式"><a href="#非缓冲方式" class="headerlink" title="非缓冲方式"></a>非缓冲方式</h3><p>如果8259A的数据线与系统数据总线直接相连，那么应选择非缓冲方式，此时SP为输入引脚，用其电平高低来标识8259A是主片（SP=1）还是从片（SP=0）<br>在非缓冲方式下，ICW4的BUF=0，M/S位无意义<br><br><img src="https://i.imgur.com/cseKaNX.png" srcset="/img/loading.gif" alt></p><h2 id="8259A的编程"><a href="#8259A的编程" class="headerlink" title="8259A的编程"></a>8259A的编程</h2><h3 id="初始化命令字"><a href="#初始化命令字" class="headerlink" title="初始化命令字"></a>初始化命令字</h3><p> 在8259A可以正常工作之前，必须首先设置初始化命令字ICW（Initialization Command Words）寄存器组的内容，而其工作过程中，则可以使用写入操作命令字OCW（Operation Command Words）寄存器组来随时设置和管理8259A的工作方式<br></p><p>A0线（可以看上面的引脚图，是8259A芯片的一个引脚）用于选择操作的寄存器。在PC/AT微机系统中，当A0=0时芯片的端口地址是0x20（主芯片）和0xA0（从芯片）；当A0=1时端口就是0x21（主芯片），和0xA1(从芯片)<br></p><p>初始化命令字的编程操作流程如下图所示，由图可以看出，对ICW1和ICW2的设置是必需的，而只有当系统中包含多片8259A芯片并且是级联的情况下才需要对ICW3进行设置，这需要在ICW1的设置中明确指出，另外，是否需要对ICW4进行设置也需要在ICW1中指明<br></p><p><img src="https://i.imgur.com/W3USeZ1.png" srcset="/img/loading.gif" alt><br></p><h3 id="ICW1-寄存器"><a href="#ICW1-寄存器" class="headerlink" title="ICW1 寄存器"></a>ICW1 寄存器</h3><p>当发送的字节第5个比特位（D4）=1,并且地址线 A0=0时，表示是对ICW1编程，此时对于PC/AT微机系统的多片级联情况下，8259A主芯片的端口位置地址是:0x20,从芯片的端口地址是0xA0；<br><br>ICW1的格式如下：<br><br><img src="https://i.imgur.com/903C1cS.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/OwWgjlt.png" srcset="/img/loading.gif" alt><br><br>在Linux-0.11内核中，ICW1被设置为0x11。表示中断请求是边沿触发，多片8259A级联并且需要发送ICW4。<br></p><h3 id="ICW2-寄存器"><a href="#ICW2-寄存器" class="headerlink" title="ICW2 寄存器"></a>ICW2 寄存器</h3><p>ICW2用于设置芯片送出的中断号的高5位。在设置了ICW1之后，当A0=1时表示对ICW2时表示对ICW2进行设置。此时对于PC/AT微机系统的多片级联情况下，8259A主芯片的端口位置是0x21，从芯片的端口位置是：0xA1。<br></p><p>ICW2的格式如下<br><br><img src="https://i.imgur.com/JLTstZP.png" srcset="/img/loading.gif" alt><br></p><p>在使用8086/88处理器的系统或兼容系统中，T7 ~ T3是中断号的高5位，与8259A芯片自动设置的低3位（8259A按IR0 ~ IR7三位编码自动填入），组成一个8位的中断号，8259A在收到第2个中断响应脉冲时会把中断号送到数据总线上供CPU读取。<br></p><p><img src="https://i.imgur.com/oAMrBPv.png" srcset="/img/loading.gif" alt><br></p><p>Linux-0.11系统把主片的ICW2设置位0x20，表示主片中断请求0 ~ 7级对应的中断号是<code>0x20 ~ 0x27</code>;把从片的ICW2设置为0x28，表示从片中断请求8 ~ 15级对应的中断号是0x28 ~ 0x2f。</p><h3 id="ICW3-寄存器"><a href="#ICW3-寄存器" class="headerlink" title="ICW3 寄存器"></a>ICW3 寄存器</h3><p><img src="https://i.imgur.com/kITYIEW.png" srcset="/img/loading.gif" alt><br><br>主芯片的端口地址是0x21，从芯片地址是0xA1<br></p><p>对于主片，Si=1，表示IRi接从INT引脚。就是主片S7~S0各比特位对于级联的从片。哪位为1则表示主片的该中断请求引脚IR上的信号来自从片，否则对应的IR引脚上没有从片<br></p><p>对于从片，ID2 ~ ID0三个比特位对应各从片的标识号，即连接到主片的中断级。当某个从片接收到级联线（CAS2-CAS0）输入的值与自己的ID2 ~ ID0相等时，表示此从片被选中，此时该从片应该向数据总线发送自己当前被选中的中断请求的中断号。<br></p><p>Linux-0.11内核把8259A主片的ICW3设置为0x04，即S2=1，其余各位为0，表示主芯片的IR2引脚连接一个从芯片。从芯片的ICW3被设置为0x02，即标识号为2。表示此从片连接到主片的IR2的引脚，因此，中断优先级的排列次序为：<br>0级位最高级，1级次之，接下来是从片上的8 ~ 15级，最后是主片上的3 ~ 7级。<br></p><h3 id="ICW4-寄存器"><a href="#ICW4-寄存器" class="headerlink" title="ICW4 寄存器"></a>ICW4 寄存器</h3><p>当ICW1的位0（IC4）置位时，表示需要ICW4.地址线A0=1，主芯片的端口是0x21，从芯片的端口地址是0xA1。<br><br><img src="https://i.imgur.com/Fhdx0Ax.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/dUtsn8F.png" srcset="/img/loading.gif" alt><br><br>Linux-0.11内核送往8259A主芯片和从芯片的ICW4命令字的值均为0x01，表示8259A芯片被设置成普通全嵌套，非缓冲，非自动结束中断方式，并且用于8086及其兼容系统。<br></p><h2 id="操作命令字寄存器"><a href="#操作命令字寄存器" class="headerlink" title="操作命令字寄存器"></a>操作命令字寄存器</h2><p>对8259A设置了初始化命令字后，芯片就已经准备好接收设备的中断信号了，但在8259A工作期间，我们也可以利用操作命令字OCW1~OCW3 来监测8259A的工作状况，或者随时改变初始化时设定的8259A的工作方式。<br></p><p>需要说明的是，与初始化命令字ICW1<del>ICW4需要按规定的顺序进行设置不同，操作命令字OCW1</del>OCW3的设置没有规定其先后顺序，使用时根据需要灵活选择不同的操作命令字写入到8259A中。<br></p><h3 id="OCW1-寄存器"><a href="#OCW1-寄存器" class="headerlink" title="OCW1 寄存器"></a>OCW1 寄存器</h3><p>OCW1 用于对8259A中中断屏蔽寄存器IMR进行读/写操作。地址线A0需为1。<br><br><img src="https://i.imgur.com/dxGevGN.png" srcset="/img/loading.gif" alt><br></p><p>若Mi=1，则屏蔽对应的请求级IRi，若Mi=0，则允许IRi，另外，屏蔽高的优先级并不会影响其他低优先级的中断请求。<br></p><p>在Linux-0.11内核初始化过程中，代码在设置好相关的设备驱动程序后就会利用该操作命令字来修改相关的中断请求屏蔽位。例如在软盘驱动初始化结束时，为了允许软驱设备发出中断请求，就会读端口0x21以取的8259A芯片的当前屏蔽字，然后与上~0x40来复位M6（软盘控制器控制器连接到了中断请求IR6上），最后再写回中断屏蔽寄存器中。<br></p><h3 id="OCW2-寄存器"><a href="#OCW2-寄存器" class="headerlink" title="OCW2 寄存器"></a>OCW2 寄存器</h3><p><img src="https://i.imgur.com/RbZMylj.png" srcset="/img/loading.gif" alt><br></p><p>Linux-0.11内核仅使用该操作命令字在中断处理过程结束之前向8259A发送结束中断（EOI）命令，所使用的OCW2值为0x20，表示为固定优先级，正常的EOI中断结束命令<br></p><h3 id="OCW3-寄存器"><a href="#OCW3-寄存器" class="headerlink" title="OCW3 寄存器"></a>OCW3 寄存器</h3><p>OCW3用于设置或清除特殊屏蔽方式和读取寄存器状态（IRR和ISR）。当D4D3=01，且地址线A0=0时，表示对OCW3进行编程，在Linux-0.11内核中没有使用该操作命令字。<br></p><p><img src="https://i.imgur.com/mjEQJJG.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/Vukfd9R.png" srcset="/img/loading.gif" alt><br></p><h4 id="POLL-Mode"><a href="#POLL-Mode" class="headerlink" title="POLL Mode"></a>POLL Mode</h4><p>当INT输出引脚不使用或者CPU内部中断允许标志为0时，外部设备无法向CPU传递有效的中断请求信号，在这种情况下，可以采用查询模式。还有，当系统的中断源很多，超过了64个，也可以使用查询模式<br></p><p>在OCW3的P位置为1后下一个可读命令，8259A看作是CPU的中断响应信号，8259A把IRR相应位清0，ISR对应位置1，并把查询字送到数据总线。读命令从数据总线上读取查询字，其格式为：<br></p><p><img src="https://i.imgur.com/qlpvExn.png" srcset="/img/loading.gif" alt><br></p><p>D7位 I=0：表示没有中断；<br><br>D7位 I=1：表示此片8259A有中断请求，W2~W0即为最高优先级中断请求。<br></p><h2 id="命令字端口地址速查表"><a href="#命令字端口地址速查表" class="headerlink" title="命令字端口地址速查表"></a>命令字端口地址速查表</h2><p><img src="https://i.imgur.com/Ic6OEpb.png" srcset="/img/loading.gif" alt><br></p><p><strong>转载</strong>：<br><br><strong>原作者：ARM的程序员敲着诗歌的梦</strong><br><br><strong>文章源地址</strong><a href="https://blog.csdn.net/longintchar/article/details/79439466" target="_blank" rel="noopener">https://blog.csdn.net/longintchar/article/details/79439466</a>，小部分添加了自己阅读时不明白地方的查阅补充<br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>8259A</tag>
      
      <tag>Linux-0.11源码阅读</tag>
      
      <tag>setup.s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootsect.s源码分析</title>
    <link href="undefined2019/11/17/bootsect-s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>2019/11/17/bootsect-s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本博客大部分搬运于《Linux内核完全注释》赵烔编著，小部分增加一些自己阅读源码过程中遇到问题的解答。<br><br>目的是：希望在自己搬运的过程中，可以加深对Linux-0.11内核的理解和印象。<br><br>感谢：<a href="https://blog.csdn.net/longintchar/article/details/79323783" target="_blank" rel="noopener">https://blog.csdn.net/longintchar/article/details/79323783</a><br><a href="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md" target="_blank" rel="noopener" title="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md">https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md</a></p><h1 id="Bootsect-s"><a href="#Bootsect-s" class="headerlink" title="Bootsect.s"></a>Bootsect.s</h1><p>bootsect.s代码时磁盘引导块程序，驻留在磁盘的第一个扇区中（引导扇区，0磁道（柱面），0磁头，第一个扇区）。在PC机加电ROM BIOS自检后，引导扇区由BIOS加载到内存，0x7C00处，然后将自己移动到内存0x90000处，该程序的主要作用是首先将setup模块（由setup.s编译成），从磁盘加载到内存，紧接在bootsect的后面位（0x90200），然后利用BIOS中断0x13取磁盘参数表中当前启动引导盘的参数，接着在屏幕上显示“Loading system…”字符串，再将system模块从磁盘上加载到内存0x10000开始的地方，随后确定根文件系统的设备号，若没有指定，则根据所保存的引导盘的每磁道扇区数判别出盘的类型和种类（是1.44MB的A盘？）并保存其设备号于root_dev（引导块的508地址处），最后长跳到setup程序的开始处（0x90200）执行setup程序。<br></p><pre><code>SYSSIZE = 0x3000  ;system模块的长度.globl begtext, begdata, begbss, endtext, enddata, endbss.textbegtext:.databegdata:.bssbegbss:.textSETUPLEN = 4                ! setup模块的长度，4个扇区BOOTSEG  = 0x07c0           ! original address of boot-sectorINITSEG  = 0x9000           ! bootsect把自身搬运到0x90000SETUPSEG = 0x9020           ! setup模块被加载到 0x90200SYSSEG   = 0x1000           ! system模块被加载到0x10000ENDSEG   = SYSSEG + SYSSIZE ! where to stop loading, 0x1000 + 0x3000 = 0x4000, 停止加载的段地址(加载system模块时使用)ROOT_DEV = 0x306            !第2个硬盘的第1个分区   !这里开始把bootsect.s程序复制到0x90000去。entry _start_start:    mov ax,#BOOTSEG     mov ds,ax      !ds = 0x07c0    mov ax,#INITSEG    mov es,ax      !ex = 0x9000    mov cx,#256    !搬运256次    sub si,si      !si = 0    sub di,di      !di = 0                   !ds:si=0x07c0:0x0, es:di=0x9000:0x0    rep    movw           !每次搬运2个字节    jmpi go,INITSEG   !跳转到 0x9000:go （jmpi是段内跳转指令跳转目的地是INITSEG:go）  ! 这里开始设置栈，为的是待会装入setup程序go: mov ax,cs    mov ds,ax    mov es,ax     !ds=es=cs=0x9000    mov ss,ax    mov sp,#0xFF00                    !es:sp = 0x9000:0xff00 ，栈的设置    ! dx，cx，bx，ax都是传递给in0x13中断服务程序的参数load_setup:    mov dx,#0x0000      ! 驱动器号(DL)0，磁头号(DH)0    mov cx,#0x0002      ! 起始扇区号CL=2, 磁道号（柱面号），CH=0    mov bx,#0x0200      ! 偏移地址0x200,(setup程序读入的开始地址es：bx，es在上面程序已经设置成0x9000，所以就是将setup程序读到0x90200处)    mov ax,#0x0200+SETUPLEN ! 功能号AH=0x02,AL=要读的扇区数目=SETUPLEN=4 （in0x13的AH=0x02的中断服务程序功能是读软盘或硬盘上的若干物理扇区到内存的ES:BX处）    int 0x13            ! read it（当载入出现错误则把CF置成1，把出错的代码位置送到AH，返回实际读到的扇区数给AL）    jnc ok_load_setup   ! ok - continue（如果CF（进位标志）=0，则跳转，因为上面中断服务程序如果出错就把CF置为1,CF=0代表没有出错则跳转）    ! 如果上面载入出错则执行这一步    mov dx,#0x0000      !需要复位的驱动器号=DL=0    mov ax,#0x0000      !功能号AH=0（int0x13的AH=0，执行中断服务程序中的复位程序）    int 0x13            ! 复位磁盘    j   load_setup    !如果没有出错则跳到这一步执行,这一步的目的主要是把一些磁盘信息存入到0x90000处。ok_load_setup:! Get disk drive parameters, specifically nr of sectors/track    mov dl,#0x00    !驱动器号为0，说明是软盘    mov ax,#0x0800  ! AH=8 is get drive parameters（INT 13H AH=08H：读取驱动器参数）    int 0x13    mov ch,#0x00    !这里用不上软盘的最大磁道号，可以使CH=0    seg cs          !把段超越前缀设置为cs,（段超越指的是把默认的段地址寄存器改成自己希望的段地址寄存器）只影响下一条语句    mov sectors,cx  ! 把cx寄存器中的内容装入cs:[sectors]处。（sectors在后面有定义）    !保存每磁道最大扇区数。对于软盘，最大磁道号不会超过256，所以CH足以表示，CL[7:6]为0    mov ax,#INITSEG    mov es,ax       !因为上面ES的值被修改，所以令ES=0x9000    mov ah,#0x03    !读光标的位置    xor bh,bh       !bh=页号    int 0x10        ! INT 10H AH=03H：获取光标位置和形状    mov cx,#24          ! 24个字符    mov bx,#0x0007      ! page 0, attribute 7 (normal)    mov bp,#msg1        ! 在代码后面有定义    mov ax,#0x1301      ! write string, move cursor    int 0x10 ! ok, we&#39;ve written the message, now ! # we want to load the system (at 10000h)  现在开始将system 模块加载到10000h(64k)处。    mov    ax,SYSSEG    mov    es,ax        ;! segment of 010000h  es = 存放system的段地址。    call read_it            ; !读磁盘上system模块，es为输入参数。    call kill_motor        ;! 关闭驱动器马达，这样就可以知道驱动器的状态了。 !call read_it时程序跳到下面read_it处执行!call kill_motor时程序跳到kill_motor处执行!此后，我们检查要使用哪个根文件系统设备（简称根设备）。如果已经指定了设备（!=0）! 就直接使用给定的设备。否则就需要根据BIOS报告的每磁道扇区数来! 确定到底使用/dev/PS0(2,28)还是/dev/at0(2,8)。!        上面一行中两个设备文件的含义：!        在Linux中软驱的主设备号是2（参加第43行注释），次设备号 = type*4 + nr, 其中!        nr为0－3分别对应软驱A、B、C或D；type是软驱的类型（2-&gt;1.2M或7-&gt;1.44M等）。!        因为7*4 + 0 = 28，所以/dev/PS0(2,28)指的是1.44M A驱动器，其设备号是021c!    同理 /dev/at0(2,8)指的是1.2M A驱动器，其设备号是0208。    seg cs    mov    ax,root_dev    cmp ax,#0    jne    root_defined    ! 如果 ax != 0, 转到root_defined    seg cs    mov    bx,sectors        !取上面保存的每磁道扇区数。如果sectors=15                        !则说明是1.2Mb的驱动器；如果sectors=18，则说明是                        ! 1.44Mb软驱。因为是可引导的驱动器，所以肯定是A驱。    mov    ax,#0x0208        ! /dev/ps0 - 1.2Mb    cmp bx,#15            ! 判断每磁道扇区数是否=15    je    root_defined    !如果等于，则ax中就是引导驱动器的设备号。    mov    ax,#0x021c            ! /dev/PS0 - 1.44Mb    cmp     bx,#18    je    root_definedundef_root:                ! 如果都不一样，则死循环（死机）。    jmp undef_rootroot_defined:    seg cs    mov    root_dev,ax        ! 将检查过的设备号保存起来。! 到此，所有程序都加载完毕，我们就跳转到被! 加载在bootsect后面的setup程序去。    jmpi    0,SETUPSEG        !跳转到9020:0000（setup程序的开始处）。sread:  .word 1+SETUPLEN !当前磁道已经读取的扇区数, 前面的1表示引导扇区bootsect.shead:   .word 0          ! current head，当前磁头号track:  .word 0          ! current track，当前磁道号read_it:    mov ax,es    test ax,#0x0fff     !使ax与0xfff按位与，测试es是否为0x1000的整数倍die:    jne die         !结果不为0（说明es不是0x1000的整数倍）则陷入死循环    xor bx,bx           ! bx（作为段内偏移地址）清零rp_read:    mov ax,es    cmp ax,#ENDSEG      ! 实际上求(ax-ENDSEG)    jb ok1_read         ! 当CF=1（ax&lt;ENDSEG, 有借位）时跳转到ok1_read    ret                 ! 当ax&gt;=ENDSEG时返回（我认为不会出现大于的情况）ok1_read:    seg cs    mov ax,sectors      ! 这两句相当于 mov ax, cs:[sectors]; 获得每磁道扇区数    sub ax,sread        ! ax = ax - sread, 得出本磁道未读扇区数    mov cx,ax    shl cx,#9           ! cx乘以512，求出字节数    add cx,bx           ! 以上3行相当于 cx = ax * 512 + bx                        ! 假设再读ax个扇区，cx就是段内共读入的字节数    jnc ok2_read        ! 若cx &lt; 0x10000（CF=0,没有进位）则跳转到ok2_read    je ok2_read         ! 若cx = 0（ZF=1），说明刚好读入64KB，则跳转到ok2_read    xor ax,ax            ! ax = 0x0000    sub ax,bx            ! 求bx对0x10000的补数，结果在ax中    shr ax,#9            ! 除以512,得到扇区数，AL作为参数，传给read_trackok2_read:                   call read_track  ！调用read_track过程，用AL传参,读取AL个扇区到ES:BX    mov cx,ax        ！cx是该次操作已经读取的扇区数    add ax,sread     ！ax是当前磁道已经读取的扇区数    seg cs    cmp ax,sectors       jne ok3_read     ！如果当前磁道还有扇区未读，跳转到ok3_read    mov ax,#1        ！说明当前磁道的扇区都已读完    sub ax,head      ！ax = 1 - 磁头号    jne ok4_read     ！不为0则跳转到 ok4_read，说明磁头号为0    inc track        ！说明磁头号为1，磁道号增加1ok4_read:    mov head,ax  !更新磁头号（如果是37行跳转过来，则 head=1；否则 head=0）    xor ax,ax    !ax=0, 因为更换了磁道，所以当前磁道已读扇区数置0ok3_read:    mov sread,ax      ！更新当前磁道已经读取的扇区数    shl cx,#9           ! ok2_read处有更新cx。    add bx,cx         ！更新偏移地址    jnc rp_read       ！没有进位，则跳转到rp_read    mov ax,es         ！有进位，说明BX达到了64KB边界    add ax,#0x1000        mov es,ax         ！es增加0x1000    xor bx,bx         ！bx = 0    jmp rp_read       ！继续读取! 读当前磁道上指定开始扇区和需读扇区数的数据到es:bx开始处。! al － 需读扇区数； es:bx － 缓冲区开始位置。read_track:    push ax    push bx    push cx    push dx!dx,cx,ax都是传给中断服务程序的参数。    mov dx,track        !取当前磁道号。（磁道号其实存在低8位也就是dl的位置，dh都为0）    mov cx,sread        ! 取当前磁道上已读扇区数。（已读扇区不会超过255所以已读扇区号其实存在cl，ch都为0）    inc cx                ! cl = 开始读扇区号，inc为加一指令。    mov ch,dl            ! ch = 当前磁道号（用ch来存当前的磁道号）。    mov dx,head            ! 取当前磁头号。（同理磁头号也不可能超出255所以磁头号这时实际上时存在dl中，dh为0）    mov dh,dl            ! dh = 磁头号。（把磁头号放到dh上，dl在下面改为驱动器号）    mov dl,#0            ! dl = 驱动器号（为0表示当前驱动器）。    and dx,#0x0100        ! 磁头号不大于1    mov ah,#2            ! ah = 2, 读磁盘扇区功能号。    int 0x13    jc bad_rt            ! 若出错，则跳转至bad_rt。    pop dx    pop cx    pop bx    pop ax    ret! 执行驱动器复位操作（磁盘中断功能号0），再跳转到read_track处重试。bad_rt:        mov ax,#0    mov dx,#0    int 0x13（磁盘复位中断程序）    pop dx    pop cx    pop bx    pop ax    jmp read_trackkill_motor:    push dx    mov dx,# 0x3f2！ 软驱控制卡的驱动端口，只写。    mov al,#0            ! A驱动器，关闭FDC，禁止DMA和中断请求，关闭马达。    outb        ! 将al中的内容输出到dx指定的端口去。outb:I/O端口操作函数,I/O 上写入 8 位数据 ( 1 字节 )；    pop dx    retsectors:             .word 0                ! 存放当前启动软盘每磁道的扇区数。msg1:.byte 13,10            ! 回车、换行的ASCII码。     .ascll &quot;Loading my system ...&quot;! 我加了my，共有27个字符了     byte 13,10,13,10    ! 共24个ASCII码字符。org 508:        ! 表示下面语句从地址508(1FC)开始，所以root_dev            ！ 在启动扇区的第508开始的2个字节中。root_dev          .word  ROOT_DEV    ！ 这里存放根文件系统所在的设备号（init/main.c中会用）。boot_flag ：            .word  0xAA55h        ！ 硬盘有效标识。.text endtext：.dataenddata.bssendbss:</code></pre><p><img src="https://i.imgur.com/GKftX8i.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux-0.11源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux-0.11源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootsect.s</title>
    <link href="undefined2019/11/16/bootsect-s/"/>
    <url>2019/11/16/bootsect-s/</url>
    
    <content type="html"><![CDATA[<h1 id="阅读bootsect-s源码时遇到的问题记录和解决"><a href="#阅读bootsect-s源码时遇到的问题记录和解决" class="headerlink" title="阅读bootsect.s源码时遇到的问题记录和解决"></a>阅读bootsect.s源码时遇到的问题记录和解决</h1><p>1.<br><code>56.  jmpi   go，INITSEG</code><br><br>jmpi指令是段内跳转指令，跳转的目的地是INITSEG:go,这句话的意思是跳到INITSEG处偏移地址为go处的指令执行。</p><p>2.<br>bootsect.s中用到的各种中断<br></p><pre><code>INT 0x10, AH = 1 -- set up the cursorINT 0x10, AH = 3 -- cursor positionINT 0x10, AH = 0xE -- display charINT 0x10, AH = 0xF -- get video page and modeINT 0x10, AH = 0x11 -- set 8x8 fontINT 0x10, AH = 0x12 -- detect EGA/VGAINT 0x10, AH = 0x13 -- display stringINT 0x10, AH = 0x1200 -- Alternate print screenINT 0x10, AH = 0x1201 -- turn off cursor emulationINT 0x10, AX = 0x4F00 -- video memory sizeINT 0x10, AX = 0x4F01 -- VESA get mode information callINT 0x10, AX = 0x4F02 -- select VESA video modesINT 0x10, AX = 0x4F0A -- VESA 2.0 protected mode interfaceINT 0x11 -- Hardware detection(see ATA using BIOS for more detail on these BIOS function calls)INT 0x13, AH = 0 -- reset floppy/hard diskINT 0x13, AH = 2 -- read floppy/hard disk in CHS modeINT 0x13, AH = 3 -- write floppy/hard disk in CHS modeINT 0x13, AH = 0x15 -- detect second diskINT 0x13, AH = 0x41 -- test existence of INT 13 extensionsINT 0x13, AH = 0x42 -- read hard disk in LBA modeINT 0x13, AH = 0x43 -- write hard disk in LBA mode(see Detecting Memory (x86) for more detail on these BIOS function calls)INT 0x12 -- get low memory sizeINT 0x15, EAX = 0xE820 -- get complete memory mapINT 0x15, AX = 0xE801 -- get contiguous memory sizeINT 0x15, AX = 0xE881 -- get contiguous memory sizeINT 0x15, AH = 0x88 -- get contiguous memory sizeINT 0x15, AH = 0xC0 -- Detect MCA busINT 0x15, AX = 0x0530 -- Detect APM BIOSINT 0x15, AH = 0x5300 -- APM detectINT 0x15, AX = 0x5303 -- APM connect using 32 bitINT 0x15, AX = 0x5304 -- APM disconnectINT 0x16, AH = 0 -- read keyboard scancode (blocking)INT 0x16, AH = 1 -- read keyboard scancode (non-blocking)INT 0x16, AH = 3 -- keyboard repeat rate</code></pre><br>![](https://i.imgur.com/USbgQLK.png)<br><p>3.<code>87.  seg cs</code> <br><br>seg是段超越指令，某些时候你不想使用默认的段地址寄存器，那么你可以强制指定一个段地址寄存器（这里强制指定段地址寄存器为CS）。<br><br>默认的段寄存器是：<br><br>CS：IP<br><br>DS：SI<br><br>ES：DI <br><br>SS:SP<br><br>而且seg指令能影响的只有下一条指令，也就是说seg只能把下一条指令中的默认段寄存器改为自己指定的段寄存器。<br></p><p>4.<code>147. sread :   .word1+SETUPLEN</code> <br><br>sread 是一个标号，处理到sread时，ASM会把1+SETUPLEN的值按16bit放在此标号中。<br><br>.word就是在这个地方放一个值，相当于在这里定义了一个数据变量，用.word定义的是16bit的数据<br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bootsect.s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常控制流</title>
    <link href="undefined2019/11/11/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>2019/11/11/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p><strong>教材：《计算机系统基础》，本博客主要用来梳理学习思路。（不然会很乱）</strong></p><h1 id="7-1-进程与进程的上下文切换"><a href="#7-1-进程与进程的上下文切换" class="headerlink" title="7.1 进程与进程的上下文切换"></a>7.1 进程与进程的上下文切换</h1><h2 id="7-1-1-程序与进程的概念"><a href="#7-1-1-程序与进程的概念" class="headerlink" title="7.1.1 程序与进程的概念"></a>7.1.1 程序与进程的概念</h2><p><strong>程序：</strong>程序就是代码与数据的集合，程序的代码是一个机器指令序列，因而程序是一种静态的概念，它作为目标模块存放在磁盘中，或者作为一个存储段存在一个地址空间中。<br><br><strong>进程：</strong>进程就是程序的一次运行过程（进程具有动态的含义），计算机处理的所有任务实际上是由进程完成的。<br><br><strong>计算机系统中的任务通常是指进程，例如Linux内核中把进程称为任务，每个进程主要通过一个称为进程描述符的结构来描述，其结构类型定义为task_structure，包括了一个进程的所有信息，所有进程通过一个双向循环环链表实现的任务列表（task list）来描述，任务列表中的每个元素是一个进程描述符，IA-32中的任务状态段（TSS），任务门（task gate）等概念中所称的任务，实际上也是指进程。<br></strong></p><p><strong>进程的引入为应用程序提供了以下两个方面的抽象：一个独立的逻辑控制流和一个私有的虚拟地址空间。每个进程拥有一个独立的逻辑控制流使得程序员以为自己的程序在执行过程中独占使用处理器，每个进程拥有一个私有的虚拟地址空间，使得程序员以为自己的程序在执行过程中独占存储器。<br></strong></p><h2 id="7-1-2-进程的逻辑控制流"><a href="#7-1-2-进程的逻辑控制流" class="headerlink" title="7.1.2 进程的逻辑控制流"></a>7.1.2 进程的逻辑控制流</h2><p><strong>逻辑控制流：</strong>指令的执行过程中，会形成一个指令执行的地址序列，对于确定的输入数据，其指令执行的地址序列也是确定的，这个确定的指令执行地址序列称为逻辑控制流.（<strong>不知道定义在说些什么直接上图</strong>）<br><img src="https://i.imgur.com/vJTH0zM.png" srcset="/img/loading.gif" alt><br><br><strong>进程p1的逻辑控制流是：A<sub>11</sub><del>A<sub>13</sub>,A<sub>11</sub></del>A<sub>14</sub>,A<sub>15</sub>~A<sub>16</sub>。（其他进程同理）<br></strong><br><strong>并发：</strong>不同进程的逻辑控制流在时间上交错或者重叠的情况称为并发。<br><br><strong>并行：</strong>我们称两个同时执行的进程的逻辑控制流是并行的。<br><br><strong>并行是并发的一个特例。</strong></p><h2 id="7-1-3-进程的上下文切换"><a href="#7-1-3-进程的上下文切换" class="headerlink" title="7.1.3 进程的上下文切换"></a>7.1.3 进程的上下文切换</h2><p><strong>上下文切换：</strong> 操作系统通过处理器让处理器轮流执行多个进程，实现不同进程中指令交替执行的机制称为进程的上下文切换。<br><br><strong>进程的上下文：</strong> 进程的物理实体（代码和数据）和支持进程运行的环境合称进程的上下文。<br><br><strong>进程的上下文包括：用户级上下文和系统级上下文。</strong><br><br><img src="https://i.imgur.com/b9nyp7P.png" srcset="/img/loading.gif" alt><br><br><strong>系统级上下文和用户级上下文包括的内容如上图所示<br><br>进程的控制信息包括各种内核数据结构，例如记录有关进程信息表，页表，打开文件列表等。（具体如下图所示）</strong><br><img src="https://i.imgur.com/kMOm5Jn.png" srcset="/img/loading.gif" alt><br><br><strong>寄存器上下文：</strong>处理器中各个寄存器的内容被称为寄存器上下文。<br></p><p>**上下文切换发生在操作系统调度一个新进程到处理器运行时，需要完成三件事：<br></p><ol><li>将当前处理器的寄存器上下文保存在当前进程的系统上下文的现场信息中；<br></li><li>将新进程系统上下文中的现场信息作为新的就寄存器上下文恢复到处理器的各个寄存器中；</li><li>将控制转移到新进程执行。这里，一个重要的上下文信息是PC的值，当前进程被打断的断点处的PC作为寄存器上下文的一部分被保存在进程现场信息中，这样，下次该进程再次被调度到处理器上执行时，就可以从现场信息中获得断点处的PC，从而能从断点处开始执行。<br>**</li></ol><p><img src="https://i.imgur.com/fIhPaLr.png" srcset="/img/loading.gif" alt><br></p><p>从上图可以看出，<strong>在一个进程的整个生命周期中，可能会有其他不同的进程在处理器中交替运行</strong>，例如上图给出了上述shell命令行执行过程中shell进程与hello进程上下文切换过程，首先运行shell进程，从shell命令行中读入字符串“./hello”到主存；当shell进程读到字符“[Enter]”后，shell进程将通过系统调用从用户态转到内核态执行，由操作系统内核程序进行上下文切换，以保存shell进程的上下文并创建hello进程的上下文，hello进程结束后，再转到操作系统完成控制权从hello进程回到shell进程的切换。<br></p><h2 id="7-1-4进程的存储器映射"><a href="#7-1-4进程的存储器映射" class="headerlink" title="7.1.4进程的存储器映射"></a>7.1.4进程的存储器映射</h2><p>以Linux系统为例，对进程的存储器映射进行介绍，进程的存储器映射，是指将进程的虚拟地址空间的一个区域或者硬盘上的对象建立关联，已初始化一个vm_area_struct结构中的信息，使用mmap（）函数实现存储器的映射并通过缺页中断处理进行读写操作。(<strong>虚拟地址空间和硬盘建立关联后，以后CPU运行程序的时候就是通过虚拟地址来存取指令和数据，CPU给出虚拟地址后由MMU来把虚拟地址变为线性地址（分段方式）,再由线性地址转化为物理地址（分页方式），这就与第六章联系起来</strong>)<br></p><h3 id="lt-1-gt-mmap函数的功能"><a href="#lt-1-gt-mmap函数的功能" class="headerlink" title="&lt;1&gt;.mmap函数的功能"></a>&lt;1&gt;.mmap函数的功能</h3><p><code>void* mmap(void* start ,size\_t length ,int flags, int fd,off_t offset)</code><br><br>若该函数的返回值式-1（MAP_FAILED），则表示出错；否则，返回值为指向映射区域的指针。该函数的功能是，将指向文件fd中偏移量offset开始的长度为length字节的一块信息，映射到虚拟地址空间中起始位置为start，长度为length字节的一块区域。<br></p><p><img src="https://i.imgur.com/eaNZfe8.png" srcset="/img/loading.gif" alt><br><br>参数prot指定该区域页面的访问权限，对应vm_area_struct结构中的vm_prot字段，可能的取值包括以下几种：<br></p><ol><li>PROT_EXE：区域内页面由可执行指令组成<br></li><li>PROT_READ：区域内容可读<br></li><li>PROT_WRITE：区域内容可读可写<br></li><li>PROT_NONE：区域内容不可被访问<br><br>参数flags指定该区域映射对象的类型，对应vm_area_struct结构中的vm_flags字段，可能的取值包括以下两种：<br></li><li>普通文件：最典型的是可执行文件和共享库文件，通常映射到只读代码区域（.init .text .rodata）和已初始化数据区域（.data）的对象再可执行文件中，这些对象都属于私有对象，采用写时拷贝的技术映射到虚拟地址空间，所映射到的区域称为私有区域，对应对象称为私有的写时拷贝对象，此时参数flags设置为MAP_PRIVATE；映射到共享库区域的对象在共享库文件中，这些对象都属于共享对象，所映射的区域称为共享区域，此时flags设置为MAP_SHARED。<br><br>CPU<strong>第一次访问</strong>对应虚拟页面时，内核在主存中找到一个空闲页框（没有则淘汰一个），然后从硬盘上的文件装入所映射的对象信息，如果文件中的对象不是正好为页面大小的整数倍，内核将用零来填充余下的部分。<br></li></ol><p>2.匿名文件：由内核创建，全部由0组成，对应区域中的每个虚拟页面称为<strong>请求零的页面</strong>。参数flags设置为MAP_ANON。通常未初始化数据区（.bss），运行时堆和用户栈等区域中都为私有的，请求零的页，此时flags设置为MAP_PRIVATE | MAP_ANON。<br></p><h3 id="lt-2-gt-共享对象和私有的写时拷贝对象"><a href="#lt-2-gt-共享对象和私有的写时拷贝对象" class="headerlink" title="&lt;2&gt;.共享对象和私有的写时拷贝对象"></a>&lt;2&gt;.共享对象和私有的写时拷贝对象</h3><p><strong>共享库的动态链接具有共享性，其优点是：虽然由很多进程都调用共享库中的代码（例如 printf（）），但是共享库代码段在内存和硬盘中都由一个副本。</strong><br><br>那么问题来了,怎么实现一个共享库副本由多个进程共享呢？答案是：通过存储器映射机制来实现。<br><br><img src="https://i.imgur.com/NMtcu18.png" srcset="/img/loading.gif" alt><br><br><strong>映射过程：</strong><br><br><strong>因为共享对象在硬盘上只有一个副本，也即对应的共享库文件名是唯一的，（如上图）所以内核可以判断出进程1已经在主存给共享对象分配了页框，因而进程2的加载运行过程中，内核只要将进程2对应区域内页表项中的页框号直接填上即可。在多个进程共享同一个共享对象时，在主存中仅保存一个副本，每个进程在访问各自的共享区域时，实际上都在同一个对应页框中存取信息，因此，一个进程共享区域进行写操作结果，对于所有共享一个共享对象的进程都是可见的，而且结果也会反映在硬盘上对应的共享对象中。<br></strong></p><p><strong>私有的写时拷贝对象（A）有点像共享对象（B）（A也是像B一样，相同的代码或者数据共用主存页框不过对应的是私有对象，但是A在需要修改页框内数据时会生成一个私有的写时拷贝页，不会影响其他进程，写回硬盘时也仅仅只会修改对应进程的文件，不会影响其他进程。)<br></strong><br>具体如下说明：<br><br>一个可执行文件被多次加载执行以形成不同的进程，因而系统中多个进程可能由同样的只读代码区域和可读可写数据区域，也即不同进程的区域可能会映射到同一个对象。与共享库文件中的共享文件不同，可执行文件中的对象是私有的，映射到的是进程的私有区域，因此在这种私有区域中写操作结果，对于其他进程是不可见的，也不会反映在对于的硬盘对象中。要实现这种功能，内核可以为不同进程中对于区域的虚拟页主存中分配各自独立的页框。但是这会浪费很多空间。<br></p><p>为了解决这个问题就有了私有对象的写时拷贝技术。</p><p><strong>具体做法是：</strong><br><br>假设可执行文件a.out对应的两个进程在系统中并发执行，先启动的进程1会将a.out中私有对象映射到自己的VM用户空间区域中，<strong>内核将这些区域中的页面标记为私有的写时拷贝页，并将对应页表项中的访问权限标记为只读</strong>，在进程1运行过程中，内核为这个私有对象在主存中分配了若干页框，同样，后启动的进程2也会将a.out中的私有对象映射到自己的VM用户空间区域中，标记对应页面为私有的写时拷贝页和只读访问权限，并使页表项中的页框号与进程1的页框号相同，如下图所示，如果两个进程都没进行写操作，例如只读代码区就不会发生写操作，那么该区域中的虚拟页在主存中就只有一个副本，可以节省主存空间。<br><img src="https://i.imgur.com/3wn4nrh.png" srcset="/img/loading.gif" alt><br></p><p>若进程2对私有的写时拷贝页面（例如，可读可写数据区域所在页面）发生了写操作，那么就与只读访问权限不符合，发生保护异常，内核就会进行页故障处理，在处理过程中，内核判断出保护异常时由于进程试图对私有的写时拷贝页面进行写操作造成的，此时，内核就会在主存中为这个页面分配一个新页框（如下图所示），把页面的内容拷贝到新页框中，并修改进程2中对应的页表项，填入新分配的页框号，将访问权限改成可读可写，页故障处理完后回到发生故障的指令重新执行，此时进程2就可以正常执行写操作了，写时拷贝技术通常延迟拷贝私有对象所在页面，使得主存物理地址得到最充分的使用。<br><br><img src="https://i.imgur.com/LnVFAfz.png" srcset="/img/loading.gif" alt><br></p><h3 id="7-1-5程序的加载和启动"><a href="#7-1-5程序的加载和启动" class="headerlink" title="7.1.5程序的加载和启动"></a>7.1.5程序的加载和启动</h3><p>启动一个可执行目标文件时，首先会通过某种方式调出加载器（loader）的操作系统程序来处理，在Linux/UNIX系统中通过调用execve（）函数来启动加载器。<br><br>execve()函数的功能是在当前进程的上下文加载并运行一个新的程序<br></p><p><code>int execve(char* filename,char *argv[],*envp[])</code><br></p><p>filename是加载并运行的可执行文件名(如./hello)，可带参数列表 argv和环境变量列表envp。若错误（如找不到指定文件filename） ，则返回-1，并将控制权交给调用程序； 若函数执行成功，则不返回 ，而是将PC（EIP）设定指向EIF头中定义的入口点Entry Point(即符号_start处)。符号\start在启动例程crtl.o中定义，每个C程序都一样。<br><br>符号_start处定义的启动代码主要是一系列过程调用，首先依次调用_libe_init_file和_init两个初始化过程；随后通过调用atexit（）对程序正常结束时需要调用的函数进行登记注册，这些函数被称为终止处理函数；然后，再调用可执行目标中的主函数main（）；最后调用_exit（）过程，以结束进程的执行，返回操作系统内核。<br></p><p><strong>因此启动代码的调用过程为_libe_init_file—-&gt;_init—-&gt;atexit（）—–&gt;main（）—-&gt;_exit（）。</strong></p><p>主函数main（）的原型<br><br><code>int main(int argc, char **argv, char **envp);</code><br><br><code>int main(int argc, char *argv[], char *envp[f]);</code><br><br><img src="https://i.imgur.com/CvC1omZ.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/Ovzj3At.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/d8YR9sb.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/199tIah.png" srcset="/img/loading.gif" alt><br><br><strong>最后运行新程序main()函数的用户栈如下图：</strong><br><br><img src="https://i.imgur.com/JCnItEa.png" srcset="/img/loading.gif" alt><br><br>关于main（）函数参数的问题可以看这篇文章<br><a href="https://lexssama.github.io/2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">C++ main函数中参数argc和argv含义以及用法</a><br></p><h1 id="7-2-异常和中断"><a href="#7-2-异常和中断" class="headerlink" title="7.2 异常和中断"></a>7.2 异常和中断</h1><h2 id="7-2-1-基本概念"><a href="#7-2-1-基本概念" class="headerlink" title="7.2.1 基本概念"></a>7.2.1 基本概念</h2><p>从80286开始，Intel统一把“内中断”称为异常，“外中断”称为中断。<br><br>异常和中断的例子：<br><br><strong>异常：</strong><br><br>内部“异常”：再CPU内部发生的意外或者特殊事件：<br><br>按发生原因分为<strong>硬故障中断</strong> 和 <strong>程序性中断</strong>两类<br><br>硬故障中断：电源断电，硬件故障等<br><br>程序性中断：执行某条指令时发生的例外事件：如溢出，缺页，越界，越权，越级，非法指令，除数为0，堆/栈溢出，访问超时，断点设置，单步，系统调用等。<br></p><p>外部“中断”：在CPU外部发生的特殊事件，通过“中断请求”信号向CPU请求处理，如实时钟，控制台，打印机缺纸，采样计时到，DMA传输结束等。<br></p><h2 id="7-2-2-异常的分类"><a href="#7-2-2-异常的分类" class="headerlink" title="7.2.2 异常的分类"></a>7.2.2 异常的分类</h2><p><strong>异常被分为三类：故障（fault），陷阱（Trap），和终止（abort）。</strong><br></p><h3 id="lt-1-gt-故障"><a href="#lt-1-gt-故障" class="headerlink" title="&lt;1&gt;.故障"></a>&lt;1&gt;.故障</h3><p>故障是引起故障的指令在执行过程中CPU检测到一类与指令执行相关的意外事件，这种意外事件有的可以恢复，有的则不能恢复。<br><br><strong>溢出的情况：</strong><br><br>对于像是溢出和非法操作码等这类故障，因为无法通过异常处理程序恢复，所以不能回到中断的程序继续执行，通常异常处理程序程序在屏幕上显示一个对话框告知发生了某种故障，然后调用内核中的abort例程，以终止发生故障的当前进程。<br><br><strong>除数为0的情况：</strong><br><br>根据定点除法指令还是浮点除法指令有不同的处理方式，对于浮点数除0，异常处理程序可以选择将指令执行结果用特殊值（如∞或者NaN）表示，然后返回到用户进程继续执行除法指令后面的一条指令；而对于整数除0，则会发生“整除0”故障，通常调用abort例程来终止当前用户进程。<br><br><strong>页故障的情况：</strong><br><br>“page fault”异常中包括了多种不同情况，需要页故障处理程序根据不同的情况进行进行不同的处理，首先检查是否发生地址越界或者访问越权，如果是的话，则故障不可以恢复；否则是真正的缺页故障，此时，可以通过从硬盘读入页面来恢复故障，Linux中不可以恢复的访存故障（地址越界或者地址越权）都称为“段故障（segmentation fault）”<br><br><img src="https://i.imgur.com/8UHrtiT.png" srcset="/img/loading.gif" alt><br></p><p><strong>故障处理后有三种情况：终止（abort），返回当前指令（再执行一遍故障指令，“缺页”），返回下条指令（例如浮点数除法，除0）。</strong><br></p><h3 id="lt-2-gt-陷阱"><a href="#lt-2-gt-陷阱" class="headerlink" title="&lt;2&gt;.陷阱"></a>&lt;2&gt;.陷阱</h3><p>陷阱也称为“自陷”或“陷入”与“故障”等其他异常事件不同，是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。当执行到陷阱指令时，CPU就会调出特定的程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令执行。<br><br><img src="https://i.imgur.com/i22SV5W.png" srcset="/img/loading.gif" alt><br><br><strong>执行陷阱指令返回是回到陷阱指令的下一条指令执行。</strong><br></p><p>陷阱的作用：<br></p><ol><li>陷阱的重要作用之一就是再用户程序和内核之间提供一个像过程一样的接口，这个接口叫做<strong>系统调用</strong>，用户程序利用这个接口可以方便地使用操作系统内核提供的一些服务。操作系统给每个服务编一个号，称为<strong>系统调用号</strong> ，每个服务功能通过一个对应的<strong>系统调用服务例程</strong>提供<br></li><li>陷阱机制可以实现程序调试功能，包括设置断点和单步跟踪<br></li></ol><p><strong>单步跟踪：</strong>在IA-32中，当CPU处于单步跟踪状态（TF=1且IF=1）时，每条指令都被设置成陷阱指令，执行每条指令后，都会发生中断类型型号为1的“调试”异常，从而转去特定的“单步跟踪处理程序”。<br><br><strong>单步跟踪处理程序执行具体过程：<br></strong><br><img src="https://i.imgur.com/YAP7Egj.jpg" srcset="/img/loading.gif" alt><br><br>单步跟踪处理前CPU会自动把标志寄存器压栈，然后将TF和IF清0，这样在单步跟踪处理程序执行过程中CPU能以正常方式工作工作，单步处理结束， <strong>返回断点处执行之前（注意是回到断点处执行，而不是回到断点处的下一条指令执行）</strong> ，再从栈中取出标志，以恢复TF和IF的值，是CPU回到单步跟踪状态，这样下一条指令又是陷阱指令，将被跟踪执行。<br></p><p><strong>断点设置：</strong><br><br>在IA-32中，用于程序调试的“断电设置”陷阱指令为int 3 ，对应机器码为CCH，若调试程序在被调试程序某处设置了断点，则调试程序就把该处指令第一字节改为CCH。当CPU执行到该指令是，就会暂停当前被调试程序的运行，并发出一个“EXCEPTION_BREAKPOINT”异常，从而最终调出相应的调试程序来执行，执行结束后再回到设定的断点的调试程序执行。<br></p><h3 id="lt-3-gt-终止"><a href="#lt-3-gt-终止" class="headerlink" title="&lt;3&gt;.终止"></a>&lt;3&gt;.终止</h3><p>如果再执行指令过程中发生了严重错误，例如控制器出现问题，访问DRAM或者SRAM时发生校检错等，则程序将无法继续执行，只好终止发生问题的进程，在有些严重的情况下，甚至要重启系统，显然，这种异常时随机发生的，无法确定发生异常的是哪一条指令，其处理过程如下图：<br><br><img src="https://i.imgur.com/9vE3Wfc.png" srcset="/img/loading.gif" alt><br></p><h2 id="7-2-3-中断的分类"><a href="#7-2-3-中断的分类" class="headerlink" title="7.2.3 中断的分类"></a>7.2.3 中断的分类</h2><p>中断时外部I/O设备请求处理器进行的处理的一种信号，它不是由当前执行的指令引起的。<br></p><p>Intel将外部中断分为可屏蔽中断（maskable interrupt）和不可屏蔽中断（nonmaskable interrupt，NMI）<br></p><ol><li><p>可屏蔽中断（maskable interrupt）<br>可屏蔽中断时指通过可屏蔽中断请求线（INTR）向CPU进行请求的中断，主要来自I/O设备的中断请求。CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或者不屏蔽它，若一个I/O设备的中断请求被屏蔽，则它的中断请求信号不会被送到CPU<br></p></li><li><p>不可屏蔽中断<br><br>不可屏蔽中断时非常紧急的硬件故障（电源断点，硬件线路故障），通过专门的不可以屏蔽中断请求线NMI向CPU发出中断请求。这类中断请求信号一旦产生，任何情况下都不可被屏蔽，因此一定会被送到CPU，以便CPU快速处理这类紧急事件，通常这种情况下，中断服务程序会尽快保存系统重要信息，然后再屏幕上显示相应的消息或者直接重启系统。<br></p></li></ol><p><img src="https://i.imgur.com/vTJ4Oes.png" srcset="/img/loading.gif" alt></p><h2 id="7-2-4-异常和中断的响应具体过程"><a href="#7-2-4-异常和中断的响应具体过程" class="headerlink" title="7.2.4 异常和中断的响应具体过程"></a>7.2.4 异常和中断的响应具体过程</h2><p>CPU对异常和中断的响应过程可以分为以下三个步骤：保护断点和程序状态，关中断，识别异常和中断事件并转到相应处理程序执行。</p><h3 id="1-保护断点和程序状态"><a href="#1-保护断点和程序状态" class="headerlink" title="1.保护断点和程序状态"></a>1.保护断点和程序状态</h3><p><strong>保护断点：</strong><br><br>对于不同的异常事件，其返回地址不同（即断点不同），例如“缺页故障”异常的断点时发生页故障的当前指令的地址；为了能在异常处理后正确返回到原被中断的程序继续执行，数据通路必须能正确计算断点处的地址。<strong>保护断点时只要将计算出的断点地址送到栈中或者特定的寄存器中即可。</strong><br><br>IA-32处理器的断点保存在栈中<br><br>MIPS处理器用EPC寄存器专门存放断点<br><br><strong>保护程序状态：</strong><br><br>因为异常处理后可能还要回到原被中断的程序中继续执行，所以被中断时源程序的状态（如产生的各自标志信息，允许自陷标志等）都必须保存起来，通常每个正在运行的程序的状态信息存放在一个专门的寄存器中，这些专门的寄存器统称为<strong>程序状态字寄存器（PSWR）—&gt;如IA-32中的EFLAGS寄存器就是PSWR</strong>，存放在PSWR的信息称为<strong>程序状态字（PSW）</strong>，与断点一样PSWR中的PSW也要保存在栈或者特定的寄存器中。<br></p><h3 id="2-关中断"><a href="#2-关中断" class="headerlink" title="2.关中断"></a>2.关中断</h3><p><strong>如果中断处理程序在保存原被打断程序现场的过程中又发生了新的中断，那么就会因为要处理新的中断，而把原被打断程序的现场以及已保存的断点和程序状态等破坏掉。因此因该有一种机制来禁止在处理中断时在响应新的中断</strong><br><br>通常通过设定“中断允许位”（“中断允许”触发器）来实现，若中断允许位为1，则为开中断，表示允许响应中断；若中断允许位清0，表示不允许响应中断 则为关中断。例如 IA-32中的“中断允许位”就是EFLAGS的寄存器中的中断标志位IF。<br><br>在IA-32中通过执行指令sti或者cli，将标志寄存器EFLAGS中的位 （置1或清0），以使CPU处在开中断或者关中断状态。<br></p><h3 id="3-识别异常和中断事件并转相应的处理程序执行"><a href="#3-识别异常和中断事件并转相应的处理程序执行" class="headerlink" title="3.识别异常和中断事件并转相应的处理程序执行"></a>3.识别异常和中断事件并转相应的处理程序执行</h3><p>在调出异常和中断处理从程序之前，必须知道发生了什么异常或哪个I/O设备发出了中断请求，一般来说，内部异常事件和外部中断源的识别方式不同，大多数处理器会将两者分开来。<br><br><strong>内部异常事件的识别：</strong><br><br>内部异常事件识别比较简单，只要把CPU在执行指令时把检测到的事件对于的异常类型号或标识异常类型的信息记录到特定的内部寄存器即可。<br><br><strong>外部中断源的识别：</strong><br><br>外部中断源的识别比较复杂。由于外部中断的发生与CPU正在执行的指令没有必然联系，相对于指令来说，外部中断时不可预测的，与当前指令无关，所以并不能根据指令执行过程中的某些现象判断是否发生了中断请求，必须时每条指令执行完之后，在加载下一条指令之前CPU通过采样对应的中断请求引脚（INTR，NMI）来进行查询，如果发现中断请求引脚有效，则说明有中断请求，但是到底时哪个I/O设备发出的请求还需要进一步识别，通常是由CPU外部的中断控制器根据IO设备的中断请求和中断屏蔽情况，结合中断响应优先级，来识别当前的中断类型号，并通过数据总线将中断类型号送到CPU。<br></p><p>异常和中断源的识别可以采用<strong>软件识别</strong>和<strong>硬件识别</strong>两种方式<br></p><p><img src="https://i.imgur.com/fh0f94U.png" srcset="/img/loading.gif" alt><br></p><h1 id="7-3-IA-32-Linux中的异常和中断"><a href="#7-3-IA-32-Linux中的异常和中断" class="headerlink" title="7.3 IA-32+Linux中的异常和中断"></a>7.3 IA-32+Linux中的异常和中断</h1><h2 id="7-3-1-IA-32的中断向量"><a href="#7-3-1-IA-32的中断向量" class="headerlink" title="7.3.1 IA-32的中断向量"></a>7.3.1 IA-32的中断向量</h2><p>IA-32采用向量中断方式，可以处理256种不同类型的异常和中断，每个异常或者中断都有唯一的编号，称之为中断类型号（也称向量号），并且还有与其对应的异常处理程序或者中断服务程序，其入口地址放在一个专门的中断向量表种。<br><br>256个中断类型前32个（0~31）保留给处理器用，剩余的可以由用户自行定义功能，这里的用户是操作系统。<br></p><h2 id="7-3-2-IA-32的中断描述符表"><a href="#7-3-2-IA-32的中断描述符表" class="headerlink" title="7.3.2 IA-32的中断描述符表"></a>7.3.2 IA-32的中断描述符表</h2><p><img src="https://i.imgur.com/vPTsaGo.jpg" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/ALWm2Oz.jpg" srcset="/img/loading.gif" alt><br><br>保护模式下，借助中断描述符表来获得异常处理程序或中断服务程序的入口地址，中断描述符表，（interrupt Descriptor Table，IDT）是操作系统内核种的一个表，共有256个表项，每个表项是一个中断门描述符，陷阱门描述符或任务门描述符（用TYPE区分，如下图，中断门TYPE=1110B，陷阱门TYPE=1111B,任务门TYPE=0101B）。<br><br>P=1时表示段存在，P=0表示段不存在，Linux总是把P置成1，因为它从来不会把一个段交换到磁盘上，而是以页面为单位交换。<br><br>DPL给出访问本段要求的最低特权等级<br></p><p><img src="https://i.imgur.com/TyHMAP6.png" srcset="/img/loading.gif" alt><br><strong>任务门描述符：</strong><br><br>任务门描述符中不包括偏移地址，只包括TSS段选择符，这个段选择符指向GDT中的一个TSS段描述符，CPU根据TSS段中的相关信息装载EIP和ESP等寄存器，从而执行相应的异常处理程序。<br></p><h2 id="7-3-2-IA-32中异常和中断的处理"><a href="#7-3-2-IA-32中异常和中断的处理" class="headerlink" title="7.3.2 IA-32中异常和中断的处理"></a>7.3.2 IA-32中异常和中断的处理</h2><p>在每条指令的执行过程中会根据执行情况判定是否发生了某种内部异常事件，在每条指令执行结束时判定是否发生了外部中断，因此在CPU根据CS和EIP去取下条指令之前，会根据检测的结果判断是否进入异常和中断响应阶段。<br><br>若由异常和中断发生:<br></p><ol><li>确定检测到的异常中断号i，从IDTR指向的IDT中取出第i个表项<br></li><li>根据IDTi中的段选择符，从GDTR指向的GDT中取出相应的段描述符，得到对应异常处理程序和中断服务程序所在段的DPL，基地址等信息。<br></li><li>将当前特权级CPL与段描述符中的DPL比较。若CPL小于DPL，则产生13号异常，内核代码段DPL总是等于0，因此不管怎样都不会发生CPL小于DPL的情况，这个检查主要是为了防止而已应用程序通过INT n 指令模拟非法异常和中断进入内核态执行非法性破坏。<br></li><li>检查是否发生了特权级变化，即判断CPL是否与相应的段描述符中的DPL不同，如果是的话，就需要从用户态切换到内核态，以使用内核对应的栈。Linux中若CPL=DPL，则发生异常或中断指令也在内核态执行；（即在一个内核态中执行的过程中又遇到了异常或者中断），若CPL&gt;DPL，则从用户态转到内核态执行，因此，因从用户态切换到内核态执行，因此应从用户栈切换到内核栈。<br></li></ol><p><strong>用户栈切换到内核栈步骤：</strong><br><br>读TR寄存器，以访问正在运行的TSS段，将TSS段中保存的内核栈的段选择符和栈指针分别装入寄存器SS和ESP,然后再内核栈中保存原来的用户栈的SS和ESP。<br><br>5. 如果发生的事故障，则将发生故障的指令的逻辑地址写入CS和EIP，以保证故障处理后能回到发生故障的指令执行。<br><br>6. 在当前栈中保存EFLAGS，CS和EIP寄存器的内容（内核栈）。若是中断门，则将EFLAGS寄存器中的IF清0(关中断)。<br><br>7. 将IDTi中的段选择符装入CS，IDTi中的偏移地址装入EIP，它们事异常处理程序或中断服务程序第一条指令的逻辑地址<br><br>8. 这样从下一个时钟周期开始，就执行异常处理程序和中断服务程序的第一条指令，在异常处理程序中或中断服务程序中，处理完异常或者中断程序后，通过执行最后一条指令IRET回到原被中断的进程继续执行<br></p><p>CPU在执行IRET指令的过程中完成以下工作：<br></p><ol><li>从内核栈中弹出EIP，CS和EFLAGS，恢复断点和程序状态。<br></li><li>检查当前异常或中断处理程序的CPL是否等于CS中的低两位，若是，则说明异常或中断响应前后都属于一个特权级，IRET指令完成操作；否则再进行下一步工作。<br></li><li>从内核栈中弹出SS和ESP(弹出来的是用户栈的SS和ESP)，以恢复到异常或中断响应前的特权级进程所使用的栈。</li><li>检查DS，ES，FS和GS寄存器的内容，若其中又某个寄存器的段选择符指向的一个段描述符且器DPL小于CPL则将段寄存器的内容清0，这是为了防止恶意应用程序（CPL=3）利用内核以前使用过的段寄存器（DPL=0）,来访问内核地址空间<br><br>执行完IRET指令后，CPU自然回到原来发生异常或中断的进程继续执行。<br></li></ol><p><img src="https://i.imgur.com/Cx9kqLD.png" srcset="/img/loading.gif" alt><br></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础-袁春风</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次结构存储系统</title>
    <link href="undefined2019/11/04/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <url>2019/11/04/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>教材：《计算机系统基础》，本博客主要用来梳理学习思路。(不然好乱）<br><br>不同类型的存储器设置的计算机中，其设置的顺序为：<br><br><strong>寄存器-&gt;cache-&gt;主存-&gt;硬盘-&gt;光盘和磁带。</strong><br><br>接下来就是详细的按顺序的介绍上面的存储器。<br></p><h1 id="6-1-存储器概述"><a href="#6-1-存储器概述" class="headerlink" title="6.1 存储器概述"></a>6.1 存储器概述</h1><h2 id="6-1-1-存储器的分类"><a href="#6-1-1-存储器的分类" class="headerlink" title="6.1.1 存储器的分类"></a>6.1.1 存储器的分类</h2><h3 id="1-按照存储元件分类"><a href="#1-按照存储元件分类" class="headerlink" title="1.按照存储元件分类"></a>1.按照存储元件分类</h3><p>半导体存储器，磁表面存储器：磁盘存储器和磁带存储器，光介质存储器：光盘存储器。</p><h3 id="2-按存取方式分类"><a href="#2-按存取方式分类" class="headerlink" title="2.按存取方式分类"></a>2.按存取方式分类</h3><h4 id="1-RAM-随机存取存储器）"><a href="#1-RAM-随机存取存储器）" class="headerlink" title="(1).RAM(随机存取存储器）"></a>(1).RAM(随机存取存储器）</h4><p>RAM特点是：按地址访问存储单元，RAM的存储介质是半导体存储器件，每个地址译码时间相同，在不用考虑行缓冲的前提下，每个单元的访问时间是一个常数，与地址无关（但是现在DRAM芯片大多都有行缓冲）。</p><h4 id="2-SAM-顺序存取存储器"><a href="#2-SAM-顺序存取存储器" class="headerlink" title="(2).SAM(顺序存取存储器)"></a>(2).SAM(顺序存取存储器)</h4><p>SAM的特点是：信息按照顺序存放和读出，其存取时间时间取决于信息存放的位置，以记录块为单位编址。例如：磁带存储器。（存储量大，存取速度慢）</p><h4 id="3-DAM-直接存取存储器"><a href="#3-DAM-直接存取存储器" class="headerlink" title="(3).DAM(直接存取存储器)"></a>(3).DAM(直接存取存储器)</h4><p>DAM的特点是：兼有随机访问和顺序访问的特点。首先直接定位在需要读写的位置，然后顺序方式存取，磁盘存储器就是如此。</p><h4 id="4-CAM-AM-相联存储器"><a href="#4-CAM-AM-相联存储器" class="headerlink" title="(4).CAM/AM(相联存储器)"></a>(4).CAM/AM(相联存储器)</h4><p>CAM/AM特点是：按照内容访问存储器(上面的RAM，CAM，SAM，都需要给出地址，CAM不用，CAM按照内容定位),例如：快表（TLB）。</p><h3 id="3-按照信息的可更改性分类。"><a href="#3-按照信息的可更改性分类。" class="headerlink" title="3. 按照信息的可更改性分类。"></a>3. 按照信息的可更改性分类。</h3><p>读写存储器(RAM),只读存取器（ROM）。RAM芯片和ROM芯片都采用随机存取的方式进行信息的访问。</p><h3 id="4-按断电后的信息的可保存性分类"><a href="#4-按断电后的信息的可保存性分类" class="headerlink" title="4.按断电后的信息的可保存性分类"></a>4.按断电后的信息的可保存性分类</h3><p>非易失性存储器：ROM，磁表面存储器，光盘存储器等。<br><br>易失性存储器：RAM,cache等。<br></p><h3 id="5-按照功能分类"><a href="#5-按照功能分类" class="headerlink" title="5.按照功能分类"></a>5.按照功能分类</h3><h4 id="1-高速缓存存储器（cache）"><a href="#1-高速缓存存储器（cache）" class="headerlink" title="(1).高速缓存存储器（cache）"></a>(1).高速缓存存储器（cache）</h4><p>cache：位于主存和CPU之间，由静态RAM芯片组成，存放CPU常用的指令和数据，速度接近CPU的工作速度。</p><h4 id="2-主存储器-主存"><a href="#2-主存储器-主存" class="headerlink" title="(2).主存储器(主存)"></a>(2).主存储器(主存)</h4><p>CPU执行指令是给出的存储地址最终必须转换为主存地址，主存用来存放系统启动运行的程序及其数据。</p><h4 id="3-辅助存储器（辅存）"><a href="#3-辅助存储器（辅存）" class="headerlink" title="(3).辅助存储器（辅存）"></a>(3).辅助存储器（辅存）</h4><p>系统运行时直接和主存交换信息的存储器叫做辅助存储器。例如：磁盘，辅存的内容要导入主存才能被CPU访问。</p><h4 id="4-海量后备存储器"><a href="#4-海量后备存储器" class="headerlink" title="(4).海量后备存储器"></a>(4).海量后备存储器</h4><p>磁带，光盘，U盘一类的吧。<br></p><p><strong>海量后备存储器和辅助存储器统称外存。</strong></p><h2 id="6-1-2-主存的组成和基本操作"><a href="#6-1-2-主存的组成和基本操作" class="headerlink" title="6.1.2 主存的组成和基本操作"></a>6.1.2 主存的组成和基本操作</h2><p><img src="https://i.imgur.com/mXC6RaT.png" srcset="/img/loading.gif" alt="主存储器的基本框图"><br>记忆单元（存储元）：是具有两种稳态的能表示二进制0和1的物理器件。<br><br>指令执行过程：（这里不考虑虚拟地址，cache的情况大略宏观上梳理一下CPU访存的过程，这里CPU给出的就是主存地址）<br><br>CPU先把欲访问的主存单元的地址送到主存地址寄存器(MAR)——&gt;MAR通过地址线把主存地址送到主存中的地址寄存器———&gt;地址译码器根据地址寄存器中的地址进行译码后选中存储阵列（存储体）中相应单元，同时CPU将读/写控制信号通过控制线送到主存的读写控制电路，进行读写操作，读写的数据通过MDR&lt;—&gt;数据线&lt;—&gt;存储阵列传输。<br><br><strong>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。</strong><br><br>图中采用64位数据线，因此在按字节编址下最多一次可以取8个字节的内容，地址线的位数决定主存地址空间最大可寻址范围：例如36位地址的最大可寻址范围位0~2<sup>36</sup>-1。</p><h2 id="6-1-3-存储器的主要性能指标"><a href="#6-1-3-存储器的主要性能指标" class="headerlink" title="6.1.3 存储器的主要性能指标"></a>6.1.3 存储器的主要性能指标</h2><p>存储器速度可以用访问时间，存储周期或者存储器带宽来表示。<br><br>(1).访问时间一般用读出时间（T<sub>A</sub>)和写入时间（T<sub>w</sub>)来表示。<br><br>(2).存储周期（T<sub>M</sub>)是指存储器进行一次读写操作所需要的全部时间。<br><br>(3).存储器带宽(B)：每秒传输信息的位数（字节）。</p><h2 id="6-1-4-各类存储元件"><a href="#6-1-4-各类存储元件" class="headerlink" title="6.1.4 各类存储元件"></a>6.1.4 各类存储元件</h2><p>半导体芯片：RAM芯片和ROM芯片。<br><br>RAM分为静态RAM芯片(SRAM)和动态RAM芯片(DRAM)。<br><br>ROM分为不可在线改写内容ROM和闪存(Flash ROM)。<br><br>SRAM:<strong>优点：</strong>速度快，无需刷新和读后再生。<strong>缺点：</strong>MOS管多，占硅面积大，功耗大，集成度低，价格贵。 <strong>应用：</strong>cache<br><br>DRAM: <strong>优点</strong>：MOS管少，占硅面积小，集成度高，价格便宜。 <strong>缺点</strong>：速度慢，需要定时刷新和读后再生。 <strong>应用</strong>：主存</p><h2 id="6-1-5-存储器的层次结构"><a href="#6-1-5-存储器的层次结构" class="headerlink" title="6.1.5 存储器的层次结构"></a>6.1.5 存储器的层次结构</h2><p><img src="https://i.imgur.com/M3VPO5U.png" srcset="/img/loading.gif" alt="存储器层次化体系结构示意图"></p><h1 id="6-2-主存与CPU的连接及其读写操作"><a href="#6-2-主存与CPU的连接及其读写操作" class="headerlink" title="6.2 主存与CPU的连接及其读写操作"></a>6.2 主存与CPU的连接及其读写操作</h1><h2 id="6-2-1-主存芯片技术"><a href="#6-2-1-主存芯片技术" class="headerlink" title="6.2.1 主存芯片技术"></a>6.2.1 主存芯片技术</h2><p>1.DRAM芯片技术<br><br>2.SDRAM芯片技术(同步DRAM)<br><br>3.DDR SDRAM芯片技术。<br><br>4.DDR2 SDRAM芯片技术。<br><br>5.DDR3 SDRAM芯片技术<br><br>不展开讲，因为涉及数字逻辑电路，不是很重点（自己觉得)，现在比较主要用SDRAM.</p><h2 id="6-2-2-主存与CPU的连接及其读写"><a href="#6-2-2-主存与CPU的连接及其读写" class="headerlink" title="6.2.2 主存与CPU的连接及其读写"></a>6.2.2 主存与CPU的连接及其读写</h2><h3 id="1-宏观上主存和CPU的关系"><a href="#1-宏观上主存和CPU的关系" class="headerlink" title="(1).宏观上主存和CPU的关系"></a>(1).宏观上主存和CPU的关系</h3><p><img src="https://i.imgur.com/7xQkMrt.jpg" srcset="/img/loading.gif" alt><br><br><strong>（什么什么）总线是连接其上的各部件的传输介质，通常由控制线，数据线，地址线构成。</strong><br><br>CPU通过系统总线和内存总线与主存相连，在CPU与主存之间交换信息时，CPU通过总线接口把总线控制信息和地址信息分别送到控制线和地址线，CPU和主存之间交换的数据信息则通过数据线传输。<br></p><p>受集成度和功耗等因数影响，单个芯片的容量不能很大，所以就要通过存储器芯片扩展技术将多个芯片做成一个内存条，然后通过多个内存条，以及主板或者扩充板上的RAM芯片和ROM芯片组成一台计算机所需要的主存空间，在通过总线，桥接器和CPU相连。<br></p><p>内存条插槽就是存储器总线，内存条中的信息通过内存条的引脚，再通过插槽内的引线连接到主板上，通过主板上的导线连接到北桥芯片或者CPU芯片。现在的计算机可以实现多条存储器总线同时进行传输，支持两条总线进行传输的内存条插槽为两通道内存插槽，还有三通道 四通道内存插槽，其总线传输的带宽可以提升2，3，4倍，<strong>在主机主板上相同颜色的插槽可以并行传输，如果有两个内存条可以插在两个颜色相同的内存条插槽上，其带宽可以增加一倍。（这个实用！）</strong><br></p><hr><h3 id="2-DRAM的扩展"><a href="#2-DRAM的扩展" class="headerlink" title="(2).DRAM的扩展"></a>(2).DRAM的扩展</h3><p>由若干个存储器构成的一个存储器，需要在字方向和位方向上进行扩展。<br><br><strong>位扩展：</strong>用若干片位数较少的存储器芯片构成给定字长的存储器（如下图z方向的扩展）<br><br><strong>字扩展：</strong>容量上的扩充，位数不变（z不变而一片DRAM芯片上的容量扩大）<br><br><strong>读写过程：CPU通过存储器控制器对内存条中的DRAM芯片进行读写，CPU读写的存储单元地址通过总线被送到存储控制器，然后由存储控制器将存储单元地址转化为DRAM芯片的行地址i和列地址j，分别在行地址选通信号RAS和列地址选通信号CAS的控制下，通过DRAM芯片的地址引脚，分时送到DRAM芯片内部的行地址译码器和列地址译码器，以选择行，列地址交叉点(i,j)【一个超元】，的8位数据同时进行读写，8个芯片就可以同时读取64位，组合成总线所需要的64位传输宽度，再通过存储器总线进行传输。</strong><br></p><p>正是主存这种存取数据的方式，就决定了计算机信息储存数据要对齐。<br><br><img src="https://i.imgur.com/tTYo7Cq.jpg" srcset="/img/loading.gif" alt="DRAM芯片的扩展"></p><hr><h3 id="3-DRAM芯片内部结构"><a href="#3-DRAM芯片内部结构" class="headerlink" title="(3). DRAM芯片内部结构"></a>(3). DRAM芯片内部结构</h3><p>图中芯片容量为16x8位，存储阵列为4行x4列，地址引脚采用复用方式，因此仅需2根地址引脚，再RAS和CAS的控制下分时传送2位行地址和2位列地址。每一个超元，有8位，需要8根数据引脚，有一个内部行缓冲，用来缓存指定行中每一列的数据，通常用SRAM元件实现。<br><br><img src="https://i.imgur.com/p4sbQ4i.png" srcset="/img/loading.gif" alt="DRAM芯片内部结构示意图"></p><p><strong>读写过程：图中反应了存储控制器再RAS有效时将行地址“2”送到行译码器后选中，第“2”行时的状态，此时，整一行数据被送到内部行缓存中，然后存储控制器再CAS有效时将列地址“1”送到选中的第“1”列时的状态，此时将内部行缓冲中第“1”列的8位数据超元（2，1）读到数据线，并向CPU传送。</strong><br><img src="https://i.imgur.com/Jj0AiXI.jpg" srcset="/img/loading.gif" alt="DRAM芯片读写原理示意图"></p><hr><h3 id="4-“装入”指令和存储“存储”指令操作过程"><a href="#4-“装入”指令和存储“存储”指令操作过程" class="headerlink" title="(4).“装入”指令和存储“存储”指令操作过程"></a>(4).“装入”指令和存储“存储”指令操作过程</h3><p>以 IA-32中的“movl 8(%ebp),%eax”指令为例：(这里8(%ebp)的计算在CPU中完成，涉及IA-32中的分段和分页存储管理机制，这里不展开说明)<br><br><strong>具体过程：<br><br>(1).图aCPU将主存地址A通过总线接口送到地址线，然后由存储控制器将地址A分解成行，列按分时的方式送给DRAM芯片。在进行这些操作的同时CPU还会把“存储器读”控制命令通过控制线送到主存。<br><br>(2).图b主存将地址A中的数据x通过数据线送到总线接口部件。<br><br>(3).图cCPU从总线接口部件中取出x存放在寄存器EAX中。<br></strong><br><img src="https://i.imgur.com/Fz80FzY.jpg" srcset="/img/loading.gif" alt="主存单元取数到寄存器的操作过程"></p><h1 id="6-3-硬盘存储器"><a href="#6-3-硬盘存储器" class="headerlink" title="6.3 硬盘存储器"></a>6.3 硬盘存储器</h1><h2 id="6-3-1磁盘存储器的结构"><a href="#6-3-1磁盘存储器的结构" class="headerlink" title="6.3.1磁盘存储器的结构"></a>6.3.1磁盘存储器的结构</h2><p><img src="https://i.imgur.com/opv5DqD.png" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/zyz1Nnp.png" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/wASJplS.jpg" srcset="/img/loading.gif" alt><br><br><strong>注意：每一个盘片都有两个磁头，正面一个反面一个。多个盘片上相同磁道形成一个柱面，所以磁道号就是柱面号</strong></p><hr><p><img src="https://i.imgur.com/hIxCGei.png" srcset="/img/loading.gif" alt></p><p><strong>读写过程：<br><br>(1).寻道操作：磁盘控制器把盘地址送到磁盘驱动器的磁盘地址寄存器后，便形成寻道命令，启动磁头定位伺服系统，根据磁头号和柱面号，选择指定的磁头移动到指定的柱面，此操作完成后，发出寻道结束信号给磁盘控制器，转入旋转等待操作。<br><br>(2).旋转等待操作：盘片旋转之前，首先将扇区计数器清零，以后每来一个扇区标志脉冲，扇区计数器加1，把计数器内容与磁盘地址寄存器中的扇区地址进行比较，如果一致则输出扇区符合信号，说明读写的信息已经转入磁头下方。<br><br>(3).读写操作：扇区符合信号送到磁盘控制器后，磁盘控制器的读写控制电路开始动作，如果是写操作，就将数据送到写入电路，写入电路根据记录方式生成相应的写电流脉冲；如果是读操作，则由读出放大电路读出内容送给磁盘控制器。<br></strong></p><hr><p>数据在磁盘上的记录格式分为定长记录格式和不定长记录格式两种，目前大多采用定长记录格式。<br></p><p>最早的硬盘由IBM开发：温切斯特盘（温盘），它采用定长记录格式。<br><br><img src="https://i.imgur.com/aAnzL0v.jpg" srcset="/img/loading.gif" alt><br><br> <strong>每个磁道由若干个扇区（也称扇段）组成，每个扇区记录一个数据块。</strong><br><br>头空（间隙1）占17个字节，全是1，磁盘转过该区域的时间是留给磁盘控制器作准备用的。</p><h2 id="6-3-2-磁盘存储器的性能指标"><a href="#6-3-2-磁盘存储器的性能指标" class="headerlink" title="6.3.2  磁盘存储器的性能指标"></a>6.3.2  磁盘存储器的性能指标</h2><p>(1).记录密度：道密度和位密度。<br><br>位密度：单位长度内存放的二进制信息数目叫做位密度。<br><br>道密度：沿磁道分布方向上单位长度内的磁道数目叫做道密度<br><br><img src="https://i.imgur.com/JcU1fAH.jpg" srcset="/img/loading.gif" alt></p><hr><p>(2).存储容量<br><br>硬盘的未格式化容量：按照道密度和位密度计算出来的容量，包括头空，ID域，CRC码等信息，是所有可利用的所有磁化单元的总数，未格式化容量，比格式化后的实际容量要大。<br></p><p>对于低密度存储方式的<strong>未格式化容量</strong>的计算方法为：<br><br><code>磁盘总容量 = 记录面数 (一个盘有两面) * 理论柱面数 * 内圆周长 * 最内道位密度</code><br><br><code>理论柱面数 =（有效记录去外径-有效记录区内径）/ 2 * 道密度</code><br></p><p><strong>格式化后实际容量只包括数据区(这里假定每个扇区512字节算)</strong><br><code>磁盘实际数据容量= 盘面数 * 磁道数/面 * 扇区数/磁道 * 512B/扇区</code></p><p>(3).数据传输速率 <br><br>数据传输速率：指的是磁表面存储器完成磁头定位和旋转等待以后，单位时间内从存储介质上读出或者写入的二进制信息量。</p><p>(4).平均存取时间 <br><br>通常，磁盘的平均存取时间近似等于平均寻道时间和平均等待时间之和。而且磁盘第一位数据的读写延时非常长，相当于平均存取时间，而以后的二位数据的读写则几乎没有延迟。</p><h2 id="6-3-3-磁盘存储器的连接"><a href="#6-3-3-磁盘存储器的连接" class="headerlink" title="6.3.3 磁盘存储器的连接"></a>6.3.3 磁盘存储器的连接</h2><p>现代计算机中，通常将复杂的磁盘物理扇区抽象成固定大小的逻辑块，物理扇区和逻辑块之间的映射由磁盘控制器来维护。磁盘控制器是一个内置固件的硬件设备，它能将主机送来的请求逻辑块号转化为磁盘的物理地址（柱面号，磁头号，扇区号），并控制磁盘驱动器进行相应的动作。</p><h2 id="6-3-4-固态硬盘-SSD"><a href="#6-3-4-固态硬盘-SSD" class="headerlink" title="6.3.4 固态硬盘(SSD)"></a>6.3.4 固态硬盘(SSD)</h2><p>#6.4 高速缓冲存储器(cache)<br> 由于CPU和主存所使用的半导体工艺不同导致两者在速度上由差距导致速度较快的CPU常常需要等到慢速的主存，为了加快CPU访存的速度，所以在CPU和主存之间增加 cache。（cache的速度与CPU的速度差不多）<br>\</p><h2 id="6-4-1-程序访问的局限性"><a href="#6-4-1-程序访问的局限性" class="headerlink" title="6.4.1 程序访问的局限性"></a>6.4.1 程序访问的局限性</h2><p>程序访问的局限性分为时间局部性和空间局限性。<br><br><strong>时间局部性：指的被访问的某个存储单元在一个较短的时间间隔内很可能又被访问。<br><br>空间局限性：指的是被访问的某个存储单元的临近的一个存储单元在一个较短的时间内很可能被访问。（例如循环访问数组）。<br></strong><br>为了更好的利用程序反问的空间局部性，通常把当前访问单元以及临近的单元作为一个主存块一起调入cache，在CPU和主存之间设置cache，总是把主存中被频繁访问的活跃的程序块和数据块复制到cache中，由于程序访问的局限性，大多情况下，CPU能直接从cache中取得指令和数据，而不必访问慢速的主存。<br></p><h2 id="6-4-2-cache的基本工作原理"><a href="#6-4-2-cache的基本工作原理" class="headerlink" title="6.4.2 cache的基本工作原理"></a>6.4.2 cache的基本工作原理</h2><p>为了便于cache与主存间交换信息，cache和主存空间被划分为相等的区域，例如，将主存按照每512个字节分成一个区域，同时把cache也划成同样大小的区域，这样主存中的信息可以按照512字节为单位送到cache中，我们把主存中的区域称为<strong>块</strong>，也称为<strong>主存块</strong> ，它是cache和主存之间的信息交换单位cache中存放一个主存块的区域叫做<strong>行</strong>或者<strong>槽</strong>。</p><h3 id="1-cache的有效位"><a href="#1-cache的有效位" class="headerlink" title="(1).cache的有效位"></a>(1).cache的有效位</h3><p>为了说明cache行中的信息是否有效，每个cache行都需要一个有效位。<br><br>有了有效位，就可以将有效位清0来淘汰某cache行中的主存；装入一个新主存块时在使有效位为1。<br></p><h3 id="2-CPU在cache中的访问过程"><a href="#2-CPU在cache中的访问过程" class="headerlink" title="(2).CPU在cache中的访问过程"></a>(2).CPU在cache中的访问过程</h3><p><img src="https://i.imgur.com/w5agUbu.png" srcset="/img/loading.gif" alt></p><h3 id="3-cache-—-主存层次的平均访问时间"><a href="#3-cache-—-主存层次的平均访问时间" class="headerlink" title="(3).cache —-主存层次的平均访问时间"></a>(3).cache —-主存层次的平均访问时间</h3><p><strong>cache命中</strong>：若CPU访问单元所在的主存块在cache中，则称为cache命中（hit），命中的概率称为命中率p，它等于命中次数与访问总次数之比。<br><br><strong>cache不命中</strong>：若CPU访问单元所在的主存块不在cache中，则称为cache不命中，其概率称为缺失率（miss rate），它等于不命中次数与访问总次数之比。<br><br><strong>命中时间：</strong>命中时CPU在cache中直接存取所用的时间开销就是cache访问时间T<sub>c</sub>称为命中时间。<br><br>缺失时需要从主存读取一个主存块送cache，并同时将所需信息送到CPU，所用时间时主存访问时间T<sub>m</sub>和cache访问时间T<sub>c</sub>之和。<br><br><strong>缺失损失:</strong>通常把从主存读入一个主存块到cache的时间T<sub>m</sub>缺失损失。<br></p><h2 id="6-4-3-cache行和主存块的映射"><a href="#6-4-3-cache行和主存块的映射" class="headerlink" title="6.4.3 cache行和主存块的映射"></a>6.4.3 cache行和主存块的映射</h2><p>把主存块复制到cache行时，主存块和cache行之间必须遵循一定的映射规则。<br><br><strong>主要分为三种映射规则：直接映射，全相联映射，组相联映射。</strong></p><h3 id="1-直接映射"><a href="#1-直接映射" class="headerlink" title="(1).直接映射"></a>(1).直接映射</h3><p>直接映射的基本思想是：把主存每一块映射到一个固定的cache行中，也称<strong>模映射</strong>，其映射关系如下：<br><br><code>cache行号 = 主存块号 mod cache行数</code><br></p><p>直接映射方式下：主存地址被分为标记，cache行号，块内地址三个字段。<br><br><img src="https://i.imgur.com/L37b3uQ.jpg" srcset="/img/loading.gif" alt><br><br>举例：假定共有2<sup>c</sup>行，主存共有2<sup>m</sup>块，主存块大小占2<sup>b</sup>字节，则按照字节编址，则上图中cache行号占c位，主存块号占m位，块内地址有b位，<strong>因为主存块号分解成标记字段和cache行号字段</strong>，因而标记字段占t=m-c位。<br></p><p><strong>直接映射的CPU访存过程：</strong><br><br><img src="https://i.imgur.com/1PTb7VT.png" srcset="/img/loading.gif" alt><br><br><strong>首先根据CPU给出的主存地址中的cache行号（如图cache字块地址）选择cache中对应的cache行，将行中的标记和CPU给出的主存地址中高t位进行比较，若相等而且有效位为1，则命中，此时根据CPU给出的主存地址低b位块内地址，在对应的cache行中存取信息。若不想等或者有效位为0，则cache 缺失，此时CPU从主存中读出该主存地址所在一块信息通过系统总线送到对应的cache行中，将有效位置1，并将标记设置为该地址的高t位，同时将该地址中的内容送CPU。</strong></p><p>直接映射的优缺点：<br><br><strong>优点</strong>：容易实现，命中时间短。<br><br><strong>缺点</strong>：cache行得不到充分利用，命中率比较低。<br></p><h3 id="2-全相联映射"><a href="#2-全相联映射" class="headerlink" title="(2).全相联映射"></a>(2).全相联映射</h3><p>全相联映射的基本思想是一个主存块可装入cache任意行中。<br><br>全相联映射cache中，每行的标记用于指出该行取自主存的哪个块，因为一个主存块可能出现在任意一个cache行中，所以需要比较所以cache行的标记，<strong>因此 主存地址中不需要cache行索引。</strong>，只有标记和块内地址两个字段。<br>所以全相联映射方式下，只要有空闲的cache行，就不会发生冲突，因而块冲突概率低。<br><br><img src="https://i.imgur.com/b2G6pQF.jpg" srcset="/img/loading.gif" alt><br></p><p>全相联映射优缺点：<br><br>优点是：块冲突率低。<br><br>缺点是：为了加快比较速度，通常每个cache行都设置一个比较器，比较器的位数等于标记字段的位数。全关联cache访存是根据标记字段的内容来访问cache行中的主存块，它查找主存块是”按内容访问”所以全关联映射的时间开销和所用元件都较大，实现起来困难。</p><h3 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="(3).组相联映射"></a>(3).组相联映射</h3><p>组相联映射的主要思想是：将cache分为大小相等的组，每个主存块被映射到固定组中的任意一行，也即采用<strong>组间模映射，组内全映射</strong>的方法。<br><br>映射关系如下：<br><br><code>cache组号 = 主存块号 mod cache组数</code><br></p><p>组相联方式下，主存地址被分为 标记 ，cache组号 ， 块内地址三个字段。<br><img src="https://i.imgur.com/36n3gxi.jpg" srcset="/img/loading.gif" alt><br><br> 假定cache共有2<sup>c</sup>行，被分为2<sup>q</sup>组，每组有2<sup>c</sup>/2<sup>q</sup>=2<sup>c-q</sup>行设s=c-q，则cache映射方向称为2<sup>s</sup>路组相联映射<strong>（即每组有多少行相联映射）</strong>。</p><p><strong>2路组相联映射的访存过程：<br><br>根据主存地址中的cache组号找到对应组—–&gt;找到对应组后就是“按内容访问”全关联模式了，根据主存地址中的标记字段与对应组中每一行的标记tag进行比较。——–&gt;若相等而且有效位为1则命中，执行相关操作，若不相等或者有效位为0，则不命中，也执行相应操作。</strong></p><h2 id="6-4-4-cache中主存块的替换算法"><a href="#6-4-4-cache中主存块的替换算法" class="headerlink" title="6.4.4 cache中主存块的替换算法"></a>6.4.4 cache中主存块的替换算法</h2><ol><li>FIFO算法(先进先出算法）</li><li>LRU算法（最近最少用算法）</li><li>LFU算法（最不经常用算法）</li><li>随机替换算法</li></ol><h2 id="6-4-5-cache的一致性问题"><a href="#6-4-5-cache的一致性问题" class="headerlink" title="6.4.5 cache的一致性问题"></a>6.4.5 cache的一致性问题</h2><ol><li>全写法</li><li>回写法(一般用回写法)</li></ol><h2 id="6-4-6-影响cache性能的因数"><a href="#6-4-6-影响cache性能的因数" class="headerlink" title="6.4.6 影响cache性能的因数"></a>6.4.6 影响cache性能的因数</h2><p><strong>&lt;1&gt;.</strong>决定系统访存性能的重要因数之一是cache 命中率，它与许多元素有关。</p><ol><li>命中率与关联度有关，关联度越高，命中率越高，关联度反映一个主存块对应的cache行的个数（直接映射的关联度为1，2路组相联映射的关联度为2，4路组相联映射的关联度为4；全关联映射为cache和行数。）</li><li>命中率与cache容量有关，显然cache容量越大，命中率就越高。</li><li>命中率与主存块的大小有关，采用大单位的主存块就能很好的利用空间的局部性，但是较大的主存块需要比较多的时间来存取，因此缺失损失会变大，由此可见，主存块大小必须适中，不能太大也不能太小。<br>&lt;2&gt;. 单级/多级cache，联合/分离cache的选择问题。<br></li></ol><p>&lt;3&gt;. 主存-总线-cache间的连接结构问题。<br>主存，总线和cache之间可以有三种连接方式：<br></p><ol><li>窄型结构:即在主存，总线和cache之间每次按一个字的宽度来进行传送。<br></li><li>宽型结构：即在它们之间每次传输多个字。<br></li><li>交叉存储结构:即在主存采用多模块交叉存取方式，在主存，总线和cache之间每次按照一个字的宽度来进行传送,例如：传输一个4字，第一个模块准备好第一个字，然后在总线上传输一个字，同时第二个模块已经准备好第二个字了，然后再总线上传输第二个字的时候，第三个模块已经准备好第三个字了，以此类推）。</li></ol><h1 id="6-5-虚拟存储器"><a href="#6-5-虚拟存储器" class="headerlink" title="6.5 虚拟存储器"></a>6.5 虚拟存储器</h1><h2 id="6-5-1虚拟存储器的基本概念"><a href="#6-5-1虚拟存储器的基本概念" class="headerlink" title="6.5.1虚拟存储器的基本概念"></a>6.5.1虚拟存储器的基本概念</h2><p>在采用虚拟存储技术的计算机中，指令执行时，通过存储器管理部件（MMU）将指令中的逻辑地址（虚拟地址 VA）转化为主存的物理地址（主存地址或实地址 PA）。在地址转换的过程中由硬件检查是否发生了访问信息不在主存或者地址越界或者访问越权，若发现信息不在主存，则由操作系统将数据从硬盘读到主存。若发生地址越界或访问越权，则由操作系统进行相应的因此处理。由此看出，虚拟技术即解决了编程空间受限的问题，又解决了多到程序共享主存带来的安全问题。<strong>{这里忽略cache，因为主存的空间是一定的所以如果没有虚拟存储技术的话，程序受到物理内存大小的限制，而且无法让多道程序共享主存，有了虚拟存储技术，就可以把主存看作一个比较大的cache}<br></strong></p><h2 id="6-5-2-虚拟地址空间"><a href="#6-5-2-虚拟地址空间" class="headerlink" title="6.5.2 虚拟地址空间"></a>6.5.2 虚拟地址空间</h2><p>每个高级语言源程序经过编译，汇编，链接等处理后都会生成可执行的二进制机器目标代码时，都被映射到一个统一的虚拟地址空间。所谓“统一”是指不同的可执行文件所映射的虚拟地址空间大小一样，地址空间中的区域划分结构也相同。<strong>（虚拟地址空间不是真实存在的，只是人们创造出来好理解CPU的寻址的，自己理解，有错请纠正）</strong></p><p><img src="https://i.imgur.com/JAGtXPH.jpg" srcset="/img/loading.gif" alt></p><h2 id="6-5-3-虚拟存储器的实现"><a href="#6-5-3-虚拟存储器的实现" class="headerlink" title="6.5.3 虚拟存储器的实现"></a>6.5.3 虚拟存储器的实现</h2><h3 id="1-分页式虚拟存储器"><a href="#1-分页式虚拟存储器" class="headerlink" title="1.分页式虚拟存储器"></a>1.分页式虚拟存储器</h3><p>分页式虚拟存储系统中，虚拟地址空间被划分为大小相等的页面，硬盘和主存之间按页面为单位交换信息。虚拟地址空间中的页称为虚拟页，逻辑页或虚页（简称VP）；主存空间也被划分为同样大小的页宽（物理页，实页，PF或者PP)。<br></p><ol><li>未分配页: 虚拟空间中没有和任何内容相关联的页称为“未分配页”。（堆区和栈区）<br></li><li>已分配页：虚拟空间中对于代码和数据等有内容的区域所关联的页面。（已分配页又分为缓存页和未缓存页)<br></li><li>缓存页和未缓存页:已调入主存而被缓存在DRAM中的页面称为缓存页，未调入主存而存在硬盘中的页称为未缓存页。<br><blockquote><p><strong>主存和cache之间交换单位为主存块，硬盘和主存之间交换的单位为页面。</strong><br><br>由于硬盘和主存之间交换数据太慢，所以缺页的代价特别大。所以考虑到缺页代价的问题，通常将主存和硬盘交换的页设置的比较大。<br><br>因为缺页的的代价比较大，所以主存页框和虚拟页之间采用全映射的方式，处理一致性的问题用回写法。<br></p></blockquote></li></ol><p>与cache必须使用一种方法来建立各个虚拟页和所存放的主存页框号或磁盘上的存储位置之间的关系，通常用<strong>页表</strong>来描述这种对应关系。<br></p><p>(1).页表(进程页表和内核页表）</p><p>进程页表和内核页表区别可以看这篇博客<a href="https://blog.csdn.net/yyf_it/article/details/52460359" target="_blank" rel="noopener">https://blog.csdn.net/yyf_it/article/details/52460359</a><br></p><p><img src="https://i.imgur.com/OjOz1Ch.png" srcset="/img/loading.gif" alt><br></p><p><strong>系统中每个进程都有一个页表，操作系统在加载程序时，根据可执行文件中的程序头表，确定每个可分配段（如只读代码段，可读可写数据段）所在的虚页号及磁盘中存放的位置，在主存中生成一个初始页表，初始页表中的每个页表项对应装入位都是0，在程序执行过程中，通过缺页异常处理程序，将磁盘上的代码和数据页面装入分配的主存页框中，并修改页表中相应页表项，例如，将存放位置改为主存页框号，将页表项中装入位置1.(—-&gt;这里指的是进程页表)</strong></p><p>(2).地址转换<br><br>采用虚存机制的系统，指令给出的地址时虚拟地址，CPU执行指令时，首先要将虚拟地址转化成主存的物理地址，才能到主存中取指令和数据，地址转化又MMU来完成.<br></p><p><img src="https://i.imgur.com/FZ6Uorq.png" srcset="/img/loading.gif" alt></p><p>(3). 快表<br><br>采用虚拟内存后，访存的次数增多了，为了减少访存次数，所以往往把页表中最活跃的几个页表复制到高速缓存中，这种高速缓存中的页表项组成的页表称为<strong>后备转化缓存器（TLB）</strong>，通常<strong>快表</strong>。相应的主存中的页表称为 <strong>慢表</strong>。<br><br>TLB的概述:<br><br>TLB是一个内存管理单元用于改进虚拟地址到物理地址转换速度的缓存.<br><br>TLB是位于内存中的页表的cache，如果没有TLB，则每次取数据都需要两次访问内存,即查页表获得物理地址和取数据.<br><br><img src="https://i.imgur.com/5bB23Rs.png" srcset="/img/loading.gif" alt><br><br><strong>上图中访存过程解释:CPU给出一个32位的虚拟地址，首先，由CPU中的MMU进行虚拟地址到物理地址的转换；然后，由处理cache的硬件根据物理地址进行存储访问。<br><br>MMU对TLB查表时，20位虚拟页号被分为标记Tag和组索引两部分，首先由组索引确定到TLB中的那一组进行查找，查找时将虚拟页号的标记部分和TLB中该组每个标记字段同时进行比较。若由某个相等而且有效位为1，则TLB命中，此时可以通过TLB进行地址转化；否则TLB缺失，此时就需要去访问主存去查慢表。图中所示的是两级页表方式，虚拟地址被分为页目录索引和页表索引两部分，根据这两部分可得到对应的页表项，从而进行地址转化，并将对应页表项的内容送入TLB形成一个新的TLB表项，同时，将虚拟页号的高位分作为TLB标记填入新的TLB表项中，若TLB已满，还需要进行TLB替换，TLB采用随机替换策略。</strong></p><p>(4). CPU访存过程<br><br><img src="https://i.imgur.com/D6Enyiw.png" srcset="/img/loading.gif" alt></p><h3 id="2-分段式虚拟存储器"><a href="#2-分段式虚拟存储器" class="headerlink" title="2.分段式虚拟存储器"></a>2.分段式虚拟存储器</h3><p>可以把段作为基本的信息单位在主存-辅存之间传送和定位，分段方式下，将主存空间按实际程序中的段来划分，每个段在主存中的位置记录在段表中，段的长度可以变化，所以段表中需有长度指示，即段长。每个进程都有一个段表，每个段在段表中有个段表项，可以用来指明对应段在主存中的位置，段长，访问权限，使用和装入情况，段表本身映射一个可定位段，可以存在外存中，需要时调入主存，但一般驻留在主存。<br></p><p>优点：段的分界与程序的自然分界相对应，易于编译，管理，修改和保护。<br><br>缺点：段的起点和终点不定，给主存空间分配带来麻烦，而且容易在主存中留下许多空白的零碎空间，造成浪费。<br><br><img src="https://i.imgur.com/wiXjxF0.png" srcset="/img/loading.gif" alt></p><h3 id="3-段页式虚拟存储器（IA-32-Linux就是采用段页式）"><a href="#3-段页式虚拟存储器（IA-32-Linux就是采用段页式）" class="headerlink" title="3. 段页式虚拟存储器（IA-32+Linux就是采用段页式）"></a>3. 段页式虚拟存储器（IA-32+Linux就是采用段页式）</h3><p>在段页式虚拟存储器中，程序按模块分段，段内在分页，用段表和页表（每个段一个页表)进行两级定位管理。段表中每个表项对应一个段，每个段表项中包含一个指向该段页表起始位置的指针，以及该段其他的控制和存储包含信息，有页表指明该段各页在主存中的位置以及是否装入，修改等状态信息。</p><h2 id="6-5-4-存储保护"><a href="#6-5-4-存储保护" class="headerlink" title="6.5.4 存储保护"></a>6.5.4 存储保护</h2><p>目的：为了避免主存中多道程序互相干扰，防止某进程出错而破坏其他进程的正确性，或某进程不合法地访问其他进程的代码或者数据区，应该对每个进程进行存储保护。<br><br><strong>条件：为了对操作系统的存储保护提供支持，硬件必须具有以下三种基本功能:</strong><br></p><ol><li>使部分CPU状态只能由操作系统内核程序写，而用户进程只能读不能写。（例如：TLB内容，页表首地址等，只能操作系统内核程序才能用特殊的指令来写）<br></li><li>支持至少两种特权模式。(用户态，内核态)<br></li><li>提供让CPU在内核态和用户态之间相互转化的机制。（如果用户进程需要访问内核代码和数据，那么必须通过系统调用接口（执行陷阱指令）来间接访问，响应异常和中断可使CPU从用户态转到内核态，异常和中断处理后返回指令可以使CPU从内核态转到用户态。<br></li></ol><p>存储保护包括以下两种情况：访问权限保护和存储器区域保护。</p><ol><li>访问权限保护</li><li>存储区域保护（加界重定位，键保护，环保护）<br>加界重定位：每个程序和程序段都有起始和终止地址，不可以越界，在分段式虚存中，通过段表来记录段的上界和下届。<br><br>键保护：操作系统给主存中的每一个页框分配一个存储键，给每个用户程序设置一个程序键。进程运行时，将程序状态字寄存器中的键（程序键）和所访问的页的键（存储键）进行核对相符才可以访问。（相当于锁和钥匙的关系）。<br><br>环保护;主存中各进程按其重要性分为多个保护级，各个级别构成同心环，最内环的进程保护级别最高，向外逐次降低。<br></li></ol><h2 id="6-6-IA-32-Linux中的地址转换"><a href="#6-6-IA-32-Linux中的地址转换" class="headerlink" title="6.6 IA-32+Linux中的地址转换"></a>6.6 IA-32+Linux中的地址转换</h2><p>在保护模式下，IA-32采用段页式虚拟存储管理方式，存储空间采用逻辑地址，线性地址，物理地址来进行描述。逻辑地址就是虚拟地址，IA-32中的逻辑地址由48位组成，包括16位段选择符和32位段内偏移量（即有效地址），为了便于多用户，多任务下的存储管理，IA-32采用分段基础上的分页机制。分段过程实现逻辑地址转换为线性地址，分页过程再实现将线性地址转换为物理地址。<br></p><h3 id="6-6-1逻辑地址到线性地址的转换"><a href="#6-6-1逻辑地址到线性地址的转换" class="headerlink" title="6.6.1逻辑地址到线性地址的转换"></a>6.6.1逻辑地址到线性地址的转换</h3><p>1.段选择符和段寄存器<br><br>TI表示段选择符要选择哪一个段描述符表，TI=0选全局描述符表（GDT），TI=1选局部描述符表（LDT）。<br><br>RPL用来定义段选择符的特权等级RPL=00 表示第0级，是最高级的内核态，若RPL=11，则为第3级是最低级的用户态。<br><br><img src="https://i.imgur.com/nJ5XZzb.png" srcset="/img/loading.gif" alt></p><p>段寄存器：<br><br>CS：代码段寄存器<br><br>SS:   栈段寄存器<br><br>DS：数据段寄存器<br><br>ES，FS，GS：可以指向任意段寄存器。<br></p><p>2.段描述符<br></p><p><img src="https://i.imgur.com/WbAh8dm.png" srcset="/img/loading.gif" alt><br><br>特权位和访问权限的含义说明如下：<br><br>G:表示粒度大小，G=1说明段以页（4KB）为基本单位；G=0则段以字节为基本单位。由于界限为20位，所以G=0时，最大的段位2<sup>20</sup> X 1B = 1MB;当G = 1时最大的段位2<sup>20</sup> X 4KB=4GB。<br><br>D: D=1表示地址和数据位32位宽，D=0表示地址和数据为16位宽。<br><br>P: 说明段是否存在主存中。P=1表示存在，P=0表示不存在。Linux总是把P置成1，因为它从来不会把一个段交换到磁盘上而是以页为单位进行交换。<br><br>DPL：访问段时对当前特权级的最低等级要求，只有CPL=0（内核态)时才能访问DPL=0的段，任何进程（CPL=3或者0) 都可以访问DPL=3的段。<br><br>S: S=0表示是系统控制段描述符，S=1表示是普通代码段或者数据段描述段。<br><br>TYPE： 指示段的访问权限或者系统控制段描述符的类型。<br><br>A：说明段是否被访问过。A=1代表段被访问过，A=0代表没有被访问过。<br><br>AVL：可以由操作系统定义使用。Linux忽略这个字段。<br></p><p>3.段描述符表<br><br>段描述符表就是分段方式下的段表，由段描述符组成，主要有三个类型：全局描述符表（GDT），段描述符表（LDT）和中断描述符表（IDT）。</p><p>4.用户不可见寄存器<br><br>除了六个段寄存器以外，还提供了多个用户进程不可以直接访问的内部寄存器，它们包括描述符cache，任务寄存器（TR），局部描述符表寄存器（LDTR），全局描述表寄存器（GDTR）和中断描述符寄存器（IDTR）。操作系统通过特权指令可对寄存器TR，LDTR，GDTR，IDTR进行读写。<br></p><p><img src="https://i.imgur.com/iIjOFER.jpg" srcset="/img/loading.gif" alt><br>描述符cache：其作用如上图描述。<br><br>全局描述符表寄存器（GDTR）：高32位存放GDT首地址，低16位存放界限。<br><br>中断描述符表寄存器（IDTR）：高32位存放IDT首地址，低16位存放界限<br><br><strong>局部描述符表寄存器（LDTR）（LDTR有点不同）：是16位寄存器，存放局部描述符表LDT的段选择符，通过该选择符可把GDT中的LDT描述符表中的部分信息（包括LDT首地址，LDT界限和访问权限）装入LDT描述符cache中从而使CPU可以快速访问LDT</strong><br><br>任务寄存器（TR）也是16位，用来存放任务状态段（TSS）的段选择符，通过该段选择符可把GDT表中的TSS描述符中部分信息（包括TSS首地址，TSS界限和访问权限等），装入TSS描述符cache中，从而可以方便的对任(即用户进程）的状态信息进行访问。<br></p><p>5.逻辑地址向线性地址的转换<br><br><strong>访问LDT表的过程<br></strong><br><img src="https://i.imgur.com/zbAkDhE.jpg" srcset="/img/loading.gif" alt><br><br><strong>访问GDT表的过程<br></strong><br><img src="https://i.imgur.com/F1oceHG.jpg" srcset="/img/loading.gif" alt><br></p><p><strong>注意：Linux中用户态和内核态的每个段的线性地址都是从基地址0开始，都是以4KB为粒度（G=1),所以所有逻辑地址中的段内偏移量（即有效地址）就是其线性地址。</strong></p><h3 id="6-6-2-线性地址到物理地址的转换"><a href="#6-6-2-线性地址到物理地址的转换" class="headerlink" title="6.6.2 线性地址到物理地址的转换"></a>6.6.2 线性地址到物理地址的转换</h3><p>IA-32采用段页式虚拟存储管理方式，通过分段方式完成逻辑地址到线性地址的转换后，再进行一步<strong>通过分页方式将线性地址转化为物理地址</strong>。<br></p><p>先介绍IA-32中的控制寄存器：<br><br>1.控制寄存器<br><br>CR0：CR0控制寄存器定义了多个控制位：<br></p><blockquote><p>1.保护模式允许位PE:PE=0(实地址模式），PE=1（保护地址模式）。<br><br>2.分页允许位PG: PG=1启用分页部件工作，PG=0则禁止分页部件工作，此时线性地址被直接作为物理地址使用。<br><br>3.任务切换位TS:每次任务切换时将其置1，任务切换完毕则清0。<br><br>4.对齐屏蔽位AM:它可以与EFLAGS中的AC位配合使用，若AM=1且AC=1，则进行对齐检查，若AM=0，则禁止对齐检查。<br><br>5.cache功能控制位NW和CD，只有NW和CD均为0时，cache才能工作。<br></p></blockquote><p>CR2是页故障线性地址寄存器，存放引起页故障（即缺页）的线性地址。只有CR0中的PG=1时,CR2才有效。<br><br>CR3是页目录基址寄存器，用来保存页目录再内存的起始地址，只有CR0中的PG=1时，CR3才有效。<br></p><p>2.线性地址向物理地址的转换<br><br><img src="https://i.imgur.com/4uRy7dZ.jpg" srcset="/img/loading.gif" alt><br><br>上述转换过程中10位的页目录索引（Directory）和页表索引（Table）都要乘以4，因为每个页目录项和页表项都是32位（4B),占4个字节。<br><br><img src="https://i.imgur.com/Ws6ibdj.png" srcset="/img/loading.gif" alt><br></p><blockquote><p>P: P=1表示页表或者页在主存中，P=0表示不再主存中，此时页故障（缺页异常），需要将页故障线性地址记录在CR2中，操作系统在处理页故障时会将缺失的页表或页从硬盘装入主存中，并重新执行页故障的指令。<br><br>R/W:该位为0时表示页表或者页只能读不能写，为1时表示可读可写。<br><br>U/S：该为为0时表示用户进程不能访问，为1时允许用户进程访问，该位可以保护操作系统所使用的页不受用户进程的破坏。<br><br>PWT: 用来控制页表对应的cache写策略时全写还是回写。<br><br>PCD：用来控制页表或者页能否被缓存到cache中。<br><br>A: A=1表示页或者页表被访问过，初始化时操作系统将其清0，利用该标志，操作系统可以清楚的了解哪些页表或者页正在使用，一般选择长期未用的页或者最少使用的页调出主存。<br><br>D :脏位或者叫修改位，该位在页目录项中没有意义，在页表项中有意义，D=1表示该页被修改过，D=0表示没有被修改过，修改过的页，操作系统在把该页清理出主存时会把它回写到硬盘中。<br></p></blockquote><h2 id="Linux系统的虚拟存储管理"><a href="#Linux系统的虚拟存储管理" class="headerlink" title="Linux系统的虚拟存储管理"></a>Linux系统的虚拟存储管理</h2><p>“进程”的引入 除了为应用程序提供一个独立的逻辑控制流，还为应用程序提供了私有的地址空间，<strong>使的程序员以为自己的程序在执行的过程中独占拥有存储器（幻觉！）</strong>，这个私有地址空间就是虚拟地址空间。<br><br><img src="https://i.imgur.com/xHjPSX3.png" srcset="/img/loading.gif" alt><br></p><p><strong>目前比较新的Linux发行版，用objdump去查看这些可执行文件的反汇编代码，会发现其代码起始位置不是在0x8048000（IA-32）或者0x400000(x86-64)而是在地址0附近，这主要是为了提高代码的安全性而采用了ASLR技术（地址空间随机化技术）。</strong></p><h3 id="Linux虚拟地址空间中的区域"><a href="#Linux虚拟地址空间中的区域" class="headerlink" title="Linux虚拟地址空间中的区域"></a>Linux虚拟地址空间中的区域</h3><p>Linux内核为每个进程维护了一个<strong>进程描述符</strong>（类似段描述符之类的），数据类型为task_struct结构，task_struct中记录了内核运行该进程所需要的所有信息，例如，进程的PID，指向用户栈的指针，可执行目标文件的文件名等。<br><br><img src="https://i.imgur.com/vqiVOte.png" srcset="/img/loading.gif" alt><br><br>task_struct结构中有个指针mm指向一个mm_struct描述的对应进程虚拟存储空间的当前状态，其中有一个字段是pgd，它指向对应进程的第一级页表（页目录表）的首地址，因此，当处理器运行对应的进程时，内核会将它送到CR3控制寄存器中，mm_struct中还有一个字段mmap，它指向一个由vm_area_struct构成的链表表头。Linux采用链表方式管理用户空间中的区域，使得内核不用记录那些不存在的“空洞”页面。<br><br>每个vm_area_struct描述了对应进程虚拟存储空间中的一个区域，vm_area_struct中部分字段如下：<br><br>vm_start: 指向区域开始处<br><br>vm_end:指向区域结束处<br><br>vm_prot：描述区域包含的所有页面的访问权限<br><br>vm_flags：描述区域包含的页面是否与其他进程共享<br><br>vm_next：指向链表下一个vm_area_struct<br></p><h3 id="Linux中页故障处理"><a href="#Linux中页故障处理" class="headerlink" title="Linux中页故障处理"></a>Linux中页故障处理</h3><p><strong>当CPU中的MMU在对某地址VA进行地址转换时，若检测到页故障，则转入操作系统内核进行页故障处理，Linux内核根据上述对虚拟地址空间中各区域的描述，将VM与vm_area_struct链表中每一个vm_start，vm_end进行比较，以判断VA是否属于空洞页面。若是，则发生“段故障”，若不是，则在判断所进行的操作是否和所在区域的访问权限 相符（由vm_prot描述）。若不相符，例如 假定VA为代码区，访问权限是PROT_EXE（可执行），但对地址VA的操作是“写”,那么就发生了“访问越权”；假定在用户态下访问属于内核的区域，访问权限为PORT_NONE（不可访问），那么就发生了“访问越级”，段故障和访问越级和访问越权都会导致终止当前进程。<br><br>若不是发生上述的情况，则内核判断发生了正常的缺页异常，把硬盘内的页装入主存中返回缺页指令处继续执行。<br></strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础-袁春风</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符号表和符号解析</title>
    <link href="undefined2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/"/>
    <url>2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h1><p>链接器在生成一个可执行文件时，必须完成符号解析，而要进行符号解析就必须要使用符号表。<br></p><p>符号类型：全局符号，外部符号，本地符号。<br><br>以模块m为例：包括在符号表中的符号有以下三种不同类型<br><br>全局符号：在模块m中定义并被其他模块引用的符号，这类符号包括：非静态的函数名和定义为不带static属性的全局变量名。<br><br>外部符号：在其他模块定义并被m引用的符号，包括在其他模块定义的外部函数名和外部变量名。<br><br>本地符号：在模块m中定义并在m中引用的本地符号，这类符号包括带static属性的函数名和全局变量名。<br></p><p><strong>注意：上述三类符号不包括分配在栈中的非静态局部变量（auto变量），链接器不需要这一类变量的信息，因而他们不在节.symtab定义的符号表中。（指的是符号表中的符号在.data和.bss中的符号，和栈中的符号没关系）</strong><br></p><p>符号表里面装了：<br>1.符号在字符串表中的索引（st_name）<br><br>2.符号的值（st_value)在可重定位文件中，是指符号所在位置相对于所在节起始位置的字节偏移量。在可执行目标文件和共享文件中，st_value则是符号所在的虚拟地址。<br><br>3.符号的类型（st_info)指出符号的类型和绑定属性，如未指定的（NOTYPE），变量（OBJECT），函数（FUNC），节（SECTION)等。<br></p><h1 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h1><p>符号解析的目的是将每个模块中引用的符号与某个目标模块中的定义符号建立关联。每个定义符号在代码段或数据段都被分配了存储空间，因此，将引用符号与对应的定义符号建立关联后，就可以在重定位时将引用符号的地址重定位为定义符号的地址。<br></p><p>编译器的对源程序编译时，会把每个全局符号输出在汇编代码文件中，每个全局符号或者是强符号或者弱符号。编译器把全局符号的强弱特性，隐含地编码在可重定位目标文件的符号表中，以供链接时符号解析所用。<br></p><h2 id="全局符号的强，弱特性"><a href="#全局符号的强，弱特性" class="headerlink" title="全局符号的强，弱特性"></a>全局符号的强，弱特性</h2><p><strong>强符号：函数名或者已初始化的全局变量名是强符号，未初始化的全局变量是弱符号，本地符号没有强弱之分。</strong><br></p><p>1.强符号不能多次定义，也就是强符号只能被定义一次，否者链接错误。<br><br>2.若一个符号被说明为一次强符号定义和多次弱符号定义，则按照强符号定义为准。<br><br>3.若有多个弱符号定义，则任选其中一个。<br></p><h2 id="符号解析过程"><a href="#符号解析过程" class="headerlink" title="符号解析过程"></a>符号解析过程</h2><p>链接器按照所有可重定位目标文件和静态库文件出现在命令行中的顺序从做到右依次扫描他们，在此期间要维护多个集合。<br><br>集合E：是将被合并在一起组成可执行文件的所有目标文件的集合。<br><br>集合U：是为解析符号的集合。<br><br>集合D：是指当前为止已被加入到E的所有目标文件中定义符号的集合。<br></p><p>符号解析开始时三个集合都是空集：然后对命令行输入一个文件f<br><br>如果f是目标文件就把f加入E，在根据f文件中未解析的符号和定义符号分别对U,D进行修改。<br><br>如果f文件是库文件，链接器就会尝试把U中未解析的符号和f中各个模块的符号进行匹配。如果f中的某个目标模块定义了一个U中的一个或者多个符号就把这个模块加入E，被定义的符号加入D，若没有定义则抛弃。<br><br>如果处理过程中出现双重定义就是一个符号在D中出现两次，或者扫描完成了U中还有未定义符号（U非空的话），链接器报错。<br></p><p>静态链接时，命令时从左到右读，而且库文件的顺序要按照引用关系来写。<br><br>命令：gcc - static -o xxxxx main.o ./libc.a （libc.a也可以不写，链接器会自动在最后加上去）<br></p><img src="/2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5.jpg" srcset="/img/loading.gif" class title="可重定位目标文件与静态库的链接">]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标文件格式</title>
    <link href="undefined2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="ELF目标文件格式"><a href="#ELF目标文件格式" class="headerlink" title="ELF目标文件格式"></a>ELF目标文件格式<br></h1><p>目标文件格式有很多种，例如：System V UNIX 的COFF，window 的PE，Linux 的ELF。<br></p><h1 id="链接视图"><a href="#链接视图" class="headerlink" title="链接视图"></a>链接视图</h1><h3 id="可重定位目标文件格式"><a href="#可重定位目标文件格式" class="headerlink" title="可重定位目标文件格式"></a>可重定位目标文件格式</h3> <br><p><strong>(1).ELF头</strong><br><br>ELF头位于目标文件的起始位置，包括文件结构说明信息。ELF头的数据结构分为32位系统对于结构和64位系统对应结构。(可以使用readelf -h 命令对某个可重定位目标文件的ELF头进行解析。例如：对main.o头文件进行解析：readelf -h main.o）<br><br><strong>(2).节</strong><br><br>节是ELF文件的主体信息，包含了链接过程所用的目标代码信息，包括指令，数据，符号表和重定位信息等。<br><br>.text :目标代码部分<br><br>.rodata:只读数据节<br><br>.data:已初始化全局变量<br><br>.bss:未初始化的全局变量（不占据实际的磁盘空间）<br><br>.symtab：符号表，程序中定义的函数名和全局静态变量名都属于符号，与这些符号相关的信息也保存在符号表中。<br><br>.rel.text: .text节相关的可重定位信息。当链接器将某一个目标文件和其他目标文件组合时，.text节中的代码被合并后，一些指令中引用的操作地址信息或跳转目标指令的位置信息等都可以能被修改，通常，调用外部函数或引用全局变量的指令中的地址字段需要修改。<br><br>.rel.data:.data节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时, .data节中的代码被合并后，一些全局静态变量的地址可能被修改。<br><br>.debug:调试用符号表，有些表项对定义的局部变量和定义的类型进行说明，有些表项对定义和引用的全局静态变量进行说明。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.line：C源程序中的行号和.text节中机器指令之间的映射。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.strlab:字符串表，包括.symtab节和.debug节中的符号以及节头表中的节名。字符串表就是以null结尾的字符串序列。<br><br><strong>(3).节头表</strong><br><br>节头表由若干个表项组成，每个表现描述相应的一个节的节名，在文件中的偏移，大小，访问属性，对齐方式等。</p><h2 id="执行视图"><a href="#执行视图" class="headerlink" title="执行视图"></a>执行视图</h2><br><p>与ELF可重定位文件不同的是：<br><br><strong>1.</strong>ELF头文件中的字段e_entry给出了系统将控制权转移到虚拟地址（入口点），即执行程序时第一条指令的地址而可重定位文件中，此字段为0。<br><br><strong>2.</strong>多了一个.init节，其中.init节定义了一个_init函数用来可执行目标文件开始执行时的初始化工作，当程序开始时，系统进入主函数之前先执行这个节中的指令代码。<br><br><strong>3.</strong>去掉了用去重定位的节.rel.text和.rel.data（因为已经重定位完毕了）。<br><br><strong>4.</strong>多了一个程序头表：也叫做段头表，是一个结构数组。<br></p><h2 id="可执行文件的存储器映像"><a href="#可执行文件的存储器映像" class="headerlink" title="可执行文件的存储器映像"></a>可执行文件的存储器映像</h2><br><p>当启动一个一个可执行目标文件时，首先会通过某种方式调出常驻内存的一个称为加载器（loader)的操作系统程序来进行处理，例如，任何的Unix程序的加载执行都是通过调用execve目标文件中相关节的内容与虚拟地址空间中的只读代码段和可读写代码段通过页表建立映射，然后启动可执行目标文件中的第一条指令执行。（这里关系到页表的内容在6.5节还没学到)</p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第4章—程序的链接</title>
    <link href="undefined2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/"/>
    <url>2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-程序的链接-小结《课本214页》"><a href="#第4章-程序的链接-小结《课本214页》" class="headerlink" title="第4章 程序的链接-小结《课本214页》"></a>第4章 程序的链接-小结《课本214页》</h1><p><strong>1.</strong>链接器位于编译器，指令集体系结构和操作系统的交叉点上，涉及指令系统，代码生成，机器语言，程序转换和虚拟存储管理等诸多概念。<br><br><strong>2.</strong>链接处理涉及三种目标文件格式：可重定位目标文件，可执行目标文件和共享库目标文件。<br><br><strong>3.</strong>共享库文件是一中特殊的可定位目标文件。<br><br><strong>4.</strong>ELF目标文件格式有链接视图和执行视图两种，前者是可重定位目标格式，后者是可执行目标格式。<br><br>链接视图包括：ELF头，各种节，节头表。<br><br>执行视图包括：ELF头，程序头表，各种节组成的段。<br><br><strong>5.</strong>链接包括两种链接形式：一是：静态链接，二是：动态链接。<br><br>静态链接：就是将多个可重定位文件中的相同类型的节合并起来以生成完全链接的可执行目标文件，它的所有符号引用都是确定的虚拟地址空间中的最终地址，因而可以直接被加载执行。<br><br>动态链接：动态链接模式下的可执行目标文件是部分链接的，还有一部分的引用地址没有确定，需要利用共享库中的定义符号进行重定位，因而需要由动态链接器来加载共享库并重定位可执行文件中部分文件的引用。<br><br>动态链接又有两种形式分别是：一种是可执行目标文件加载时进行共享库的动态链接；另一种时可执行目标文件执行时进行共享库的动态链接。<br><br><strong>6.</strong>在不同模块可能会定义相同的符号 <strong>（这里说的符号指的是被写入.data节.bss节中的符号，不包括执行时栈中的符号）</strong>，因为相同的多个符号只能分配一个地址，所以链接器以哪个符号为准？编译器通过对定义符号标识是强符号还是弱符号，由链接器根据一套规则来确定多重定义符号中哪个为唯一的定义符号。<br><br><strong>7.</strong>加载器在加载可执行目标文件时，实际上只是把可执行目标文件中的只读代码段和可读写数据段通过页表映射到了虚拟地址空间中的确定位置，并没有真正的把代码和数据从磁盘装入主存。<br></p><h1 id="过程梳理："><a href="#过程梳理：" class="headerlink" title="过程梳理："></a>过程梳理：</h1><p><strong>预处理–&gt;编译–&gt;汇编–&gt;链接</strong><br></p><h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="(1.)预处理"></a>(1.)预处理</h2><p>对预处理文件命令进行处理，包括对头文件的包含，对宏的扩展，条件编译的选择等，例如：#include&lt;xxxx.h&gt;把xxxx.h文件的内容插入源程序文件中。<br><br>gcc命令：“gcc - E main.c -o main.i”和“ cpp main.c -o main.i”<br></p><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="(2.)编译"></a>(2.)编译</h2><p>编译器把代码进行优化（也可以不进行优化）和存储分配，最终把C语言源程序翻译成汇编语言程序。<br><br>gcc命令：“gcc -S main.i -o main .s”和 “ccl main.i -o main.s”<br></p><h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="(3.)汇编"></a>(3.)汇编</h2><p>把汇编语言代码转化为机器语言代码生成可重定位目标文件(.o文件）。<br><br>gcc命令：“gcc -c main.s -o main.o” 和 “as main.s -o main.o”<br></p><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="(4.)链接"></a>(4.)链接</h2><p>将所以有关联的可重定位目标文件组合起来，以生成一个可执行文件。（好处：模块化，效率高）<br></p><p>链接包括两步：<br></p><h3 id="1-符号解析"><a href="#1-符号解析" class="headerlink" title="1.符号解析"></a>1.符号解析</h3><p>将每一个符号引用与一个确定的符号定义建立关联。<br><br>符号包括:全局静态变量名和函数名，而非静态局部变量名则不是符号。编译器将所有的符号存放在可重定位目标文件的符号表中。<br></p><h3 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2.重定位"></a>2.重定位</h3><p>可重定位目标文件中的代码区和数据区都是从地址0开始的，链接器需要将不同模块中相同的节合并起来生成一个新的单独的节，并将合并后的代码区和数据区按照ABI规范确定虚拟地址空间划分（也称存储器映像）来重新确定位置。<br><br>例如，对于32位Linux系统存储器映像，其只读代码总是从地址0x8048000开始，而可读可写数据段总是在代码段后面（从下到上）第一个4KB对齐的地址处开始，因而链接器余姚重新确定每条指令的每个数据的地址，并且在指令中需要明确给定的引用符号的地址，这种重新定义代码和数据地址并更新指令中引用地址符号的地址的工作叫做重定位。<br></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC内嵌汇编中常见的constraint</title>
    <link href="undefined2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/"/>
    <url>2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/</url>
    
    <content type="html"><![CDATA[<p>1.”a”代表AL/AX/EAX/RAX寄存器<br><br>2.”b”代表BL/BX/EBX/RBX寄存器<br><br>3.”c”代表CL/CX/ECX/RCX寄存器<br><br>4.”d”代表DL/DX/EDX/RDX寄存器<br><br>5”D”代表DI寄存器<br><br>6.”S”代表SI寄存器<br><br>7.”m”代表内存操作数<br><br>8.”r”,”q”代表寄存器操作数（就是随便一个寄存器）<br><br>9.”i”代表立即数操作数<br><br>10.”f”代表浮点寄存器操作数<br><br>11.”F”代表浮点立即数操作数<br><br>12.”o”内存操作数，要求内存地址范围是在同样一个段内<br><br>13.”v”内存操作数，但是不在同一个段内<br><br>14.”n”一个确定值的立即数<br></p>]]></content>
    
    
    <categories>
      
      <category>内嵌汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内嵌汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏，#define</title>
    <link href="undefined2019/10/27/%E5%AE%8F%EF%BC%8C-define/"/>
    <url>2019/10/27/%E5%AE%8F%EF%BC%8C-define/</url>
    
    <content type="html"><![CDATA[<p>转载<br><br>原文链接：<a href="https://blog.csdn.net/Boring_Wednesday/article/details/78756696" target="_blank" rel="noopener">https://blog.csdn.net/Boring_Wednesday/article/details/78756696</a><br></p><div id="content_views" class="markdown_views">                    <!-- flowchart 箭头图标 勿删 -->                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/>                    </svg>                                            <h3 id="写在前面"><a name="t0"></a>写在前面：</h3><h3 id="本文所有代码均在linux环境下运行"><a name="t1"></a>本文所有代码均在<strong>Linux</strong>环境下运行</h3><h3 id="linux版本为centos-74"><a name="t2"></a><strong>Linux</strong>版本为CentOS 7.4</h3><hr><h3 id="宏定义"><a name="t3"></a>宏定义</h3><blockquote>  <h4 id="语法">语法</h4>  <h4 id="define-name-stuff">#define name Stuff</h4></blockquote><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PI 3.14</span><span class="hljs-comment">//定义一个M，值为3.14</span><span class="hljs-preprocessor">#define DO_FOREVER for(;;)</span><span class="hljs-comment">//定义一个死循环</span><span class="hljs-preprocessor">#define REG register</span><span class="hljs-comment">//定义REG来作为register的别名</span><span class="hljs-preprocessor">#define CASE break;case</span><span class="hljs-comment">//在switch中用CASE来补上break;</span><span class="hljs-preprocessor">#define DEBUG_PRINT printf("file:%s\tline:%d\tdate:%s\ttime:%s\n",\</span>                        __FILE__, __LINE__, __DATE__, __TIME__);<span class="hljs-comment">//测试预定义符号</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre><h3 id="1宏的作用范围"><a name="t4"></a>1、<strong>宏</strong>的<strong>作用范围</strong></h3><h4 id="先看下面代码">先看下面代码：</h4><p><img src="https://img-blog.csdn.net/20171209164450664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="让我们查看上图中代码经过预处理后的样子">让我们查看上图中代码经过预处理后的样子</h4><p><img src="https://img-blog.csdn.net/20171209165200867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以发现宏只对宏定义后的行数起作用且与定义在哪里无关即使函数不被调用也可以使用宏"><strong>可以发现宏只对宏定义后的行数起作用，且与定义在哪里无关，即使函数不被调用，也可以使用宏</strong></h4><h3 id="2宏替换的原则"><a name="t5"></a>2、<strong>宏替换</strong>的<strong>原则</strong></h3><h4 id="在程序中扩展define定义符号和宏时需要涉及几个步骤">在程序中扩展#define定义符号和宏时，需要涉及几个步骤。</h4><blockquote>  <h4 id="1-在调用宏时首先对参数进行检查看看是否包含任何由define定义的符号如果是它们首先被替换">1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。</h4>  <h4 id="2-替换文本随后被插入到程序中原来文本的位置对于宏参数名被他们的值替换">2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。</h4>  <h4 id="3-最后再次对结果文件进行扫描看看它是否包含任何由define定义的符号如果是就重复上述处理过程">3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。</h4></blockquote><h4 id="注意"><strong>注意</strong>：</h4><blockquote>  <h4 id="1宏函数不能出现递归">1、宏函数<strong>不能</strong>出现<strong>递归</strong></h4>  <h4 id="2宏定义的符号即name部分不会在预处理替换的时候被搜索">2、宏定义的符号，即name部分<strong>不会</strong>在预处理替换的时候被搜索</h4></blockquote><h3 id="3宏定义define后不需要加"><a name="t6"></a>3、宏定义#define后不需要加<code>;</code></h3><blockquote>  <h4 id="例如">例如：</h4>  <h4 id="define-m-100">#define M 100;</h4>  <h4 id="这里在100后面加上了">这里在100后面加上了<code>;</code></h4>  <h4 id="在句子中有时候就会出现问题">在句子中有时候就会出现问题</h4></blockquote><h4 id="观察下面代码片段">观察下面代码片段：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define M 100;</span><span class="hljs-keyword">if</span> (condition)    m = M；<span class="hljs-keyword">else</span>    max = <span class="hljs-number">0</span>；<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="在该选择语句中会出现语法错误没有与else与之匹配的if语句">在该选择语句中会出现语法错误，没有与else与之匹配的if语句</h4><h3 id="4宏函数申明"><a name="t7"></a>4、<strong>宏函数</strong>申明</h3><blockquote>  <h4 id="宏函数申明格式"><strong>宏函数申明格式：</strong></h4>  <h4 id="define-name-parament-list-stuff">#define name ( parament-list ) stuff</h4>  <h4 id="parament-list为参数表可以包含多个参数他们会在stuff出现">parament-list为参数表，可以包含多个参数，他们会在stuff出现</h4></blockquote><h4 id="例如-1"><strong>例如：</strong></h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQARE( X ) X*X</span><span class="hljs-comment">//定义一个计算乘方的宏函数</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><h4 id="但是这么定义是会出现预料之外的错误的观察下面代码片段">但是这么定义是会出现<strong>预料之外</strong>的错误的，观察下面代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQUARE(X) X*X</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, SQUARE(a+<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="本来结果应该为62-36">本来结果应该为6^2 = 36</h4><p><img src="https://img-blog.csdn.net/20171209161434163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="但是实际计算机输出的结果为11">但是实际计算机输出的结果为11</h4><h4 id="我们用gcc观察预处理后的代码片段是怎么样的">我们用gcc观察预处理后的代码片段是怎么样的</h4><h4 id="使用命令-gcc-e-testc-o-testi来查看预处理后的代码">使用命令<code>$ gcc -E test.c -o test.i</code>来查看预处理后的代码</h4><p><img src="https://img-blog.csdn.net/20171209162424712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以看到这里原式被替换成-a-1-a-1-11而这个结果显然不是我们期望的">可以看到这里原式被替换成 a + 1 * a + 1 = 11，而这个结果显然不是我们期望的</h4><h4 id="这里我们提出解决方案将-x-用括号括起来x这样就避免上述代码因符号优先级带来的错误">这里我们提出解决方案，将 X 用括号括起来（X），这样就避免上述代码因符号优先级带来的错误</h4><h4 id="至此上面代码解决了来看下面的宏函数定义">至此，上面代码解决了，来看下面的宏函数定义：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define DOUBLE(X) (X) + (X)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">10</span> * DOUBLE(a));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="期望结果为100而看程序执行结果">期望结果为100，而看程序执行结果：</h4><p><img src="https://img-blog.csdn.net/20171209163654504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="程序再次出现预料之外的结果原因是原式被替换成了">程序再次出现预料之外的结果，原因是原式被替换成了</h4><h4 id="10-5-5-55">10 * 5 + 5 = 55</h4><h4 id="解决方法"><strong>解决方法：</strong></h4><h4 id="在宏函数定义时对stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题">在宏函数定义时，对Stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题</h4><h3 id="5宏中的和"><a name="t8"></a>5、宏中的<strong>#</strong>和<strong>##</strong></h3><h4 id="的用法"><strong>#的用法</strong></h4><h4 id="首先要理解一个原则即邻近字符串连接原则">首先要理解一个原则，即<strong>邻近字符串连接原则</strong></h4><blockquote>  <h4 id="在c语言中">在C语言中</h4>  <h4 id="printfhello-worldn">printf(“hello”” world!”“\n”);</h4>  <h4 id="这句话是合法的">这句话是合法的</h4>  <h4 id="打印结果为">打印结果为：</h4>  <h4 id="hello-world">hello world!</h4></blockquote><h4 id="按照上述原则我们可以写出下列代码">按照上述原则，我们可以写出下列代码:</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PRINT(FORMAT, VALUE) printf("the value of " #VALUE " is "FORMAT"\n", VALUE)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    PRINT(<span class="hljs-string">"%d"</span>, i + <span class="hljs-number">3</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="看下gcc编译后的代码程序正常运行">看下gcc编译后的代码，程序正常运行：</h4><p><img src="https://img-blog.csdn.net/20171209173118273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="我们再通过gcc生成testi文件看下预处理是怎么样的">我们再通过gcc生成test.i文件看下预处理是怎么样的：</h4><p><img src="https://img-blog.csdn.net/20171209173520670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="所以我们可以看出来的作用">所以我们可以看出来<strong>#的作用：</strong></h4><h4 id="将一个宏参数变成一个对应的字符串">将一个<strong>宏参数</strong>变成一个<strong>对应的字符串</strong></h4><h4 id="在上述例子中">在上述例子中：</h4><blockquote>  <h4 id="value被替换成了i-3"><strong>#VALUE</strong>被替换成了<strong>“i + 3”</strong></h4>  <h4 id="别忘了被替换的时候i-3两边加上了双引号">别忘了被替换的时候i + 3两边<strong>加上了双引号</strong></h4></blockquote><h4 id="的用法-1"><strong>##的用法</strong></h4><h4 id="看下面的代码片段">看下面的代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define ADD_TO_AN(num, value) a##num += value</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">0</span>;    ADD_TO_AN(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);    ADD_TO_AN(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><h4 id="解释一下上面这段代码">解释一下上面这段代码</h4><h4 id="假设有一个变量叫a1">假设有一个变量叫a1</h4><h4 id="此时代码片段为addtoan1-5">此时代码片段为ADD_TO_AN(1, 5)</h4><h4 id="即替换为a1-5给a1变量增加5">即替换为a1 += 5，给a1变量增加5</h4><h4 id="同理addtoan2-6则替换成a2-6">同理ADD_TO_AN(2, 6)则替换成a2 += 6</h4><blockquote>  <h4 id="的作用"><strong>##的作用</strong></h4>  <h4 id="将两边的字符连在一起作为一个标识符">将##两边的字符连在一起作为一个标识符</h4>  <h4 id="前提连接后的标识符必须合法否则编译出现标识符未定义">前提连接后的标识符必须合法，否则编译出现标识符未定义</h4></blockquote><h3 id="6宏和函数"><a name="t9"></a>6、<strong>宏</strong>和<strong>函数</strong></h3><h4 id="宏通常被应用于执行简单的运算">宏通常被应用于执行简单的运算</h4><h4 id="和函数相比宏有他的优点">和函数相比，宏有他的优点</h4><blockquote>  <h4 id="宏的优点"><strong>宏的优点：</strong></h4>  <h4 id="1-用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多所以宏比函数在程序的规模和速度方面更胜一筹">1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以<strong>宏比函数在程序的规模和速度方面更胜一筹</strong></h4>  <h4 id="2-更为重要的是函数的参数必须声明为特定的类型所以函数只能在类型合适的表达式上使用反之这个宏怎可以适用于整形长整型浮点型等可以用于来比较的类型宏的参数与类型无关的">2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于<code>&gt;</code>来比较的类型。<strong>宏的参数与类型无关的</strong></h4>  <h4 id="3-宏参数可以使用变量类型而函数不可以例如">3. 宏参数<strong>可以使用变量类型</strong>，而函数不可以，例如：</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs cs has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MALLOC(num, type) (type *)malloc(num * sizeof(type))</span>MALLOC(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>);<span class="hljs-comment">//类型作为参数</span><span class="hljs-comment">//预处理器替换之后：</span>(<span class="hljs-keyword">int</span> *)malloc(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="但是宏参数与类型无关是一把双刃剑和函数比较也有他的缺点">但是，宏参数与类型无关是一把双刃剑，和函数比较也有他的缺点</h4><blockquote>  <h4 id="宏的缺点"><strong>宏的缺点：</strong></h4>  <h4 id="1-每次使用宏的时候一份宏定义的代码将插入到程序中除非宏比较短否则可能大幅度增加程序的长度">1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能<strong>大幅度增加程序的长度</strong></h4>  <h4 id="2-宏是没法调试的">2. <strong>宏</strong>是<strong>没法调试的</strong></h4>  <h4 id="3-宏由于类型无关也就不够严谨">3. <strong>宏由于类型无关</strong>，也就<strong>不够严谨</strong></h4>  <h4 id="4-宏可能会带来运算符优先级的问题导致程序容易出现问题">4. 宏可能会<strong>带来运算符优先级的问题</strong>，导致程序<strong>容易出现问题</strong></h4></blockquote><h4 id="我的建议"><strong>我的建议：</strong></h4><blockquote>  <h4 id="当有一部分功能既可以用函数实现也可以用宏实现且在调用函数的过程与宏使用过程所消耗的资源相当时优先考虑代码的严谨性使用函数">当有一部分功能既可以用函数实现也可以用宏实现，且在<strong>调用函数的过程</strong>与<strong>宏使用过程</strong>所<strong>消耗的资源相当时</strong>，<strong>优先考虑代码的严谨性</strong>，使用函数</h4></blockquote><h3 id="7宏参数的副作用"><a name="t10"></a>7、<strong>宏参数</strong>的<strong>副作用</strong></h3><blockquote>  <h4 id="当宏参数在宏的定义中出现超过一次的时候如果参数带有副作用那么你在使用这个宏的时候就可能出现危险导致不可预测的后果副作用就是表达式求值的时候出现的永久性效果">当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs perl has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-comment">#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )</span><span class="hljs-keyword">x</span> = <span class="hljs-number">5</span>;<span class="hljs-keyword">y</span> = <span class="hljs-number">8</span>;z = MAX(<span class="hljs-keyword">x</span>++, <span class="hljs-keyword">y</span>++);<span class="hljs-keyword">printf</span>(<span class="hljs-string">"x=<span class="hljs-variable">%d</span> y=<span class="hljs-variable">%d</span> z=<span class="hljs-variable">%d</span>\n"</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, z);<span class="hljs-regexp">//</span>结果为<span class="hljs-keyword">x</span>=<span class="hljs-number">6</span> <span class="hljs-keyword">y</span>=<span class="hljs-number">10</span> z=<span class="hljs-number">9</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre><h4 id="可以看到上面代码中y带来了副作用所以在使用宏的时候避免使用运算和-运算">可以看到上面代码中y++带来了副作用，所以在使用宏的时候，避免使用<code>++</code>运算和<code>--</code>运算</h4><h3 id="8宏的命名"><a name="t11"></a>8、宏的<strong>命名</strong></h3><h4 id="宏和函数的使用很类似我们平时的使用习惯是">宏和函数的使用很类似，我们平时的使用习惯是：</h4><blockquote>  <h4 id="1-宏名全部大写"><strong>1. 宏名全部大写</strong></h4>  <h4 id="2-函数名不全大写"><strong>2. 函数名不全大写</strong></h4></blockquote><h2 id="最后感谢所有访问我博客的来访者"><a name="t12"></a><strong>最后，感谢所有访问我博客的来访者</strong></h2>                                    </div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ main函数中参数argc和argv含义以及用法</title>
    <link href="undefined2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>原文链接:<a href="https://www.cnblogs.com/mtcnn/p/9412008.html" target="_blank" rel="noopener">https://www.cnblogs.com/mtcnn/p/9412008.html</a></p><div id="cnblogs_post_body" class="blogpost-body "><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argc 是 argument count的缩写，表示传入main函数的参数个数；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">简单用法示例，新建工程键代码：</span></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><p><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</p><p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;argv[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><p></p><p></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">argv是指向指针的指针，main函数的第二个参数<strong>“char *argv[]“也可以替换为 “char **argv“</strong>，两者是等价的。</span></p><span style="font-size:14px;">在编译环境下按F5运行，输出如下：</span><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721225702418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">可见，在没有参数传入的情况下，保存程序名称的第一个变量argv[0]依然存在。</span></p><p><span style="font-size:14px;">传参数给main函数有两种方法，第一种方式是在编译环境中设置，以vs2012为例，右击项目—&gt;属性—&gt;配置属性—&gt;调试—&gt;命令参数，在命令参数中输入，每个参数之间用空格隔开。</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721231958740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">之后点击确定并应用，运行之后显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232144436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">第二种方式也是经常会用到的方式是通过命令提示符传入。首先需要打开命令提示符窗口，点击开始菜单在“搜索程序和文件”里输入命令“cmd”或者直接按<strong>快捷键 Windows+R</strong>，在弹出的对话框里输入“cmd”即可打开命令提示符窗口：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232732806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">打开命令提示符窗口后需要输入生成的exe文件所在的完整路径，一个简便的方法是</span><span style="font-size:14px;background-color:rgb(255,0,0);">把exe文件直接拖入提示符窗口即可</span><span style="font-size:14px;">，之后输入传入参数，以空格分隔，之后回车，显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721233522377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">如果你坚持要手工输入完整路径的话，你会发现等你“Ctrl+C”路径后，在提示符窗口中按“Ctrl+V”却不能粘贴，这时候可以在窗口中右键单击一下试试，你会发现<strong><span style="color:#ff0000;">右键菜单里的粘贴功能还是有效的</span></strong>。</span></p><p><span style="font-size:14px;">下一个例子演示使用opencv显示一幅图片：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span><br></span>{<br>    Mat image=imread(argv[<span class="hljs-number">1</span>]);<br>    imshow(<span class="hljs-string">“Lena”</span>,image);<br>    waitKey();<br>}</p></code></pre><span style="font-size:14px;"></span><p></p><p></p><p><span style="font-size:14px;"><br></span></p>注意读入的参数是argv[1]，在命令提示符窗口运行：<p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721235245942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">最后说明一下：<span style="color:#ff0000;"><strong>一般编译器默认使用argc和argv两个名称作为main函数的参数，但这两个参数如此命名并不是必须的，你可以使用任何符合C++语言命名规范的变量名作为入参</strong></span>，效果是一样的：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,<span class="hljs-keyword">char</span> **point)</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;value;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;point[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><span style="font-size:14px;"><br><br></span><br><p></p><p></p></div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈工大-操作系统(实验二）-系统调用</title>
    <link href="undefined2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>此次实验的基本内容是：在linux-0.11上添加两个系统调用，并编写两个简单的应用程序测试他们。<br><br>感谢两位大佬的博客指点：<br><br><a href="https://www.jianshu.com/p/5786cd42b152" target="_blank" rel="noopener" title="寒夏凉秋">https://www.jianshu.com/p/5786cd42b152</a>  <br><br>  <a href="https://github.com/Wangzhike/HIT-Linux-0.11" target="_blank" rel="noopener" title="qiuyu_mac">https://github.com/Wangzhike/HIT-Linux-0.11</a><br></p><h1 id="应用程序怎么调用系统调用？"><a href="#应用程序怎么调用系统调用？" class="headerlink" title="应用程序怎么调用系统调用？"></a>应用程序怎么调用系统调用？</h1><blockquote><p>通常情况下，调用系统调用与调用一个普通的自定义代码没什么区别，但是调用后发生的事情不同，调用自定义函数通常通过call指令直接跳转到目标函数的地址处，继续运行，但是调用系统调用，是调用系统库中为系统调用编写的一个接口函数，叫做API（Application Programming Interface）（它对应一个宏_syscallx，在unistd.h中）。<br>API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用。</p><h2 id="（1）系统调用的基本过程"><a href="#（1）系统调用的基本过程" class="headerlink" title="（1）系统调用的基本过程"></a>（1）系统调用的基本过程</h2><p>1.应用程序调用库函数（API）<br><br>2.API函数要么通过自己添加含有int $0x80的嵌入汇编代码,要么调用syscall0到syscall3这四个宏函数（这四个函数在include/unistd.h中定义）将系统调用号存入EAX寄存器，通过int $0x80编程异常处理进入到内核态的<strong>系统调用</strong>处理函数system_call<br><br>3.<strong>系统调用</strong> 处理函数system_call根据系统调用号，调用对应的内核函数（真正的<strong>系统调用</strong>实现函数）<br><br>4.system_call处理完成后返回API函数中，并将内核函数的返回值通过EAX寄存器传递给API函数<br><br>5.API函数将返回值返回给应用程序</p><h2 id="（2）在Linux-0-11中添加一个系统调用foo（）的步骤："><a href="#（2）在Linux-0-11中添加一个系统调用foo（）的步骤：" class="headerlink" title="（2）在Linux 0.11中添加一个系统调用foo（）的步骤："></a>（2）在Linux 0.11中添加一个系统调用foo（）的步骤：</h2><p>1.编写API函数 foo()，根据器参数的个数，调用syscall0到syscall3这四个宏函数的其中一个，或者手动添加含有int $0x80的嵌入汇编代码，通过EAX寄存器传入系统调用号，进入内核。<br><br>2.在内核中实现 真正的系统调用函数sys_foo，并修改对应的makefile文件<br><br>3.同时在sys_call_table中加入sys_foo()函数的函数名，既入口地址，在该头文件中声明sys_foo()函数<br><br>4.在include/unistd.h中定义sys_foo()函数的系统调用号<br><br>5.修改kernel/system_call.s中代表系统调用总数的变量nr_system_calls的值<br><br>6.编写测试程序，修改添加了foo（）系统调用的Linux 0.11的文件系统下的unistd.h的文件，加入foo（）的系统调用号，运行测试程序，检验效果。</p><h3 id="实操："><a href="#实操：" class="headerlink" title="实操："></a>实操：</h3><p>(1).在虚拟机中编写号iam.c跟whoami.c两个文件（这两个文件就是我们全部完成实验步骤后在boch中运行的程序）<br><br>写好这两个文件后，在oslab中运行<br><br><code>sudo ./mount-hdc</code><br><br>可以把虚拟机硬盘挂载在oslab/hdc目录下然后再将文件复制到oslab/hdc/usr/root/下，usr/root/就是你的linux 0.11开机后所在的目录&lt;就相当于window的桌面上的东西&gt;<br><br>iam.c<br></p></blockquote><pre><code>//为什么要写#define __LIBRARY__这句话呢？我猜测是因为unistd.h中有一句#ifdef __LIBRARY__,//只有__LIBRARY__被定义过才能展开_syscall1().#define __LIBRARY__  #include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;_syscall1(int,iam,const char*,name)int main(int argc,char* argv[]){    iam(argv[1]);    return 0;}</code></pre><p>这里的int main中的两个参数分别代表的是<br><br>argc代表传入main函数的参数的个数<br><br>argv代表传入main函数的参数序列或指针<br><br>具体看这里：<a href="https://lexssama.github.io/2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">C++ main函数中参数argc和argv含义以及用法</a></p><p>whoami.c<br></p><blockquote></blockquote><pre><code>#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt; _syscall2(int, whoami, char*, name, unsigned int, size);int main(int argc, char ** argv){char t[30];whoami(t, 30);printf(&quot;%s\n&quot;, t);return 0;}</code></pre><p>(2).编写who.c文件（里面包括sys_iam()和sys_whoami()文件),将完成的who.c放进linux-0.11/kernel目录下<br><br>who.c<br></p><blockquote></blockquote><pre><code>#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;asm/segment.h&gt;char msg[24]; int sys_iam(const char * name){char tep[26];int i = 0;for(; i &lt; 26; i++){tep[i] = get_fs_byte(name+i);if(tep[i] == &#39;\0&#39;)  break;}if (i &gt; 23) return -(EINVAL);strcpy(msg, tep);return i;    }int sys_whoami(char * name, unsigned int size){int len = 0;for (;msg[len] != &#39;\0&#39;; len++);if (len &gt; size) {return -(EINVAL);}int i = 0;for(i = 0; i &lt; size; i++){put_fs_byte(msg[i], name+i);if(msg[i] == &#39;\0&#39;) break;}return i;}</code></pre><p>(3).修改linux-0.11/kernel中的makefile文件。<br><br>修改makefile文件为的是让添加的who.c文件可以和其他Linux代码链接在一起。<br><br><strong>修改完成后“make all”就能自动把who.c加入到内核中了</strong></p><blockquote></blockquote><pre><code>OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o改为：OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o who.o另一处：### Dependencies:exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h改为：### Dependencies:who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.hexit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h</code></pre><p>(4).在sys_call_table中(<strong>sys_call_table是一个指针变量存在于linux-0.11/include/linux/sys.h</strong>)加入sys_iam和sys_whoami函数的函数名，即入口地址，在改头文件中声明sys_iam和sys_whoami函数。</p><blockquote></blockquote><pre><code>extern int sys_setup();extern int sys_exit();extern int sys_fork();extern int sys_read();extern int sys_write();extern int sys_open();extern int sys_close();extern int sys_waitpid();extern int sys_creat();extern int sys_link();extern int sys_unlink();extern int sys_execve();extern int sys_chdir();extern int sys_time();extern int sys_mknod();extern int sys_chmod();extern int sys_chown();extern int sys_break();extern int sys_stat();extern int sys_lseek();extern int sys_getpid();extern int sys_mount();extern int sys_umount();extern int sys_setuid();extern int sys_getuid();extern int sys_stime();extern int sys_ptrace();extern int sys_alarm();extern int sys_fstat();extern int sys_pause();extern int sys_utime();extern int sys_stty();extern int sys_gtty();extern int sys_access();extern int sys_nice();extern int sys_ftime();extern int sys_sync();extern int sys_kill();extern int sys_rename();extern int sys_mkdir();extern int sys_rmdir();extern int sys_dup();extern int sys_pipe();extern int sys_times();extern int sys_prof();extern int sys_brk();extern int sys_setgid();extern int sys_getgid();extern int sys_signal();extern int sys_geteuid();extern int sys_getegid();extern int sys_acct();extern int sys_phys();extern int sys_lock();extern int sys_ioctl();extern int sys_fcntl();extern int sys_mpx();extern int sys_setpgid();extern int sys_ulimit();extern int sys_uname();extern int sys_umask();extern int sys_chroot();extern int sys_ustat();extern int sys_dup2();extern int sys_getppid();extern int sys_getpgrp();extern int sys_setsid();extern int sys_sigaction();extern int sys_sgetmask();extern int sys_ssetmask();extern int sys_setreuid();extern int sys_setregid();</code></pre><blockquote></blockquote><pre><code>extern int sys_iam();//需要新增的地方extern int sys_whoami();</code></pre><blockquote></blockquote><pre><code>fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid,sys_setregid, sys_iam, sys_whoami };//记得在中断向量表的最后填上系统调用</code></pre><blockquote></blockquote><p>(5).在include/unistd.h中定义sys_iam和sys_whoami的函数系统调用号。<br><br><strong>注意：unistd.h不能直接在oslab中修改</strong>，需要运行<br></p><blockquote></blockquote><p><code>sudo ./mount-hdc</code><br><br>把虚拟机硬盘挂载在oslab/hdc目录下，在hdc/usr/include目录中修改unistd.h。<br><br>至于为什么要这么做自己也没搞懂。</p><blockquote></blockquote><pre><code>#define __NR_setup    0   /* used only by init, to get system going */#define __NR_exit    1#define __NR_fork    2#define __NR_read    3#define __NR_write    4#define __NR_open    5#define __NR_close    6#define __NR_waitpid    7#define __NR_creat    8#define __NR_link    9#define __NR_unlink    10#define __NR_execve    11#define __NR_chdir    12#define __NR_time    13#define __NR_mknod    14#define __NR_chmod    15#define __NR_chown    16#define __NR_break    17#define __NR_stat    18#define __NR_lseek    19#define __NR_getpid    20#define __NR_mount    21#define __NR_umount    22#define __NR_setuid    23#define __NR_getuid    24#define __NR_stime    25#define __NR_ptrace    26#define __NR_alarm    27#define __NR_fstat    28#define __NR_pause    29#define __NR_utime    30#define __NR_stty    31#define __NR_gtty    32#define __NR_access    33#define __NR_nice    34#define __NR_ftime    35#define __NR_sync    36#define __NR_kill    37#define __NR_rename    38#define __NR_mkdir    39#define __NR_rmdir    40#define __NR_dup    41#define __NR_pipe    42#define __NR_times    43#define __NR_prof    44#define __NR_brk    45#define __NR_setgid    46#define __NR_getgid    47#define __NR_signal    48#define __NR_geteuid    49#define __NR_getegid    50#define __NR_acct    51#define __NR_phys    52#define __NR_lock    53#define __NR_ioctl    54#define __NR_fcntl    55#define __NR_mpx    56#define __NR_setpgid    57#define __NR_ulimit    58#define __NR_uname    59#define __NR_umask    60#define __NR_chroot    61#define __NR_ustat    62#define __NR_dup2    63#define __NR_getppid    64#define __NR_getpgrp    65#define __NR_setsid    66#define __NR_sigaction    67#define __NR_sgetmask    68#define __NR_ssetmask    69#define __NR_setreuid    70#define __NR_setregid    71   /*Linux system_call total 72*/#define __NR_iam    72     /*new system_call 72 and 73*/#define __NR_whoami    73</code></pre><p>(6).修改kernel/systeam_call.s中代表系统调用总个数的变量 nr_systeam_calls的值（原值是72，改为74）<br></p><blockquote></blockquote><pre><code>sa_handler = 0sa_mask = 4sa_flags = 8sa_restorer = 12nr_system_calls = 74</code></pre><p>(7).自此大功告成，cd 进入oslab中执行 ./run运行系统，<br>在boch中编译iam.c和whoam.c。</p><blockquote></blockquote><pre><code>gcc -o iam iam.c gcc -o whoami whoami.c </code></pre><p>运行./iam 和 ./whoami 。</p>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>系统调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的常用指令</title>
    <link href="undefined2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h1><blockquote><p>hexo n “我的博客” == hexo new “我的博客” —–&gt;新建文章<br><br>hexo p == hexo publish <br><br>hexo g == hexo generate —-&gt;生成<br><br>hexo s == hexo server —–&gt; 启动服务预览<br><br>hexo d == hexo deploy —–&gt;部署到博客上<br></p></blockquote><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><blockquote><p>hexo clean —&gt;清除缓存<br><br>hexo g —-&gt;生成静态网页<br><br>hexo d —-&gt;开始部署<br></p></blockquote><h1 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h1><blockquote><p>hexo generate –watch –&gt;监视文件变动</p></blockquote><h1 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h1><blockquote><p>hexo generate –deploy == hexo g -d<br><br>hexo deploy –generate == hexo d -g<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>