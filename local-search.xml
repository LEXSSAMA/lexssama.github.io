<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>层次结构存储系统</title>
    <link href="undefined2019/11/04/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <url>2019/11/04/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>教材：《计算机系统基础》，本博客主要用来梳理学习思路。(不然好乱）<br><br>不同类型的存储器设置的计算机中，其设置的顺序为：<br><br><strong>寄存器-&gt;cache-&gt;主存-&gt;硬盘-&gt;光盘和磁带。</strong><br><br>接下来就是详细的按顺序的介绍上面的存储器。<br></p><h1 id="6-1-存储器概述"><a href="#6-1-存储器概述" class="headerlink" title="6.1 存储器概述"></a>6.1 存储器概述</h1><h2 id="6-1-1-存储器的分类"><a href="#6-1-1-存储器的分类" class="headerlink" title="6.1.1 存储器的分类"></a>6.1.1 存储器的分类</h2><h3 id="1-按照存储元件分类"><a href="#1-按照存储元件分类" class="headerlink" title="1.按照存储元件分类"></a>1.按照存储元件分类</h3><p>半导体存储器，磁表面存储器：磁盘存储器和磁带存储器，光介质存储器：光盘存储器。</p><h3 id="2-按存取方式分类"><a href="#2-按存取方式分类" class="headerlink" title="2.按存取方式分类"></a>2.按存取方式分类</h3><h4 id="1-RAM-随机存取存储器）"><a href="#1-RAM-随机存取存储器）" class="headerlink" title="(1).RAM(随机存取存储器）"></a>(1).RAM(随机存取存储器）</h4><p>RAM特点是：按地址访问存储单元，RAM的存储介质是半导体存储器件，每个地址译码时间相同，在不用考虑行缓冲的前提下，每个单元的访问时间是一个常数，与地址无关（但是现在DRAM芯片大多都有行缓冲）。</p><h4 id="2-SAM-顺序存取存储器"><a href="#2-SAM-顺序存取存储器" class="headerlink" title="(2).SAM(顺序存取存储器)"></a>(2).SAM(顺序存取存储器)</h4><p>SAM的特点是：信息按照顺序存放和读出，其存取时间时间取决于信息存放的位置，以记录块为单位编址。例如：磁带存储器。（存储量大，存取速度慢）</p><h4 id="3-DAM-直接存取存储器"><a href="#3-DAM-直接存取存储器" class="headerlink" title="(3).DAM(直接存取存储器)"></a>(3).DAM(直接存取存储器)</h4><p>DAM的特点是：兼有随机访问和顺序访问的特点。首先直接定位在需要读写的位置，然后顺序方式存取，磁盘存储器就是如此。</p><h4 id="4-CAM-AM-相联存储器"><a href="#4-CAM-AM-相联存储器" class="headerlink" title="(4).CAM/AM(相联存储器)"></a>(4).CAM/AM(相联存储器)</h4><p>CAM/AM特点是：按照内容访问存储器(上面的RAM，CAM，SAM，都需要给出地址，CAM不用，CAM按照内容定位),例如：快表（TLB）。</p><h3 id="3-按照信息的可更改性分类。"><a href="#3-按照信息的可更改性分类。" class="headerlink" title="3. 按照信息的可更改性分类。"></a>3. 按照信息的可更改性分类。</h3><p>读写存储器(RAM),只读存取器（ROM）。RAM芯片和ROM芯片都采用随机存取的方式进行信息的访问。</p><h3 id="4-按断电后的信息的可保存性分类"><a href="#4-按断电后的信息的可保存性分类" class="headerlink" title="4.按断电后的信息的可保存性分类"></a>4.按断电后的信息的可保存性分类</h3><p>非易失性存储器：ROM，磁表面存储器，光盘存储器等。<br><br>易失性存储器：RAM,cache等。<br></p><h3 id="5-按照功能分类"><a href="#5-按照功能分类" class="headerlink" title="5.按照功能分类"></a>5.按照功能分类</h3><h4 id="1-高速缓存存储器（cache）"><a href="#1-高速缓存存储器（cache）" class="headerlink" title="(1).高速缓存存储器（cache）"></a>(1).高速缓存存储器（cache）</h4><p>cache：位于主存和CPU之间，由静态RAM芯片组成，存放CPU常用的指令和数据，速度接近CPU的工作速度。</p><h4 id="2-主存储器-主存"><a href="#2-主存储器-主存" class="headerlink" title="(2).主存储器(主存)"></a>(2).主存储器(主存)</h4><p>CPU执行指令是给出的存储地址最终必须转换为主存地址，主存用来存放系统启动运行的程序及其数据。</p><h4 id="3-辅助存储器（辅存）"><a href="#3-辅助存储器（辅存）" class="headerlink" title="(3).辅助存储器（辅存）"></a>(3).辅助存储器（辅存）</h4><p>系统运行时直接和主存交换信息的存储器叫做辅助存储器。例如：磁盘，辅存的内容要导入主存才能被CPU访问。</p><h4 id="4-海量后备存储器"><a href="#4-海量后备存储器" class="headerlink" title="(4).海量后备存储器"></a>(4).海量后备存储器</h4><p>磁带，光盘，U盘一类的吧。<br></p><p><strong>海量后备存储器和辅助存储器统称外存。</strong></p><h2 id="6-1-2-主存的组成和基本操作"><a href="#6-1-2-主存的组成和基本操作" class="headerlink" title="6.1.2 主存的组成和基本操作"></a>6.1.2 主存的组成和基本操作</h2><p><img src="https://i.imgur.com/mXC6RaT.png" srcset="/img/loading.gif" alt="主存储器的基本框图"><br>记忆单元（存储元）：是具有两种稳态的能表示二进制0和1的物理器件。<br><br>指令执行过程：（这里不考虑虚拟地址，cache的情况大略宏观上梳理一下CPU访存的过程，这里CPU给出的就是主存地址）<br><br>CPU先把欲访问的主存单元的地址送到主存地址寄存器(MAR)——&gt;MAR通过地址线把主存地址送到主存中的地址寄存器———&gt;地址译码器根据地址寄存器中的地址进行译码后选中存储阵列（存储体）中相应单元，同时CPU将读/写控制信号通过控制线送到主存的读写控制电路，进行读写操作，读写的数据通过MDR&lt;—&gt;数据线&lt;—&gt;存储阵列传输。<br><br><strong>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。</strong><br><br>图中采用64位数据线，因此在按字节编址下最多一次可以取8个字节的内容，地址线的位数决定主存地址空间最大可寻址范围：例如36位地址的最大可寻址范围位0~2<sup>36</sup>-1。</p><h2 id="6-1-3-存储器的主要性能指标"><a href="#6-1-3-存储器的主要性能指标" class="headerlink" title="6.1.3 存储器的主要性能指标"></a>6.1.3 存储器的主要性能指标</h2><p>存储器速度可以用访问时间，存储周期或者存储器带宽来表示。<br><br>(1).访问时间一般用读出时间（T<sub>A</sub>)和写入时间（T<sub>w</sub>)来表示。<br><br>(2).存储周期（T<sub>M</sub>)是指存储器进行一次读写操作所需要的全部时间。<br><br>(3).存储器带宽(B)：每秒传输信息的位数（字节）。</p><h2 id="6-1-4-各类存储元件"><a href="#6-1-4-各类存储元件" class="headerlink" title="6.1.4 各类存储元件"></a>6.1.4 各类存储元件</h2><p>半导体芯片：RAM芯片和ROM芯片。<br><br>RAM分为静态RAM芯片(SRAM)和动态RAM芯片(DRAM)。<br><br>ROM分为不可在线改写内容ROM和闪存(Flash ROM)。<br><br>SRAM:<strong>优点：</strong>速度快，无需刷新和读后再生。<strong>缺点：</strong>MOS管多，占硅面积大，功耗大，集成度低，价格贵。 <strong>应用：</strong>cache<br><br>DRAM: <strong>优点</strong>：MOS管少，占硅面积小，集成度高，价格便宜。 <strong>缺点</strong>：速度慢，需要定时刷新和读后再生。 <strong>应用</strong>：主存</p><h2 id="6-1-5-存储器的层次结构"><a href="#6-1-5-存储器的层次结构" class="headerlink" title="6.1.5 存储器的层次结构"></a>6.1.5 存储器的层次结构</h2><p><img src="https://i.imgur.com/M3VPO5U.png" srcset="/img/loading.gif" alt="存储器层次化体系结构示意图"></p><h1 id="6-2-主存与CPU的连接及其读写操作"><a href="#6-2-主存与CPU的连接及其读写操作" class="headerlink" title="6.2 主存与CPU的连接及其读写操作"></a>6.2 主存与CPU的连接及其读写操作</h1><h2 id="6-2-1-主存芯片技术"><a href="#6-2-1-主存芯片技术" class="headerlink" title="6.2.1 主存芯片技术"></a>6.2.1 主存芯片技术</h2><p>1.DRAM芯片技术<br><br>2.SDRAM芯片技术(同步DRAM)<br><br>3.DDR SDRAM芯片技术。<br><br>4.DDR2 SDRAM芯片技术。<br><br>5.DDR3 SDRAM芯片技术<br><br>不展开讲，因为涉及数字逻辑电路，不是很重点（自己觉得)，现在比较主要用SDRAM.</p><h2 id="6-2-2-主存与CPU的连接及其读写"><a href="#6-2-2-主存与CPU的连接及其读写" class="headerlink" title="6.2.2 主存与CPU的连接及其读写"></a>6.2.2 主存与CPU的连接及其读写</h2><h3 id="1-宏观上主存和CPU的关系"><a href="#1-宏观上主存和CPU的关系" class="headerlink" title="(1).宏观上主存和CPU的关系"></a>(1).宏观上主存和CPU的关系</h3><p><img src="https://i.imgur.com/7xQkMrt.jpg" srcset="/img/loading.gif" alt><br><br><strong>（什么什么）总线是连接其上的各部件的传输介质，通常由控制线，数据线，地址线构成。</strong><br><br>CPU通过系统总线和内存总线与主存相连，在CPU与主存之间交换信息时，CPU通过总线接口把总线控制信息和地址信息分别送到控制线和地址线，CPU和主存之间交换的数据信息则通过数据线传输。<br></p><p>受集成度和功耗等因数影响，单个芯片的容量不能很大，所以就要通过存储器芯片扩展技术将多个芯片做成一个内存条，然后通过多个内存条，以及主板或者扩充板上的RAM芯片和ROM芯片组成一台计算机所需要的主存空间，在通过总线，桥接器和CPU相连。<br></p><p>内存条插槽就是存储器总线，内存条中的信息通过内存条的引脚，再通过插槽内的引线连接到主板上，通过主板上的导线连接到北桥芯片或者CPU芯片。现在的计算机可以实现多条存储器总线同时进行传输，支持两条总线进行传输的内存条插槽为两通道内存插槽，还有三通道 四通道内存插槽，其总线传输的带宽可以提升2，3，4倍，<strong>在主机主板上相同颜色的插槽可以并行传输，如果有两个内存条可以插在两个颜色相同的内存条插槽上，其带宽可以增加一倍。（这个实用！）</strong><br></p><hr><h3 id="2-DRAM的扩展"><a href="#2-DRAM的扩展" class="headerlink" title="(2).DRAM的扩展"></a>(2).DRAM的扩展</h3><p>由若干个存储器构成的一个存储器，需要在字方向和位方向上进行扩展。<br><br><strong>位扩展：</strong>用若干片位数较少的存储器芯片构成给定字长的存储器（如下图z方向的扩展）<br><br><strong>字扩展：</strong>容量上的扩充，位数不变（z不变而一片DRAM芯片上的容量扩大）<br><br><strong>读写过程：CPU通过存储器控制器对内存条中的DRAM芯片进行读写，CPU读写的存储单元地址通过总线被送到存储控制器，然后由存储控制器将存储单元地址转化为DRAM芯片的行地址i和列地址j，分别在行地址选通信号RAS和列地址选通信号CAS的控制下，通过DRAM芯片的地址引脚，分时送到DRAM芯片内部的行地址译码器和列地址译码器，以选择行，列地址交叉点(i,j)【一个超元】，的8位数据同时进行读写，8个芯片就可以同时读取64位，组合成总线所需要的64位传输宽度，再通过存储器总线进行传输。</strong><br></p><p>正是主存这种存取数据的方式，就决定了计算机信息储存数据要对齐。<br><br><img src="https://i.imgur.com/tTYo7Cq.jpg" srcset="/img/loading.gif" alt="DRAM芯片的扩展"></p><hr><h3 id="3-DRAM芯片内部结构"><a href="#3-DRAM芯片内部结构" class="headerlink" title="(3). DRAM芯片内部结构"></a>(3). DRAM芯片内部结构</h3><p>图中芯片容量为16x8位，存储阵列为4行x4列，地址引脚采用复用方式，因此仅需2根地址引脚，再RAS和CAS的控制下分时传送2位行地址和2位列地址。每一个超元，有8位，需要8根数据引脚，有一个内部行缓冲，用来缓存指定行中每一列的数据，通常用SRAM元件实现。<br><br><img src="https://i.imgur.com/p4sbQ4i.png" srcset="/img/loading.gif" alt="DRAM芯片内部结构示意图"></p><p><strong>读写过程：图中反应了存储控制器再RAS有效时将行地址“2”送到行译码器后选中，第“2”行时的状态，此时，整一行数据被送到内部行缓存中，然后存储控制器再CAS有效时将列地址“1”送到选中的第“1”列时的状态，此时将内部行缓冲中第“1”列的8位数据超元（2，1）读到数据线，并向CPU传送。</strong><br><img src="https://i.imgur.com/Jj0AiXI.jpg" srcset="/img/loading.gif" alt="DRAM芯片读写原理示意图"></p><hr><h3 id="4-“装入”指令和存储“存储”指令操作过程"><a href="#4-“装入”指令和存储“存储”指令操作过程" class="headerlink" title="(4).“装入”指令和存储“存储”指令操作过程"></a>(4).“装入”指令和存储“存储”指令操作过程</h3><p>以 IA-32中的“movl 8(%ebp),%eax”指令为例：(这里8(%ebp)的计算在CPU中完成，涉及IA-32中的分段和分页存储管理机制，这里不展开说明)<br><br><strong>具体过程：<br><br>(1).图aCPU将主存地址A通过总线接口送到地址线，然后由存储控制器将地址A分解成行，列按分时的方式送给DRAM芯片。在进行这些操作的同时CPU还会把“存储器读”控制命令通过控制线送到主存。<br><br>(2).图b主存将地址A中的数据x通过数据线送到总线接口部件。<br><br>(3).图cCPU从总线接口部件中取出x存放在寄存器EAX中。<br></strong><br><img src="https://i.imgur.com/Fz80FzY.jpg" srcset="/img/loading.gif" alt="主存单元取数到寄存器的操作过程"></p><h1 id="6-3-硬盘存储器"><a href="#6-3-硬盘存储器" class="headerlink" title="6.3 硬盘存储器"></a>6.3 硬盘存储器</h1><h2 id="6-3-1磁盘存储器的结构"><a href="#6-3-1磁盘存储器的结构" class="headerlink" title="6.3.1磁盘存储器的结构"></a>6.3.1磁盘存储器的结构</h2><p><img src="https://i.imgur.com/opv5DqD.png" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/zyz1Nnp.png" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/wASJplS.jpg" srcset="/img/loading.gif" alt><br><br><strong>注意：每一个盘片都有两个磁头，正面一个反面一个。多个盘片上相同磁道形成一个柱面，所以磁道号就是柱面号</strong></p><hr><p><img src="https://i.imgur.com/hIxCGei.png" srcset="/img/loading.gif" alt></p><p><strong>读写过程：<br><br>(1).寻道操作：磁盘控制器把盘地址送到磁盘驱动器的磁盘地址寄存器后，便形成寻道命令，启动磁头定位伺服系统，根据磁头号和柱面号，选择指定的磁头移动到指定的柱面，此操作完成后，发出寻道结束信号给磁盘控制器，转入旋转等待操作。<br><br>(2).旋转等待操作：盘片旋转之前，首先将扇区计数器清零，以后每来一个扇区标志脉冲，扇区计数器加1，把计数器内容与磁盘地址寄存器中的扇区地址进行比较，如果一致则输出扇区符合信号，说明读写的信息已经转入磁头下方。<br><br>(3).读写操作：扇区符合信号送到磁盘控制器后，磁盘控制器的读写控制电路开始动作，如果是写操作，就将数据送到写入电路，写入电路根据记录方式生成相应的写电流脉冲；如果是读操作，则由读出放大电路读出内容送给磁盘控制器。<br></strong></p><hr><p>数据在磁盘上的记录格式分为定长记录格式和不定长记录格式两种，目前大多采用定长记录格式。<br></p><p>最早的硬盘由IBM开发：温切斯特盘（温盘），它采用定长记录格式。<br><br><img src="https://i.imgur.com/aAnzL0v.jpg" srcset="/img/loading.gif" alt><br><br> <strong>每个磁道由若干个扇区（也称扇段）组成，每个扇区记录一个数据块。</strong><br><br>头空（间隙1）占17个字节，全是1，磁盘转过该区域的时间是留给磁盘控制器作准备用的。</p><h2 id="6-3-2-磁盘存储器的性能指标"><a href="#6-3-2-磁盘存储器的性能指标" class="headerlink" title="6.3.2  磁盘存储器的性能指标"></a>6.3.2  磁盘存储器的性能指标</h2><p>(1).记录密度：道密度和位密度。<br><br>位密度：单位长度内存放的二进制信息数目叫做位密度。<br><br>道密度：沿磁道分布方向上单位长度内的磁道数目叫做道密度<br><br><img src="https://i.imgur.com/JcU1fAH.jpg" srcset="/img/loading.gif" alt></p><hr><p>(2).存储容量<br><br>硬盘的未格式化容量：按照道密度和位密度计算出来的容量，包括头空，ID域，CRC码等信息，是所有可利用的所有磁化单元的总数，未格式化容量，比格式化后的实际容量要大。<br></p><p>对于低密度存储方式的<strong>未格式化容量</strong>的计算方法为：<br><br><code>磁盘总容量 = 记录面数 (一个盘有两面) * 理论柱面数 * 内圆周长 * 最内道位密度</code><br><br><code>理论柱面数 =（有效记录去外径-有效记录区内径）/ 2 * 道密度</code><br></p><p><strong>格式化后实际容量只包括数据区(这里假定每个扇区512字节算)</strong><br><code>磁盘实际数据容量= 盘面数 * 磁道数/面 * 扇区数/磁道 * 512B/扇区</code></p><p>(3).数据传输速率 <br><br>数据传输速率：指的是磁表面存储器完成磁头定位和旋转等待以后，单位时间内从存储介质上读出或者写入的二进制信息量。</p><p>(4).平均存取时间 <br><br>通常，磁盘的平均存取时间近似等于平均寻道时间和平均等待时间之和。而且磁盘第一位数据的读写延时非常长，相当于平均存取时间，而以后的二位数据的读写则几乎没有延迟。</p><h2 id="6-3-3-磁盘存储器的连接"><a href="#6-3-3-磁盘存储器的连接" class="headerlink" title="6.3.3 磁盘存储器的连接"></a>6.3.3 磁盘存储器的连接</h2><p>现代计算机中，通常将复杂的磁盘物理扇区抽象成固定大小的逻辑块，物理扇区和逻辑块之间的映射由磁盘控制器来维护。磁盘控制器是一个内置固件的硬件设备，它能将主机送来的请求逻辑块号转化为磁盘的物理地址（柱面号，磁头号，扇区号），并控制磁盘驱动器进行相应的动作。</p><h2 id="6-3-4-固态硬盘-SSD"><a href="#6-3-4-固态硬盘-SSD" class="headerlink" title="6.3.4 固态硬盘(SSD)"></a>6.3.4 固态硬盘(SSD)</h2><p>#6.4 高速缓冲存储器(cache)<br> 由于CPU和主存所使用的半导体工艺不同导致两者在速度上由差距导致速度较快的CPU常常需要等到慢速的主存，为了加快CPU访存的速度，所以在CPU和主存之间增加 cache。（cache的速度与CPU的速度差不多）<br>\</p><h2 id="6-4-1-程序访问的局限性"><a href="#6-4-1-程序访问的局限性" class="headerlink" title="6.4.1 程序访问的局限性"></a>6.4.1 程序访问的局限性</h2><p>程序访问的局限性分为时间局部性和空间局限性。<br><br><strong>时间局部性：指的被访问的某个存储单元在一个较短的时间间隔内很可能又被访问。<br><br>空间局限性：指的是被访问的某个存储单元的临近的一个存储单元在一个较短的时间内很可能被访问。（例如循环访问数组）。<br></strong><br>为了更好的利用程序反问的空间局部性，通常把当前访问单元以及临近的单元作为一个主存块一起调入cache，在CPU和主存之间设置cache，总是把主存中被频繁访问的活跃的程序块和数据块复制到cache中，由于程序访问的局限性，大多情况下，CPU能直接从cache中取得指令和数据，而不必访问慢速的主存。<br></p><h2 id="6-4-2-cache的基本工作原理"><a href="#6-4-2-cache的基本工作原理" class="headerlink" title="6.4.2 cache的基本工作原理"></a>6.4.2 cache的基本工作原理</h2><p>为了便于cache与主存间交换信息，cache和主存空间被划分为相等的区域，例如，将主存按照每512个字节分成一个区域，同时把cache也划成同样大小的区域，这样主存中的信息可以按照512字节为单位送到cache中，我们把主存中的区域称为<strong>块</strong>，也称为<strong>主存块</strong> ，它是cache和主存之间的信息交换单位cache中存放一个主存块的区域叫做<strong>行</strong>或者<strong>槽</strong>。</p><h3 id="1-cache的有效位"><a href="#1-cache的有效位" class="headerlink" title="(1).cache的有效位"></a>(1).cache的有效位</h3><p>为了说明cache行中的信息是否有效，每个cache行都需要一个有效位。<br><br>有了有效位，就可以将有效位清0来淘汰某cache行中的主存；装入一个新主存块时在使有效位为1。<br></p><h3 id="2-CPU在cache中的访问过程"><a href="#2-CPU在cache中的访问过程" class="headerlink" title="(2).CPU在cache中的访问过程"></a>(2).CPU在cache中的访问过程</h3><p><img src="https://i.imgur.com/w5agUbu.png" srcset="/img/loading.gif" alt></p><h3 id="3-cache-—-主存层次的平均访问时间"><a href="#3-cache-—-主存层次的平均访问时间" class="headerlink" title="(3).cache —-主存层次的平均访问时间"></a>(3).cache —-主存层次的平均访问时间</h3><p><strong>cache命中</strong>：若CPU访问单元所在的主存块在cache中，则称为cache命中（hit），命中的概率称为命中率p，它等于命中次数与访问总次数之比。<br><br><strong>cache不命中</strong>：若CPU访问单元所在的主存块不在cache中，则称为cache不命中，其概率称为缺失率（miss rate），它等于不命中次数与访问总次数之比。<br><br><strong>命中时间：</strong>命中时CPU在cache中直接存取所用的时间开销就是cache访问时间T<sub>c</sub>称为命中时间。<br><br>缺失时需要从主存读取一个主存块送cache，并同时将所需信息送到CPU，所用时间时主存访问时间T<sub>m</sub>和cache访问时间T<sub>c</sub>之和。<br><br><strong>缺失损失:</strong>通常把从主存读入一个主存块到cache的时间T<sub>m</sub>缺失损失。<br></p><h2 id="6-4-3-cache行和主存块的映射"><a href="#6-4-3-cache行和主存块的映射" class="headerlink" title="6.4.3 cache行和主存块的映射"></a>6.4.3 cache行和主存块的映射</h2><p>把主存块复制到cache行时，主存块和cache行之间必须遵循一定的映射规则。<br><br><strong>主要分为三种映射规则：直接映射，全相联映射，组相联映射。</strong></p><h3 id="1-直接映射"><a href="#1-直接映射" class="headerlink" title="(1).直接映射"></a>(1).直接映射</h3><p>直接映射的基本思想是：把主存每一块映射到一个固定的cache行中，也称<strong>模映射</strong>，其映射关系如下：<br><br><code>cache行号 = 主存块号 mod cache行数</code><br></p><p>直接映射方式下：主存地址被分为标记，cache行号，块内地址三个字段。<br><br><img src="https://i.imgur.com/L37b3uQ.jpg" srcset="/img/loading.gif" alt><br><br>举例：假定共有2<sup>c</sup>行，主存共有2<sup>m</sup>块，主存块大小占2<sup>b</sup>字节，则按照字节编址，则上图中cache行号占c位，主存块号占m位，块内地址有b位，<strong>因为主存块号分解成标记字段和cache行号字段</strong>，因而标记字段占t=m-c位。<br></p><p><strong>直接映射的CPU访存过程：</strong><br><br><img src="https://i.imgur.com/1PTb7VT.png" srcset="/img/loading.gif" alt><br><br><strong>首先根据CPU给出的主存地址中的cache行号（如图cache字块地址）选择cache中对应的cache行，将行中的标记和CPU给出的主存地址中高t位进行比较，若相等而且有效位为1，则命中，此时根据CPU给出的主存地址低b位块内地址，在对应的cache行中存取信息。若不想等或者有效位为0，则cache 缺失，此时CPU从主存中读出该主存地址所在一块信息通过系统总线送到对应的cache行中，将有效位置1，并将标记设置为该地址的高t位，同时将该地址中的内容送CPU。</strong></p><p>直接映射的优缺点：<br><br><strong>优点</strong>：容易实现，命中时间短。<br><br><strong>缺点</strong>：cache行得不到充分利用，命中率比较低。<br></p><h3 id="2-全相联映射"><a href="#2-全相联映射" class="headerlink" title="(2).全相联映射"></a>(2).全相联映射</h3><p>全相联映射的基本思想是一个主存块可装入cache任意行中。<br><br>全相联映射cache中，每行的标记用于指出该行取自主存的哪个块，因为一个主存块可能出现在任意一个cache行中，所以需要比较所以cache行的标记，<strong>因此 主存地址中不需要cache行索引。</strong>，只有标记和块内地址两个字段。<br>所以全相联映射方式下，只要有空闲的cache行，就不会发生冲突，因而块冲突概率低。<br><br><img src="https://i.imgur.com/b2G6pQF.jpg" srcset="/img/loading.gif" alt><br></p><p>全相联映射优缺点：<br><br>优点是：块冲突率低。<br><br>缺点是：为了加快比较速度，通常每个cache行都设置一个比较器，比较器的位数等于标记字段的位数。全关联cache访存是根据标记字段的内容来访问cache行中的主存块，它查找主存块是”按内容访问”所以全关联映射的时间开销和所用元件都较大，实现起来困难。</p><h3 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="(3).组相联映射"></a>(3).组相联映射</h3><p>组相联映射的主要思想是：将cache分为大小相等的组，每个主存块被映射到固定组中的任意一行，也即采用<strong>组间模映射，组内全映射</strong>的方法。<br><br>映射关系如下：<br><br><code>cache组号 = 主存块号 mod cache组数</code><br></p><p>组相联方式下，主存地址被分为 标记 ，cache组号 ， 块内地址三个字段。<br><img src="https://i.imgur.com/36n3gxi.jpg" srcset="/img/loading.gif" alt><br><br> 假定cache共有2<sup>c</sup>行，被分为2<sup>q</sup>组，每组有2<sup>c</sup>/2<sup>q</sup>=2<sup>c-q</sup>行设s=c-q，则cache映射方向称为2<sup>s</sup>路组相联映射<strong>（即每组有多少行相联映射）</strong>。</p><p><strong>2路组相联映射的访存过程：<br><br>根据主存地址中的cache组号找到对应组—–&gt;找到对应组后就是“按内容访问”全关联模式了，根据主存地址中的标记字段与对应组中每一行的标记tag进行比较。——–&gt;若相等而且有效位为1则命中，执行相关操作，若不相等或者有效位为0，则不命中，也执行相应操作。</strong></p><h2 id="6-4-4-cache中主存块的替换算法"><a href="#6-4-4-cache中主存块的替换算法" class="headerlink" title="6.4.4 cache中主存块的替换算法"></a>6.4.4 cache中主存块的替换算法</h2><ol><li>FIFO算法(先进先出算法）</li><li>LRU算法（最近最少用算法）</li><li>LFU算法（最不经常用算法）</li><li>随机替换算法</li></ol><h2 id="6-4-5-cache的一致性问题"><a href="#6-4-5-cache的一致性问题" class="headerlink" title="6.4.5 cache的一致性问题"></a>6.4.5 cache的一致性问题</h2><ol><li>全写法</li><li>回写法(一般用回写法)</li></ol><h2 id="6-4-6-影响cache性能的因数"><a href="#6-4-6-影响cache性能的因数" class="headerlink" title="6.4.6 影响cache性能的因数"></a>6.4.6 影响cache性能的因数</h2><p><strong>&lt;1&gt;.</strong>决定系统访存性能的重要因数之一是cache 命中率，它与许多元素有关。</p><ol><li>命中率与关联度有关，关联度越高，命中率越高，关联度反映一个主存块对应的cache行的个数（直接映射的关联度为1，2路组相联映射的关联度为2，4路组相联映射的关联度为4；全关联映射为cache和行数。）</li><li>命中率与cache容量有关，显然cache容量越大，命中率就越高。</li><li>命中率与主存块的大小有关，采用大单位的主存块就能很好的利用空间的局部性，但是较大的主存块需要比较多的时间来存取，因此缺失损失会变大，由此可见，主存块大小必须适中，不能太大也不能太小。<br>&lt;2&gt;. 单级/多级cache，联合/分离cache的选择问题。<br></li></ol><p>&lt;3&gt;. 主存-总线-cache间的连接结构问题。<br>主存，总线和cache之间可以有三种连接方式：<br></p><ol><li>窄型结构:即在主存，总线和cache之间每次按一个字的宽度来进行传送。<br></li><li>宽型结构：即在它们之间每次传输多个字。<br></li><li>交叉存储结构:即在主存采用多模块交叉存取方式，在主存，总线和cache之间每次按照一个字的宽度来进行传送,例如：传输一个4字，第一个模块准备好第一个字，然后在总线上传输一个字，同时第二个模块已经准备好第二个字了，然后再总线上传输第二个字的时候，第三个模块已经准备好第三个字了，以此类推）。</li></ol><h1 id="6-5-虚拟存储器"><a href="#6-5-虚拟存储器" class="headerlink" title="6.5 虚拟存储器"></a>6.5 虚拟存储器</h1><h2 id="6-5-1虚拟存储器的基本概念"><a href="#6-5-1虚拟存储器的基本概念" class="headerlink" title="6.5.1虚拟存储器的基本概念"></a>6.5.1虚拟存储器的基本概念</h2><p>在采用虚拟存储技术的计算机中，指令执行时，通过存储器管理部件（MMU）将指令中的逻辑地址（虚拟地址 VA）转化为主存的物理地址（主存地址或实地址 PA）。在地址转换的过程中由硬件检查是否发生了访问信息不在主存或者地址越界或者访问越权，若发现信息不在主存，则由操作系统将数据从硬盘读到主存。若发生地址越界或访问越权，则由操作系统进行相应的因此处理。由此看出，虚拟技术即解决了编程空间受限的问题，又解决了多到程序共享主存带来的安全问题。<strong>{这里忽略cache，因为主存的空间是一定的所以如果没有虚拟存储技术的话，程序受到物理内存大小的限制，而且无法让多道程序共享主存，有了虚拟存储技术，就可以把主存看作一个比较大的cache}<br></strong></p><h2 id="6-5-2-虚拟地址空间"><a href="#6-5-2-虚拟地址空间" class="headerlink" title="6.5.2 虚拟地址空间"></a>6.5.2 虚拟地址空间</h2><p>每个高级语言源程序经过编译，汇编，链接等处理后都会生成可执行的二进制机器目标代码时，都被映射到一个统一的虚拟地址空间。所谓“统一”是指不同的可执行文件所映射的虚拟地址空间大小一样，地址空间中的区域划分结构也相同。<strong>（虚拟地址空间不是真实存在的，只是人们创造出来好理解CPU的寻址的，自己理解，有错请纠正）</strong></p><p><img src="https://i.imgur.com/JAGtXPH.jpg" srcset="/img/loading.gif" alt></p><h2 id="6-5-3-虚拟存储器的实现"><a href="#6-5-3-虚拟存储器的实现" class="headerlink" title="6.5.3 虚拟存储器的实现"></a>6.5.3 虚拟存储器的实现</h2><h3 id="1-分页式虚拟存储器"><a href="#1-分页式虚拟存储器" class="headerlink" title="1.分页式虚拟存储器"></a>1.分页式虚拟存储器</h3><p>分页式虚拟存储系统中，虚拟地址空间被划分为大小相等的页面，硬盘和主存之间按页面为单位交换信息。虚拟地址空间中的页称为虚拟页，逻辑页或虚页（简称VP）；主存空间也被划分为同样大小的页宽（物理页，实页，PF或者PP)。<br></p><ol><li>未分配页: 虚拟空间中没有和任何内容相关联的页称为“未分配页”。（堆区和栈区）<br></li><li>已分配页：虚拟空间中对于代码和数据等有内容的区域所关联的页面。（已分配页又分为缓存页和未缓存页)<br></li><li>缓存页和未缓存页:已调入主存而被缓存在DRAM中的页面称为缓存页，未调入主存而存在硬盘中的页称为未缓存页。<br><blockquote><p><strong>主存和cache之间交换单位为主存块，硬盘和主存之间交换的单位为页面。</strong><br><br>由于硬盘和主存之间交换数据太慢，所以缺页的代价特别大。所以考虑到缺页代价的问题，通常将主存和硬盘交换的页设置的比较大。<br><br>因为缺页的的代价比较大，所以主存页框和虚拟页之间采用全映射的方式，处理一致性的问题用回写法。<br></p></blockquote></li></ol><p>与cache必须使用一种方法来建立各个虚拟页和所存放的主存页框号或磁盘上的存储位置之间的关系，通常用<strong>页表</strong>来描述这种对应关系。<br></p><p>(1).页表(进程页表和内核页表）</p><p>进程页表和内核页表区别可以看这篇博客<a href="https://blog.csdn.net/yyf_it/article/details/52460359" target="_blank" rel="noopener">https://blog.csdn.net/yyf_it/article/details/52460359</a><br></p><p><img src="https://i.imgur.com/OjOz1Ch.png" srcset="/img/loading.gif" alt><br></p><p><strong>系统中每个进程都有一个页表，操作系统在加载程序时，根据可执行文件中的程序头表，确定每个可分配段（如只读代码段，可读可写数据段）所在的虚页号及磁盘中存放的位置，在主存中生成一个初始页表，初始页表中的每个页表项对应装入位都是0，在程序执行过程中，通过缺页异常处理程序，将磁盘上的代码和数据页面装入分配的主存页框中，并修改页表中相应页表项，例如，将存放位置改为主存页框号，将页表项中装入位置1.(—-&gt;这里指的是进程页表)</strong></p><p>(2).地址转换<br><br>采用虚存机制的系统，指令给出的地址时虚拟地址，CPU执行指令时，首先要将虚拟地址转化成主存的物理地址，才能到主存中取指令和数据，地址转化又MMU来完成.<br></p><p><img src="https://i.imgur.com/FZ6Uorq.png" srcset="/img/loading.gif" alt></p><p>(3). 快表<br><br>采用虚拟内存后，访存的次数增多了，为了减少访存次数，所以往往把页表中最活跃的几个页表复制到高速缓存中，这种高速缓存中的页表项组成的页表称为<strong>后备转化缓存器（TLB）</strong>，通常<strong>快表</strong>。相应的主存中的页表称为 <strong>慢表</strong>。<br><br>TLB的概述:<br><br>TLB是一个内存管理单元用于改进虚拟地址到物理地址转换速度的缓存.<br><br>TLB是位于内存中的页表的cache，如果没有TLB，则每次取数据都需要两次访问内存,即查页表获得物理地址和取数据.<br><br><img src="https://i.imgur.com/5bB23Rs.png" srcset="/img/loading.gif" alt><br><br><strong>上图中访存过程解释:CPU给出一个32位的虚拟地址，首先，由CPU中的MMU进行虚拟地址到物理地址的转换；然后，由处理cache的硬件根据物理地址进行存储访问。<br><br>MMU对TLB查表时，20位虚拟页号被分为标记Tag和组索引两部分，首先由组索引确定到TLB中的那一组进行查找，查找时将虚拟页号的标记部分和TLB中该组每个标记字段同时进行比较。若由某个相等而且有效位为1，则TLB命中，此时可以通过TLB进行地址转化；否则TLB缺失，此时就需要去访问主存去查慢表。图中所示的是两级页表方式，虚拟地址被分为页目录索引和页表索引两部分，根据这两部分可得到对应的页表项，从而进行地址转化，并将对应页表项的内容送入TLB形成一个新的TLB表项，同时，将虚拟页号的高位分作为TLB标记填入新的TLB表项中，若TLB已满，还需要进行TLB替换，TLB采用随机替换策略。</strong></p><p>(4). CPU访存过程<br><br><img src="https://i.imgur.com/D6Enyiw.png" srcset="/img/loading.gif" alt></p><h3 id="2-分段式虚拟存储器"><a href="#2-分段式虚拟存储器" class="headerlink" title="2.分段式虚拟存储器"></a>2.分段式虚拟存储器</h3><p>可以把段作为基本的信息单位在主存-辅存之间传送和定位，分段方式下，将主存空间按实际程序中的段来划分，每个段在主存中的位置记录在段表中，段的长度可以变化，所以段表中需有长度指示，即段长。每个进程都有一个段表，每个段在段表中有个段表项，可以用来指明对应段在主存中的位置，段长，访问权限，使用和装入情况，段表本身映射一个可定位段，可以存在外存中，需要时调入主存，但一般驻留在主存。<br></p><p>优点：段的分界与程序的自然分界相对应，易于编译，管理，修改和保护。<br><br>缺点：段的起点和终点不定，给主存空间分配带来麻烦，而且容易在主存中留下许多空白的零碎空间，造成浪费。<br><br><img src="https://i.imgur.com/wiXjxF0.png" srcset="/img/loading.gif" alt></p><h3 id="3-段页式虚拟存储器（IA-32-Linux就是采用段页式）"><a href="#3-段页式虚拟存储器（IA-32-Linux就是采用段页式）" class="headerlink" title="3. 段页式虚拟存储器（IA-32+Linux就是采用段页式）"></a>3. 段页式虚拟存储器（IA-32+Linux就是采用段页式）</h3><p>在段页式虚拟存储器中，程序按模块分段，段内在分页，用段表和页表（每个段一个页表)进行两级定位管理。段表中每个表项对应一个段，每个段表项中包含一个指向该段页表起始位置的指针，以及该段其他的控制和存储包含信息，有页表指明该段各页在主存中的位置以及是否装入，修改等状态信息。</p><h2 id="6-5-4-存储保护"><a href="#6-5-4-存储保护" class="headerlink" title="6.5.4 存储保护"></a>6.5.4 存储保护</h2><p>目的：为了避免主存中多道程序互相干扰，防止某进程出错而破坏其他进程的正确性，或某进程不合法地访问其他进程的代码或者数据区，应该对每个进程进行存储保护。<br><br><strong>条件：为了对操作系统的存储保护提供支持，硬件必须具有以下三种基本功能:</strong><br></p><ol><li>使部分CPU状态只能由操作系统内核程序写，而用户进程只能读不能写。（例如：TLB内容，页表首地址等，只能操作系统内核程序才能用特殊的指令来写）<br></li><li>支持至少两种特权模式。(用户态，内核态)<br></li><li>提供让CPU在内核态和用户态之间相互转化的机制。（如果用户进程需要访问内核代码和数据，那么必须通过系统调用接口（执行陷阱指令）来间接访问，响应异常和中断可使CPU从用户态转到内核态，异常和中断处理后返回指令可以使CPU从内核态转到用户态。<br></li></ol><p>存储保护包括以下两种情况：访问权限保护和存储器区域保护。</p><ol><li>访问权限保护</li><li>存储区域保护（加界重定位，键保护，环保护）<br>加界重定位：每个程序和程序段都有起始和终止地址，不可以越界，在分段式虚存中，通过段表来记录段的上界和下届。<br><br>键保护：操作系统给主存中的每一个页框分配一个存储键，给每个用户程序设置一个程序键。进程运行时，将程序状态字寄存器中的键（程序键）和所访问的页的键（存储键）进行核对相符才可以访问。（相当于锁和钥匙的关系）。<br><br>环保护;主存中各进程按其重要性分为多个保护级，各个级别构成同心环，最内环的进程保护级别最高，向外逐次降低。<br></li></ol><h2 id="6-6-IA-32-Linux中的地址转换"><a href="#6-6-IA-32-Linux中的地址转换" class="headerlink" title="6.6 IA-32+Linux中的地址转换"></a>6.6 IA-32+Linux中的地址转换</h2><p>在保护模式下，IA-32采用段页式虚拟存储管理方式，存储空间采用逻辑地址，线性地址，物理地址来进行描述。逻辑地址就是虚拟地址，IA-32中的逻辑地址由48位组成，包括16位段选择符和32位段内偏移量（即有效地址），为了便于多用户，多任务下的存储管理，IA-32采用分段基础上的分页机制。分段过程实现逻辑地址转换为线性地址，分页过程再实现将线性地址转换为物理地址。<br></p><h3 id="6-6-1逻辑地址到线性地址的转换"><a href="#6-6-1逻辑地址到线性地址的转换" class="headerlink" title="6.6.1逻辑地址到线性地址的转换"></a>6.6.1逻辑地址到线性地址的转换</h3><p>1.段选择符和段寄存器<br><br>TI表示段选择符要选择哪一个段描述符表，TI=0选全局描述符表（GDT），TI=1选局部描述符表（LDT）。<br><br>RPL用来定义段选择符的特权等级RPL=00 表示第0级，是最高级的内核态，若RPL=11，则为第3级是最低级的用户态。<br><br><img src="https://i.imgur.com/nJ5XZzb.png" srcset="/img/loading.gif" alt></p><p>段寄存器：<br><br>CS：代码段寄存器<br><br>SS:   栈段寄存器<br><br>DS：数据段寄存器<br><br>ES，FS，GS：可以指向任意段寄存器。<br></p><p>2.段描述符<br></p><p><img src="https://i.imgur.com/WbAh8dm.png" srcset="/img/loading.gif" alt><br><br>特权位和访问权限的含义说明如下：<br><br>G:表示粒度大小，G=1说明段以页（4KB）为基本单位；G=0则段以字节为基本单位。由于界限为20位，所以G=0时，最大的段位2<sup>20</sup> X 1B = 1MB;当G = 1时最大的段位2<sup>20</sup> X 4KB=4GB。<br><br>D: D=1表示地址和数据位32位宽，D=0表示地址和数据为16位宽。<br><br>P: 说明段是否存在主存中。P=1表示存在，P=0表示不存在。Linux总是把P置成1，因为它从来不会把一个段交换到磁盘上而是以页为单位进行交换。<br><br>DPL：访问段时对当前特权级的最低等级要求，只有CPL=0（内核态)时才能访问DPL=0的段，任何进程（CPL=3或者0) 都可以访问DPL=3的段。<br><br>S: S=0表示是系统控制段描述符，S=1表示是普通代码段或者数据段描述段。<br><br>TYPE： 指示段的访问权限或者系统控制段描述符的类型。<br><br>A：说明段是否被访问过。A=1代表段被访问过，A=0代表没有被访问过。<br><br>AVL：可以由操作系统定义使用。Linux忽略这个字段。<br></p><p>3.段描述符表<br><br>段描述符表就是分段方式下的段表，由段描述符组成，主要有三个类型：全局描述符表（GDT），段描述符表（LDT）和中断描述符表（IDT）。</p><p>4.用户不可见寄存器<br><br>除了六个段寄存器以外，还提供了多个用户进程不可以直接访问的内部寄存器，它们包括描述符cache，任务寄存器（TR），局部描述符表寄存器（LDTR），全局描述表寄存器（GDTR）和中断描述符寄存器（IDTR）。操作系统通过特权指令可对寄存器TR，LDTR，GDTR，IDTR进行读写。<br></p><p><img src="https://i.imgur.com/iIjOFER.jpg" srcset="/img/loading.gif" alt><br>描述符cache：其作用如上图描述。<br><br>全局描述符表寄存器（GDTR）：高32位存放GDT首地址，低16位存放界限。<br><br>中断描述符表寄存器（IDTR）：高32位存放IDT首地址，低16位存放界限<br><br><strong>局部描述符表寄存器（LDTR）（LDTR有点不同）：是16位寄存器，存放局部描述符表LDT的段选择符，通过该选择符可把GDT中的LDT描述符表中的部分信息（包括LDT首地址，LDT界限和访问权限）装入LDT描述符cache中从而使CPU可以快速访问LDT</strong><br><br>任务寄存器（TR）也是16位，用来存放任务状态段（TSS）的段选择符，通过该段选择符可把GDT表中的TSS描述符中部分信息（包括TSS首地址，TSS界限和访问权限等），装入TSS描述符cache中，从而可以方便的对任(即用户进程）的状态信息进行访问。<br></p><p>5.逻辑地址向线性地址的转换<br><br><strong>访问LDT表的过程<br></strong><br><img src="https://i.imgur.com/zbAkDhE.jpg" srcset="/img/loading.gif" alt><br><br><strong>访问GDT表的过程<br></strong><br><img src="https://i.imgur.com/F1oceHG.jpg" srcset="/img/loading.gif" alt><br></p><p><strong>注意：Linux中用户态和内核态的每个段的线性地址都是从基地址0开始，都是以4KB为粒度（G=1),所以所有逻辑地址中的段内偏移量（即有效地址）就是其线性地址。</strong></p><h3 id="6-6-2-线性地址到物理地址的转换"><a href="#6-6-2-线性地址到物理地址的转换" class="headerlink" title="6.6.2 线性地址到物理地址的转换"></a>6.6.2 线性地址到物理地址的转换</h3><p>IA-32采用段页式虚拟存储管理方式，通过分段方式完成逻辑地址到线性地址的转换后，再进行一步<strong>通过分页方式将线性地址转化为物理地址</strong>。<br></p><p>先介绍IA-32中的控制寄存器：<br><br>1.控制寄存器<br><br>CR0：CR0控制寄存器定义了多个控制位：<br></p><blockquote><p>1.保护模式允许位PE:PE=0(实地址模式），PE=1（保护地址模式）。<br><br>2.分页允许位PG: PG=1启用分页部件工作，PG=0则禁止分页部件工作，此时线性地址被直接作为物理地址使用。<br><br>3.任务切换位TS:每次任务切换时将其置1，任务切换完毕则清0。<br><br>4.对齐屏蔽位AM:它可以与EFLAGS中的AC位配合使用，若AM=1且AC=1，则进行对齐检查，若AM=0，则禁止对齐检查。<br><br>5.cache功能控制位NW和CD，只有NW和CD均为0时，cache才能工作。<br></p></blockquote><p>CR2是页故障线性地址寄存器，存放引起页故障（即缺页）的线性地址。只有CR0中的PG=1时,CR2才有效。<br><br>CR3是页目录基址寄存器，用来保存页目录再内存的起始地址，只有CR0中的PG=1时，CR3才有效。<br></p><p>2.线性地址向物理地址的转换<br><br><img src="https://i.imgur.com/4uRy7dZ.jpg" srcset="/img/loading.gif" alt><br><br>上述转换过程中10位的页目录索引（Directory）和页表索引（Table）都要乘以4，因为每个页目录项和页表项都是32位（4B),占4个字节。<br><br><img src="https://i.imgur.com/Ws6ibdj.png" srcset="/img/loading.gif" alt><br></p><blockquote><p>P: P=1表示页表或者页在主存中，P=0表示不再主存中，此时页故障（缺页异常），需要将页故障线性地址记录在CR2中，操作系统在处理页故障时会将缺失的页表或页从硬盘装入主存中，并重新执行页故障的指令。<br><br>R/W:该位为0时表示页表或者页只能读不能写，为1时表示可读可写。<br><br>U/S：该为为0时表示用户进程不能访问，为1时允许用户进程访问，该位可以保护操作系统所使用的页不受用户进程的破坏。<br><br>PWT: 用来控制页表对应的cache写策略时全写还是回写。<br><br>PCD：用来控制页表或者页能否被缓存到cache中。<br><br>A: A=1表示页或者页表被访问过，初始化时操作系统将其清0，利用该标志，操作系统可以清楚的了解哪些页表或者页正在使用，一般选择长期未用的页或者最少使用的页调出主存。<br><br>D :脏位或者叫修改位，该位在页目录项中没有意义，在页表项中有意义，D=1表示该页被修改过，D=0表示没有被修改过，修改过的页，操作系统在把该页清理出主存时会把它回写到硬盘中。<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础-袁春风</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符号表和符号解析</title>
    <link href="undefined2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/"/>
    <url>2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h1><p>链接器在生成一个可执行文件时，必须完成符号解析，而要进行符号解析就必须要使用符号表。<br></p><p>符号类型：全局符号，外部符号，本地符号。<br><br>以模块m为例：包括在符号表中的符号有以下三种不同类型<br><br>全局符号：在模块m中定义并被其他模块引用的符号，这类符号包括：非静态的函数名和定义为不带static属性的全局变量名。<br><br>外部符号：在其他模块定义并被m引用的符号，包括在其他模块定义的外部函数名和外部变量名。<br><br>本地符号：在模块m中定义并在m中引用的本地符号，这类符号包括带static属性的函数名和全局变量名。<br></p><p><strong>注意：上述三类符号不包括分配在栈中的非静态局部变量（auto变量），链接器不需要这一类变量的信息，因而他们不在节.symtab定义的符号表中。（指的是符号表中的符号在.data和.bss中的符号，和栈中的符号没关系）</strong><br></p><p>符号表里面装了：<br>1.符号在字符串表中的索引（st_name）<br><br>2.符号的值（st_value)在可重定位文件中，是指符号所在位置相对于所在节起始位置的字节偏移量。在可执行目标文件和共享文件中，st_value则是符号所在的虚拟地址。<br><br>3.符号的类型（st_info)指出符号的类型和绑定属性，如未指定的（NOTYPE），变量（OBJECT），函数（FUNC），节（SECTION)等。<br></p><h1 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h1><p>符号解析的目的是将每个模块中引用的符号与某个目标模块中的定义符号建立关联。每个定义符号在代码段或数据段都被分配了存储空间，因此，将引用符号与对应的定义符号建立关联后，就可以在重定位时将引用符号的地址重定位为定义符号的地址。<br></p><p>编译器的对源程序编译时，会把每个全局符号输出在汇编代码文件中，每个全局符号或者是强符号或者弱符号。编译器把全局符号的强弱特性，隐含地编码在可重定位目标文件的符号表中，以供链接时符号解析所用。<br></p><h2 id="全局符号的强，弱特性"><a href="#全局符号的强，弱特性" class="headerlink" title="全局符号的强，弱特性"></a>全局符号的强，弱特性</h2><p><strong>强符号：函数名或者已初始化的全局变量名是强符号，未初始化的全局变量是弱符号，本地符号没有强弱之分。</strong><br></p><p>1.强符号不能多次定义，也就是强符号只能被定义一次，否者链接错误。<br><br>2.若一个符号被说明为一次强符号定义和多次弱符号定义，则按照强符号定义为准。<br><br>3.若有多个弱符号定义，则任选其中一个。<br></p><h2 id="符号解析过程"><a href="#符号解析过程" class="headerlink" title="符号解析过程"></a>符号解析过程</h2><p>链接器按照所有可重定位目标文件和静态库文件出现在命令行中的顺序从做到右依次扫描他们，在此期间要维护多个集合。<br><br>集合E：是将被合并在一起组成可执行文件的所有目标文件的集合。<br><br>集合U：是为解析符号的集合。<br><br>集合D：是指当前为止已被加入到E的所有目标文件中定义符号的集合。<br></p><p>符号解析开始时三个集合都是空集：然后对命令行输入一个文件f<br><br>如果f是目标文件就把f加入E，在根据f文件中未解析的符号和定义符号分别对U,D进行修改。<br><br>如果f文件是库文件，链接器就会尝试把U中未解析的符号和f中各个模块的符号进行匹配。如果f中的某个目标模块定义了一个U中的一个或者多个符号就把这个模块加入E，被定义的符号加入D，若没有定义则抛弃。<br><br>如果处理过程中出现双重定义就是一个符号在D中出现两次，或者扫描完成了U中还有未定义符号（U非空的话），链接器报错。<br></p><p>静态链接时，命令时从左到右读，而且库文件的顺序要按照引用关系来写。<br><br>命令：gcc - static -o xxxxx main.o ./libc.a （libc.a也可以不写，链接器会自动在最后加上去）<br></p><img src="/2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5.jpg" srcset="/img/loading.gif" class title="可重定位目标文件与静态库的链接">]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标文件格式</title>
    <link href="undefined2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="ELF目标文件格式"><a href="#ELF目标文件格式" class="headerlink" title="ELF目标文件格式"></a>ELF目标文件格式<br></h1><p>目标文件格式有很多种，例如：System V UNIX 的COFF，window 的PE，Linux 的ELF。<br></p><h1 id="链接视图"><a href="#链接视图" class="headerlink" title="链接视图"></a>链接视图</h1><h3 id="可重定位目标文件格式"><a href="#可重定位目标文件格式" class="headerlink" title="可重定位目标文件格式"></a>可重定位目标文件格式</h3> <img src="/2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20180708185336199.png" srcset="/img/loading.gif" class title="ELF可重定位目标文件"><br><p><strong>(1).ELF头</strong><br><br>ELF头位于目标文件的起始位置，包括文件结构说明信息。ELF头的数据结构分为32位系统对于结构和64位系统对应结构。(可以使用readelf -h 命令对某个可重定位目标文件的ELF头进行解析。例如：对main.o头文件进行解析：readelf -h main.o）<br><br><strong>(2).节</strong><br><br>节是ELF文件的主体信息，包含了链接过程所用的目标代码信息，包括指令，数据，符号表和重定位信息等。<br><br>.text :目标代码部分<br><br>.rodata:只读数据节<br><br>.data:已初始化全局变量<br><br>.bss:未初始化的全局变量（不占据实际的磁盘空间）<br><br>.symtab：符号表，程序中定义的函数名和全局静态变量名都属于符号，与这些符号相关的信息也保存在符号表中。<br><br>.rel.text: .text节相关的可重定位信息。当链接器将某一个目标文件和其他目标文件组合时，.text节中的代码被合并后，一些指令中引用的操作地址信息或跳转目标指令的位置信息等都可以能被修改，通常，调用外部函数或引用全局变量的指令中的地址字段需要修改。<br><br>.rel.data:.data节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时, .data节中的代码被合并后，一些全局静态变量的地址可能被修改。<br><br>.debug:调试用符号表，有些表项对定义的局部变量和定义的类型进行说明，有些表项对定义和引用的全局静态变量进行说明。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.line：C源程序中的行号和.text节中机器指令之间的映射。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.strlab:字符串表，包括.symtab节和.debug节中的符号以及节头表中的节名。字符串表就是以null结尾的字符串序列。<br><br><strong>(3).节头表</strong><br><br>节头表由若干个表项组成，每个表现描述相应的一个节的节名，在文件中的偏移，大小，访问属性，对齐方式等。</p><h2 id="执行视图"><a href="#执行视图" class="headerlink" title="执行视图"></a>执行视图</h2><img src="/2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/fSqCY0UBZnX35qDCxjx67h98ps8JduKzOqgUQBtL.png" srcset="/img/loading.gif" class title="ELF可执行目标文件"><br><p>与ELF可重定位文件不同的是：<br><br><strong>1.</strong>ELF头文件中的字段e_entry给出了系统将控制权转移到虚拟地址（入口点），即执行程序时第一条指令的地址而可重定位文件中，此字段为0。<br><br><strong>2.</strong>多了一个.init节，其中.init节定义了一个_init函数用来可执行目标文件开始执行时的初始化工作，当程序开始时，系统进入主函数之前先执行这个节中的指令代码。<br><br><strong>3.</strong>去掉了用去重定位的节.rel.text和.rel.data（因为已经重定位完毕了）。<br><br><strong>4.</strong>多了一个程序头表：也叫做段头表，是一个结构数组。<br></p><h2 id="可执行文件的存储器映像"><a href="#可执行文件的存储器映像" class="headerlink" title="可执行文件的存储器映像"></a>可执行文件的存储器映像</h2><img src="/2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20170621205440745.png" srcset="/img/loading.gif" class title="可执行文件的存储器映像"><br><p>当启动一个一个可执行目标文件时，首先会通过某种方式调出常驻内存的一个称为加载器（loader)的操作系统程序来进行处理，例如，任何的Unix程序的加载执行都是通过调用execve目标文件中相关节的内容与虚拟地址空间中的只读代码段和可读写代码段通过页表建立映射，然后启动可执行目标文件中的第一条指令执行。（这里关系到页表的内容在6.5节还没学到)</p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第4章—程序的链接</title>
    <link href="undefined2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/"/>
    <url>2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-程序的链接-小结《课本214页》"><a href="#第4章-程序的链接-小结《课本214页》" class="headerlink" title="第4章 程序的链接-小结《课本214页》"></a>第4章 程序的链接-小结《课本214页》</h1><p><strong>1.</strong>链接器位于编译器，指令集体系结构和操作系统的交叉点上，涉及指令系统，代码生成，机器语言，程序转换和虚拟存储管理等诸多概念。<br><br><strong>2.</strong>链接处理涉及三种目标文件格式：可重定位目标文件，可执行目标文件和共享库目标文件。<br><br><strong>3.</strong>共享库文件是一中特殊的可定位目标文件。<br><br><strong>4.</strong>ELF目标文件格式有链接视图和执行视图两种，前者是可重定位目标格式，后者是可执行目标格式。<br><br>链接视图包括：ELF头，各种节，节头表。<br><br>执行视图包括：ELF头，程序头表，各种节组成的段。<br><br><strong>5.</strong>链接包括两种链接形式：一是：静态链接，二是：动态链接。<br><br>静态链接：就是将多个可重定位文件中的相同类型的节合并起来以生成完全链接的可执行目标文件，它的所有符号引用都是确定的虚拟地址空间中的最终地址，因而可以直接被加载执行。<br><br>动态链接：动态链接模式下的可执行目标文件是部分链接的，还有一部分的引用地址没有确定，需要利用共享库中的定义符号进行重定位，因而需要由动态链接器来加载共享库并重定位可执行文件中部分文件的引用。<br><br>动态链接又有两种形式分别是：一种是可执行目标文件加载时进行共享库的动态链接；另一种时可执行目标文件执行时进行共享库的动态链接。<br><br><strong>6.</strong>在不同模块可能会定义相同的符号 <strong>（这里说的符号指的是被写入.data节.bss节中的符号，不包括执行时栈中的符号）</strong>，因为相同的多个符号只能分配一个地址，所以链接器以哪个符号为准？编译器通过对定义符号标识是强符号还是弱符号，由链接器根据一套规则来确定多重定义符号中哪个为唯一的定义符号。<br><br><strong>7.</strong>加载器在加载可执行目标文件时，实际上只是把可执行目标文件中的只读代码段和可读写数据段通过页表映射到了虚拟地址空间中的确定位置，并没有真正的把代码和数据从磁盘装入主存。<br></p><h1 id="过程梳理："><a href="#过程梳理：" class="headerlink" title="过程梳理："></a>过程梳理：</h1><p><strong>预处理–&gt;编译–&gt;汇编–&gt;链接</strong><br></p><h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="(1.)预处理"></a>(1.)预处理</h2><p>对预处理文件命令进行处理，包括对头文件的包含，对宏的扩展，条件编译的选择等，例如：#include&lt;xxxx.h&gt;把xxxx.h文件的内容插入源程序文件中。<br><br>gcc命令：“gcc - E main.c -o main.i”和“ cpp main.c -o main.i”<br></p><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="(2.)编译"></a>(2.)编译</h2><p>编译器把代码进行优化（也可以不进行优化）和存储分配，最终把C语言源程序翻译成汇编语言程序。<br><br>gcc命令：“gcc -S main.i -o main .s”和 “ccl main.i -o main.s”<br></p><h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="(3.)汇编"></a>(3.)汇编</h2><p>把汇编语言代码转化为机器语言代码生成可重定位目标文件(.o文件）。<br><br>gcc命令：“gcc -c main.s -o main.o” 和 “as main.s -o main.o”<br></p><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="(4.)链接"></a>(4.)链接</h2><p>将所以有关联的可重定位目标文件组合起来，以生成一个可执行文件。（好处：模块化，效率高）<br></p><p>链接包括两步：<br></p><h3 id="1-符号解析"><a href="#1-符号解析" class="headerlink" title="1.符号解析"></a>1.符号解析</h3><p>将每一个符号引用与一个确定的符号定义建立关联。<br><br>符号包括:全局静态变量名和函数名，而非静态局部变量名则不是符号。编译器将所有的符号存放在可重定位目标文件的符号表中。<br></p><h3 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2.重定位"></a>2.重定位</h3><p>可重定位目标文件中的代码区和数据区都是从地址0开始的，链接器需要将不同模块中相同的节合并起来生成一个新的单独的节，并将合并后的代码区和数据区按照ABI规范确定虚拟地址空间划分（也称存储器映像）来重新确定位置。<br><br>例如，对于32位Linux系统存储器映像，其只读代码总是从地址0x8048000开始，而可读可写数据段总是在代码段后面（从下到上）第一个4KB对齐的地址处开始，因而链接器余姚重新确定每条指令的每个数据的地址，并且在指令中需要明确给定的引用符号的地址，这种重新定义代码和数据地址并更新指令中引用地址符号的地址的工作叫做重定位。<br></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC内嵌汇编中常见的constraint</title>
    <link href="undefined2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/"/>
    <url>2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/</url>
    
    <content type="html"><![CDATA[<p>1.”a”代表AL/AX/EAX/RAX寄存器<br><br>2.”b”代表BL/BX/EBX/RBX寄存器<br><br>3.”c”代表CL/CX/ECX/RCX寄存器<br><br>4.”d”代表DL/DX/EDX/RDX寄存器<br><br>5”D”代表DI寄存器<br><br>6.”S”代表SI寄存器<br><br>7.”m”代表内存操作数<br><br>8.”r”,”q”代表寄存器操作数（就是随便一个寄存器）<br><br>9.”i”代表立即数操作数<br><br>10.”f”代表浮点寄存器操作数<br><br>11.”F”代表浮点立即数操作数<br><br>12.”o”内存操作数，要求内存地址范围是在同样一个段内<br><br>13.”v”内存操作数，但是不在同一个段内<br><br>14.”n”一个确定值的立即数<br></p>]]></content>
    
    
    <categories>
      
      <category>内嵌汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内嵌汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏，#define</title>
    <link href="undefined2019/10/27/%E5%AE%8F%EF%BC%8C-define/"/>
    <url>2019/10/27/%E5%AE%8F%EF%BC%8C-define/</url>
    
    <content type="html"><![CDATA[<p>转载<br><br>原文链接：<a href="https://blog.csdn.net/Boring_Wednesday/article/details/78756696" target="_blank" rel="noopener">https://blog.csdn.net/Boring_Wednesday/article/details/78756696</a><br></p><div id="content_views" class="markdown_views">                    <!-- flowchart 箭头图标 勿删 -->                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/>                    </svg>                                            <h3 id="写在前面"><a name="t0"></a>写在前面：</h3><h3 id="本文所有代码均在linux环境下运行"><a name="t1"></a>本文所有代码均在<strong>Linux</strong>环境下运行</h3><h3 id="linux版本为centos-74"><a name="t2"></a><strong>Linux</strong>版本为CentOS 7.4</h3><hr><h3 id="宏定义"><a name="t3"></a>宏定义</h3><blockquote>  <h4 id="语法">语法</h4>  <h4 id="define-name-stuff">#define name Stuff</h4></blockquote><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PI 3.14</span><span class="hljs-comment">//定义一个M，值为3.14</span><span class="hljs-preprocessor">#define DO_FOREVER for(;;)</span><span class="hljs-comment">//定义一个死循环</span><span class="hljs-preprocessor">#define REG register</span><span class="hljs-comment">//定义REG来作为register的别名</span><span class="hljs-preprocessor">#define CASE break;case</span><span class="hljs-comment">//在switch中用CASE来补上break;</span><span class="hljs-preprocessor">#define DEBUG_PRINT printf("file:%s\tline:%d\tdate:%s\ttime:%s\n",\</span>                        __FILE__, __LINE__, __DATE__, __TIME__);<span class="hljs-comment">//测试预定义符号</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre><h3 id="1宏的作用范围"><a name="t4"></a>1、<strong>宏</strong>的<strong>作用范围</strong></h3><h4 id="先看下面代码">先看下面代码：</h4><p><img src="https://img-blog.csdn.net/20171209164450664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="让我们查看上图中代码经过预处理后的样子">让我们查看上图中代码经过预处理后的样子</h4><p><img src="https://img-blog.csdn.net/20171209165200867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以发现宏只对宏定义后的行数起作用且与定义在哪里无关即使函数不被调用也可以使用宏"><strong>可以发现宏只对宏定义后的行数起作用，且与定义在哪里无关，即使函数不被调用，也可以使用宏</strong></h4><h3 id="2宏替换的原则"><a name="t5"></a>2、<strong>宏替换</strong>的<strong>原则</strong></h3><h4 id="在程序中扩展define定义符号和宏时需要涉及几个步骤">在程序中扩展#define定义符号和宏时，需要涉及几个步骤。</h4><blockquote>  <h4 id="1-在调用宏时首先对参数进行检查看看是否包含任何由define定义的符号如果是它们首先被替换">1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。</h4>  <h4 id="2-替换文本随后被插入到程序中原来文本的位置对于宏参数名被他们的值替换">2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。</h4>  <h4 id="3-最后再次对结果文件进行扫描看看它是否包含任何由define定义的符号如果是就重复上述处理过程">3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。</h4></blockquote><h4 id="注意"><strong>注意</strong>：</h4><blockquote>  <h4 id="1宏函数不能出现递归">1、宏函数<strong>不能</strong>出现<strong>递归</strong></h4>  <h4 id="2宏定义的符号即name部分不会在预处理替换的时候被搜索">2、宏定义的符号，即name部分<strong>不会</strong>在预处理替换的时候被搜索</h4></blockquote><h3 id="3宏定义define后不需要加"><a name="t6"></a>3、宏定义#define后不需要加<code>;</code></h3><blockquote>  <h4 id="例如">例如：</h4>  <h4 id="define-m-100">#define M 100;</h4>  <h4 id="这里在100后面加上了">这里在100后面加上了<code>;</code></h4>  <h4 id="在句子中有时候就会出现问题">在句子中有时候就会出现问题</h4></blockquote><h4 id="观察下面代码片段">观察下面代码片段：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define M 100;</span><span class="hljs-keyword">if</span> (condition)    m = M；<span class="hljs-keyword">else</span>    max = <span class="hljs-number">0</span>；<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="在该选择语句中会出现语法错误没有与else与之匹配的if语句">在该选择语句中会出现语法错误，没有与else与之匹配的if语句</h4><h3 id="4宏函数申明"><a name="t7"></a>4、<strong>宏函数</strong>申明</h3><blockquote>  <h4 id="宏函数申明格式"><strong>宏函数申明格式：</strong></h4>  <h4 id="define-name-parament-list-stuff">#define name ( parament-list ) stuff</h4>  <h4 id="parament-list为参数表可以包含多个参数他们会在stuff出现">parament-list为参数表，可以包含多个参数，他们会在stuff出现</h4></blockquote><h4 id="例如-1"><strong>例如：</strong></h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQARE( X ) X*X</span><span class="hljs-comment">//定义一个计算乘方的宏函数</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><h4 id="但是这么定义是会出现预料之外的错误的观察下面代码片段">但是这么定义是会出现<strong>预料之外</strong>的错误的，观察下面代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQUARE(X) X*X</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, SQUARE(a+<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="本来结果应该为62-36">本来结果应该为6^2 = 36</h4><p><img src="https://img-blog.csdn.net/20171209161434163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="但是实际计算机输出的结果为11">但是实际计算机输出的结果为11</h4><h4 id="我们用gcc观察预处理后的代码片段是怎么样的">我们用gcc观察预处理后的代码片段是怎么样的</h4><h4 id="使用命令-gcc-e-testc-o-testi来查看预处理后的代码">使用命令<code>$ gcc -E test.c -o test.i</code>来查看预处理后的代码</h4><p><img src="https://img-blog.csdn.net/20171209162424712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以看到这里原式被替换成-a-1-a-1-11而这个结果显然不是我们期望的">可以看到这里原式被替换成 a + 1 * a + 1 = 11，而这个结果显然不是我们期望的</h4><h4 id="这里我们提出解决方案将-x-用括号括起来x这样就避免上述代码因符号优先级带来的错误">这里我们提出解决方案，将 X 用括号括起来（X），这样就避免上述代码因符号优先级带来的错误</h4><h4 id="至此上面代码解决了来看下面的宏函数定义">至此，上面代码解决了，来看下面的宏函数定义：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define DOUBLE(X) (X) + (X)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">10</span> * DOUBLE(a));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="期望结果为100而看程序执行结果">期望结果为100，而看程序执行结果：</h4><p><img src="https://img-blog.csdn.net/20171209163654504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="程序再次出现预料之外的结果原因是原式被替换成了">程序再次出现预料之外的结果，原因是原式被替换成了</h4><h4 id="10-5-5-55">10 * 5 + 5 = 55</h4><h4 id="解决方法"><strong>解决方法：</strong></h4><h4 id="在宏函数定义时对stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题">在宏函数定义时，对Stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题</h4><h3 id="5宏中的和"><a name="t8"></a>5、宏中的<strong>#</strong>和<strong>##</strong></h3><h4 id="的用法"><strong>#的用法</strong></h4><h4 id="首先要理解一个原则即邻近字符串连接原则">首先要理解一个原则，即<strong>邻近字符串连接原则</strong></h4><blockquote>  <h4 id="在c语言中">在C语言中</h4>  <h4 id="printfhello-worldn">printf(“hello”” world!”“\n”);</h4>  <h4 id="这句话是合法的">这句话是合法的</h4>  <h4 id="打印结果为">打印结果为：</h4>  <h4 id="hello-world">hello world!</h4></blockquote><h4 id="按照上述原则我们可以写出下列代码">按照上述原则，我们可以写出下列代码:</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PRINT(FORMAT, VALUE) printf("the value of " #VALUE " is "FORMAT"\n", VALUE)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    PRINT(<span class="hljs-string">"%d"</span>, i + <span class="hljs-number">3</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="看下gcc编译后的代码程序正常运行">看下gcc编译后的代码，程序正常运行：</h4><p><img src="https://img-blog.csdn.net/20171209173118273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="我们再通过gcc生成testi文件看下预处理是怎么样的">我们再通过gcc生成test.i文件看下预处理是怎么样的：</h4><p><img src="https://img-blog.csdn.net/20171209173520670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="所以我们可以看出来的作用">所以我们可以看出来<strong>#的作用：</strong></h4><h4 id="将一个宏参数变成一个对应的字符串">将一个<strong>宏参数</strong>变成一个<strong>对应的字符串</strong></h4><h4 id="在上述例子中">在上述例子中：</h4><blockquote>  <h4 id="value被替换成了i-3"><strong>#VALUE</strong>被替换成了<strong>“i + 3”</strong></h4>  <h4 id="别忘了被替换的时候i-3两边加上了双引号">别忘了被替换的时候i + 3两边<strong>加上了双引号</strong></h4></blockquote><h4 id="的用法-1"><strong>##的用法</strong></h4><h4 id="看下面的代码片段">看下面的代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define ADD_TO_AN(num, value) a##num += value</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">0</span>;    ADD_TO_AN(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);    ADD_TO_AN(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><h4 id="解释一下上面这段代码">解释一下上面这段代码</h4><h4 id="假设有一个变量叫a1">假设有一个变量叫a1</h4><h4 id="此时代码片段为addtoan1-5">此时代码片段为ADD_TO_AN(1, 5)</h4><h4 id="即替换为a1-5给a1变量增加5">即替换为a1 += 5，给a1变量增加5</h4><h4 id="同理addtoan2-6则替换成a2-6">同理ADD_TO_AN(2, 6)则替换成a2 += 6</h4><blockquote>  <h4 id="的作用"><strong>##的作用</strong></h4>  <h4 id="将两边的字符连在一起作为一个标识符">将##两边的字符连在一起作为一个标识符</h4>  <h4 id="前提连接后的标识符必须合法否则编译出现标识符未定义">前提连接后的标识符必须合法，否则编译出现标识符未定义</h4></blockquote><h3 id="6宏和函数"><a name="t9"></a>6、<strong>宏</strong>和<strong>函数</strong></h3><h4 id="宏通常被应用于执行简单的运算">宏通常被应用于执行简单的运算</h4><h4 id="和函数相比宏有他的优点">和函数相比，宏有他的优点</h4><blockquote>  <h4 id="宏的优点"><strong>宏的优点：</strong></h4>  <h4 id="1-用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多所以宏比函数在程序的规模和速度方面更胜一筹">1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以<strong>宏比函数在程序的规模和速度方面更胜一筹</strong></h4>  <h4 id="2-更为重要的是函数的参数必须声明为特定的类型所以函数只能在类型合适的表达式上使用反之这个宏怎可以适用于整形长整型浮点型等可以用于来比较的类型宏的参数与类型无关的">2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于<code>&gt;</code>来比较的类型。<strong>宏的参数与类型无关的</strong></h4>  <h4 id="3-宏参数可以使用变量类型而函数不可以例如">3. 宏参数<strong>可以使用变量类型</strong>，而函数不可以，例如：</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs cs has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MALLOC(num, type) (type *)malloc(num * sizeof(type))</span>MALLOC(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>);<span class="hljs-comment">//类型作为参数</span><span class="hljs-comment">//预处理器替换之后：</span>(<span class="hljs-keyword">int</span> *)malloc(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="但是宏参数与类型无关是一把双刃剑和函数比较也有他的缺点">但是，宏参数与类型无关是一把双刃剑，和函数比较也有他的缺点</h4><blockquote>  <h4 id="宏的缺点"><strong>宏的缺点：</strong></h4>  <h4 id="1-每次使用宏的时候一份宏定义的代码将插入到程序中除非宏比较短否则可能大幅度增加程序的长度">1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能<strong>大幅度增加程序的长度</strong></h4>  <h4 id="2-宏是没法调试的">2. <strong>宏</strong>是<strong>没法调试的</strong></h4>  <h4 id="3-宏由于类型无关也就不够严谨">3. <strong>宏由于类型无关</strong>，也就<strong>不够严谨</strong></h4>  <h4 id="4-宏可能会带来运算符优先级的问题导致程序容易出现问题">4. 宏可能会<strong>带来运算符优先级的问题</strong>，导致程序<strong>容易出现问题</strong></h4></blockquote><h4 id="我的建议"><strong>我的建议：</strong></h4><blockquote>  <h4 id="当有一部分功能既可以用函数实现也可以用宏实现且在调用函数的过程与宏使用过程所消耗的资源相当时优先考虑代码的严谨性使用函数">当有一部分功能既可以用函数实现也可以用宏实现，且在<strong>调用函数的过程</strong>与<strong>宏使用过程</strong>所<strong>消耗的资源相当时</strong>，<strong>优先考虑代码的严谨性</strong>，使用函数</h4></blockquote><h3 id="7宏参数的副作用"><a name="t10"></a>7、<strong>宏参数</strong>的<strong>副作用</strong></h3><blockquote>  <h4 id="当宏参数在宏的定义中出现超过一次的时候如果参数带有副作用那么你在使用这个宏的时候就可能出现危险导致不可预测的后果副作用就是表达式求值的时候出现的永久性效果">当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs perl has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-comment">#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )</span><span class="hljs-keyword">x</span> = <span class="hljs-number">5</span>;<span class="hljs-keyword">y</span> = <span class="hljs-number">8</span>;z = MAX(<span class="hljs-keyword">x</span>++, <span class="hljs-keyword">y</span>++);<span class="hljs-keyword">printf</span>(<span class="hljs-string">"x=<span class="hljs-variable">%d</span> y=<span class="hljs-variable">%d</span> z=<span class="hljs-variable">%d</span>\n"</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, z);<span class="hljs-regexp">//</span>结果为<span class="hljs-keyword">x</span>=<span class="hljs-number">6</span> <span class="hljs-keyword">y</span>=<span class="hljs-number">10</span> z=<span class="hljs-number">9</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre><h4 id="可以看到上面代码中y带来了副作用所以在使用宏的时候避免使用运算和-运算">可以看到上面代码中y++带来了副作用，所以在使用宏的时候，避免使用<code>++</code>运算和<code>--</code>运算</h4><h3 id="8宏的命名"><a name="t11"></a>8、宏的<strong>命名</strong></h3><h4 id="宏和函数的使用很类似我们平时的使用习惯是">宏和函数的使用很类似，我们平时的使用习惯是：</h4><blockquote>  <h4 id="1-宏名全部大写"><strong>1. 宏名全部大写</strong></h4>  <h4 id="2-函数名不全大写"><strong>2. 函数名不全大写</strong></h4></blockquote><h2 id="最后感谢所有访问我博客的来访者"><a name="t12"></a><strong>最后，感谢所有访问我博客的来访者</strong></h2>                                    </div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ main函数中参数argc和argv含义以及用法</title>
    <link href="undefined2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>原文链接:<a href="https://www.cnblogs.com/mtcnn/p/9412008.html" target="_blank" rel="noopener">https://www.cnblogs.com/mtcnn/p/9412008.html</a></p><div id="cnblogs_post_body" class="blogpost-body "><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argc 是 argument count的缩写，表示传入main函数的参数个数；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">简单用法示例，新建工程键代码：</span></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><p><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</p><p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;argv[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><p></p><p></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">argv是指向指针的指针，main函数的第二个参数<strong>“char *argv[]“也可以替换为 “char **argv“</strong>，两者是等价的。</span></p><span style="font-size:14px;">在编译环境下按F5运行，输出如下：</span><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721225702418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">可见，在没有参数传入的情况下，保存程序名称的第一个变量argv[0]依然存在。</span></p><p><span style="font-size:14px;">传参数给main函数有两种方法，第一种方式是在编译环境中设置，以vs2012为例，右击项目—&gt;属性—&gt;配置属性—&gt;调试—&gt;命令参数，在命令参数中输入，每个参数之间用空格隔开。</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721231958740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">之后点击确定并应用，运行之后显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232144436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">第二种方式也是经常会用到的方式是通过命令提示符传入。首先需要打开命令提示符窗口，点击开始菜单在“搜索程序和文件”里输入命令“cmd”或者直接按<strong>快捷键 Windows+R</strong>，在弹出的对话框里输入“cmd”即可打开命令提示符窗口：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232732806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">打开命令提示符窗口后需要输入生成的exe文件所在的完整路径，一个简便的方法是</span><span style="font-size:14px;background-color:rgb(255,0,0);">把exe文件直接拖入提示符窗口即可</span><span style="font-size:14px;">，之后输入传入参数，以空格分隔，之后回车，显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721233522377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">如果你坚持要手工输入完整路径的话，你会发现等你“Ctrl+C”路径后，在提示符窗口中按“Ctrl+V”却不能粘贴，这时候可以在窗口中右键单击一下试试，你会发现<strong><span style="color:#ff0000;">右键菜单里的粘贴功能还是有效的</span></strong>。</span></p><p><span style="font-size:14px;">下一个例子演示使用opencv显示一幅图片：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span><br></span>{<br>    Mat image=imread(argv[<span class="hljs-number">1</span>]);<br>    imshow(<span class="hljs-string">“Lena”</span>,image);<br>    waitKey();<br>}</p></code></pre><span style="font-size:14px;"></span><p></p><p></p><p><span style="font-size:14px;"><br></span></p>注意读入的参数是argv[1]，在命令提示符窗口运行：<p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721235245942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">最后说明一下：<span style="color:#ff0000;"><strong>一般编译器默认使用argc和argv两个名称作为main函数的参数，但这两个参数如此命名并不是必须的，你可以使用任何符合C++语言命名规范的变量名作为入参</strong></span>，效果是一样的：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,<span class="hljs-keyword">char</span> **point)</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;value;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;point[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><span style="font-size:14px;"><br><br></span><br><p></p><p></p></div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈工大-操作系统(实验二）-系统调用</title>
    <link href="undefined2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>此次实验的基本内容是：在linux-0.11上添加两个系统调用，并编写两个简单的应用程序测试他们。<br><br>感谢两位大佬的博客指点：<br><br><a href="https://www.jianshu.com/p/5786cd42b152" target="_blank" rel="noopener" title="寒夏凉秋">https://www.jianshu.com/p/5786cd42b152</a>  <br><br>  <a href="https://github.com/Wangzhike/HIT-Linux-0.11" target="_blank" rel="noopener" title="qiuyu_mac">https://github.com/Wangzhike/HIT-Linux-0.11</a><br></p><h1 id="应用程序怎么调用系统调用？"><a href="#应用程序怎么调用系统调用？" class="headerlink" title="应用程序怎么调用系统调用？"></a>应用程序怎么调用系统调用？</h1><blockquote><p>通常情况下，调用系统调用与调用一个普通的自定义代码没什么区别，但是调用后发生的事情不同，调用自定义函数通常通过call指令直接跳转到目标函数的地址处，继续运行，但是调用系统调用，是调用系统库中为系统调用编写的一个接口函数，叫做API（Application Programming Interface）（它对应一个宏_syscallx，在unistd.h中）。<br>API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用。</p><h2 id="（1）系统调用的基本过程"><a href="#（1）系统调用的基本过程" class="headerlink" title="（1）系统调用的基本过程"></a>（1）系统调用的基本过程</h2><p>1.应用程序调用库函数（API）<br><br>2.API函数要么通过自己添加含有int $0x80的嵌入汇编代码,要么调用syscall0到syscall3这四个宏函数（这四个函数在include/unistd.h中定义）将系统调用号存入EAX寄存器，通过int $0x80编程异常处理进入到内核态的<strong>系统调用</strong>处理函数system_call<br><br>3.<strong>系统调用</strong> 处理函数system_call根据系统调用号，调用对应的内核函数（真正的<strong>系统调用</strong>实现函数）<br><br>4.system_call处理完成后返回API函数中，并将内核函数的返回值通过EAX寄存器传递给API函数<br><br>5.API函数将返回值返回给应用程序</p><h2 id="（2）在Linux-0-11中添加一个系统调用foo（）的步骤："><a href="#（2）在Linux-0-11中添加一个系统调用foo（）的步骤：" class="headerlink" title="（2）在Linux 0.11中添加一个系统调用foo（）的步骤："></a>（2）在Linux 0.11中添加一个系统调用foo（）的步骤：</h2><p>1.编写API函数 foo()，根据器参数的个数，调用syscall0到syscall3这四个宏函数的其中一个，或者手动添加含有int $0x80的嵌入汇编代码，通过EAX寄存器传入系统调用号，进入内核。<br><br>2.在内核中实现 真正的系统调用函数sys_foo，并修改对应的makefile文件<br><br>3.同时在sys_call_table中加入sys_foo()函数的函数名，既入口地址，在该头文件中声明sys_foo()函数<br><br>4.在include/unistd.h中定义sys_foo()函数的系统调用号<br><br>5.修改kernel/system_call.s中代表系统调用总数的变量nr_system_calls的值<br><br>6.编写测试程序，修改添加了foo（）系统调用的Linux 0.11的文件系统下的unistd.h的文件，加入foo（）的系统调用号，运行测试程序，检验效果。</p><h3 id="实操："><a href="#实操：" class="headerlink" title="实操："></a>实操：</h3><p>(1).在虚拟机中编写号iam.c跟whoami.c两个文件（这两个文件就是我们全部完成实验步骤后在boch中运行的程序）<br><br>写好这两个文件后，在oslab中运行<br><br><code>sudo ./mount-hdc</code><br><br>可以把虚拟机硬盘挂载在oslab/hdc目录下然后再将文件复制到oslab/hdc/usr/root/下，usr/root/就是你的linux 0.11开机后所在的目录&lt;就相当于window的桌面上的东西&gt;<br><br>iam.c<br></p></blockquote><pre><code>//为什么要写#define __LIBRARY__这句话呢？我猜测是因为unistd.h中有一句#ifdef __LIBRARY__,//只有__LIBRARY__被定义过才能展开_syscall1().#define __LIBRARY__  #include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;_syscall1(int,iam,const char*,name)int main(int argc,char* argv[]){    iam(argv[1]);    return 0;}</code></pre><p>这里的int main中的两个参数分别代表的是<br><br>argc代表传入main函数的参数的个数<br><br>argv代表传入main函数的参数序列或指针<br><br>具体看这里：<a href="https://lexssama.github.io/2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">C++ main函数中参数argc和argv含义以及用法</a></p><p>whoami.c<br></p><blockquote></blockquote><pre><code>#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt; _syscall2(int, whoami, char*, name, unsigned int, size);int main(int argc, char ** argv){char t[30];whoami(t, 30);printf(&quot;%s\n&quot;, t);return 0;}</code></pre><p>(2).编写who.c文件（里面包括sys_iam()和sys_whoami()文件),将完成的who.c放进linux-0.11/kernel目录下<br><br>who.c<br></p><blockquote></blockquote><pre><code>#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;asm/segment.h&gt;char msg[24]; int sys_iam(const char * name){char tep[26];int i = 0;for(; i &lt; 26; i++){tep[i] = get_fs_byte(name+i);if(tep[i] == &#39;\0&#39;)  break;}if (i &gt; 23) return -(EINVAL);strcpy(msg, tep);return i;    }int sys_whoami(char * name, unsigned int size){int len = 0;for (;msg[len] != &#39;\0&#39;; len++);if (len &gt; size) {return -(EINVAL);}int i = 0;for(i = 0; i &lt; size; i++){put_fs_byte(msg[i], name+i);if(msg[i] == &#39;\0&#39;) break;}return i;}</code></pre><p>(3).修改linux-0.11/kernel中的makefile文件。<br><br>修改makefile文件为的是让添加的who.c文件可以和其他Linux代码链接在一起。<br><br><strong>修改完成后“make all”就能自动把who.c加入到内核中了</strong></p><blockquote></blockquote><pre><code>OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o改为：OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o who.o另一处：### Dependencies:exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h改为：### Dependencies:who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.hexit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h</code></pre><p>(4).在sys_call_table中(<strong>sys_call_table是一个指针变量存在于linux-0.11/include/linux/sys.h</strong>)加入sys_iam和sys_whoami函数的函数名，即入口地址，在改头文件中声明sys_iam和sys_whoami函数。</p><blockquote></blockquote><pre><code>extern int sys_setup();extern int sys_exit();extern int sys_fork();extern int sys_read();extern int sys_write();extern int sys_open();extern int sys_close();extern int sys_waitpid();extern int sys_creat();extern int sys_link();extern int sys_unlink();extern int sys_execve();extern int sys_chdir();extern int sys_time();extern int sys_mknod();extern int sys_chmod();extern int sys_chown();extern int sys_break();extern int sys_stat();extern int sys_lseek();extern int sys_getpid();extern int sys_mount();extern int sys_umount();extern int sys_setuid();extern int sys_getuid();extern int sys_stime();extern int sys_ptrace();extern int sys_alarm();extern int sys_fstat();extern int sys_pause();extern int sys_utime();extern int sys_stty();extern int sys_gtty();extern int sys_access();extern int sys_nice();extern int sys_ftime();extern int sys_sync();extern int sys_kill();extern int sys_rename();extern int sys_mkdir();extern int sys_rmdir();extern int sys_dup();extern int sys_pipe();extern int sys_times();extern int sys_prof();extern int sys_brk();extern int sys_setgid();extern int sys_getgid();extern int sys_signal();extern int sys_geteuid();extern int sys_getegid();extern int sys_acct();extern int sys_phys();extern int sys_lock();extern int sys_ioctl();extern int sys_fcntl();extern int sys_mpx();extern int sys_setpgid();extern int sys_ulimit();extern int sys_uname();extern int sys_umask();extern int sys_chroot();extern int sys_ustat();extern int sys_dup2();extern int sys_getppid();extern int sys_getpgrp();extern int sys_setsid();extern int sys_sigaction();extern int sys_sgetmask();extern int sys_ssetmask();extern int sys_setreuid();extern int sys_setregid();</code></pre><blockquote></blockquote><pre><code>extern int sys_iam();//需要新增的地方extern int sys_whoami();</code></pre><blockquote></blockquote><pre><code>fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid,sys_setregid, sys_iam, sys_whoami };//记得在中断向量表的最后填上系统调用</code></pre><blockquote></blockquote><p>(5).在include/unistd.h中定义sys_iam和sys_whoami的函数系统调用号。<br><br><strong>注意：unistd.h不能直接在oslab中修改</strong>，需要运行<br></p><blockquote></blockquote><p><code>sudo ./mount-hdc</code><br><br>把虚拟机硬盘挂载在oslab/hdc目录下，在hdc/usr/include目录中修改unistd.h。<br><br>至于为什么要这么做自己也没搞懂。</p><blockquote></blockquote><pre><code>#define __NR_setup    0   /* used only by init, to get system going */#define __NR_exit    1#define __NR_fork    2#define __NR_read    3#define __NR_write    4#define __NR_open    5#define __NR_close    6#define __NR_waitpid    7#define __NR_creat    8#define __NR_link    9#define __NR_unlink    10#define __NR_execve    11#define __NR_chdir    12#define __NR_time    13#define __NR_mknod    14#define __NR_chmod    15#define __NR_chown    16#define __NR_break    17#define __NR_stat    18#define __NR_lseek    19#define __NR_getpid    20#define __NR_mount    21#define __NR_umount    22#define __NR_setuid    23#define __NR_getuid    24#define __NR_stime    25#define __NR_ptrace    26#define __NR_alarm    27#define __NR_fstat    28#define __NR_pause    29#define __NR_utime    30#define __NR_stty    31#define __NR_gtty    32#define __NR_access    33#define __NR_nice    34#define __NR_ftime    35#define __NR_sync    36#define __NR_kill    37#define __NR_rename    38#define __NR_mkdir    39#define __NR_rmdir    40#define __NR_dup    41#define __NR_pipe    42#define __NR_times    43#define __NR_prof    44#define __NR_brk    45#define __NR_setgid    46#define __NR_getgid    47#define __NR_signal    48#define __NR_geteuid    49#define __NR_getegid    50#define __NR_acct    51#define __NR_phys    52#define __NR_lock    53#define __NR_ioctl    54#define __NR_fcntl    55#define __NR_mpx    56#define __NR_setpgid    57#define __NR_ulimit    58#define __NR_uname    59#define __NR_umask    60#define __NR_chroot    61#define __NR_ustat    62#define __NR_dup2    63#define __NR_getppid    64#define __NR_getpgrp    65#define __NR_setsid    66#define __NR_sigaction    67#define __NR_sgetmask    68#define __NR_ssetmask    69#define __NR_setreuid    70#define __NR_setregid    71   /*Linux system_call total 72*/#define __NR_iam    72     /*new system_call 72 and 73*/#define __NR_whoami    73</code></pre><p>(6).修改kernel/systeam_call.s中代表系统调用总个数的变量 nr_systeam_calls的值（原值是72，改为74）<br></p><blockquote></blockquote><pre><code>sa_handler = 0sa_mask = 4sa_flags = 8sa_restorer = 12nr_system_calls = 74</code></pre><p>(7).自此大功告成，cd 进入oslab中执行 ./run运行系统，<br>在boch中编译iam.c和whoam.c。</p><blockquote></blockquote><pre><code>gcc -o iam iam.c gcc -o whoami whoami.c </code></pre><p>运行./iam 和 ./whoami 。</p>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>系统调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的常用指令</title>
    <link href="undefined2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h1><blockquote><p>hexo n “我的博客” == hexo new “我的博客” —–&gt;新建文章<br><br>hexo p == hexo publish <br><br>hexo g == hexo generate —-&gt;生成<br><br>hexo s == hexo server —–&gt; 启动服务预览<br><br>hexo d == hexo deploy —–&gt;部署到博客上<br></p></blockquote><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><blockquote><p>hexo clean —&gt;清除缓存<br><br>hexo g —-&gt;生成静态网页<br><br>hexo d —-&gt;开始部署<br></p></blockquote><h1 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h1><blockquote><p>hexo generate –watch –&gt;监视文件变动</p></blockquote><h1 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h1><blockquote><p>hexo generate –deploy == hexo g -d<br><br>hexo deploy –generate == hexo d -g<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>