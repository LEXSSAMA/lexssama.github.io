<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>目标文件格式</title>
    <link href="undefined2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>#ELF目标文件格式<br><br>目标文件格式有很多种，例如：System V UNIX 的COFF，window 的PE，Linux 的ELF。<br><br>##链接视图<br></p><h3 id="可重定位目标文件格式"><a href="#可重定位目标文件格式" class="headerlink" title="可重定位目标文件格式"></a>可重定位目标文件格式<br></h3><p> <img src="/.com//20180708185336199.png" srcset="/img/loading.gif" alt><br><br><strong>1.ELF头</strong><br><br>ELF头位于目标文件的起始位置，包括文件结构说明信息。ELF头的数据结构分为32位系统对于结构和64位系统对应结构。(可以使用readelf -h 命令对某个可重定位目标文件的ELF头进行解析。例如：对main.o头文件进行解析：readelf -h main.o）<br><br><strong>2.节</strong><br><br>节是ELF文件的主体信息，包含了链接过程所用的目标代码信息，包括指令，数据，符号表和重定位信息等。<br><br>.text :目标代码部分<br><br>.rodata:只读数据节<br><br>.data:已初始化全局变量<br><br>.bss:未初始化的全局变量（不占据实际的磁盘空间）<br><br>.symtab：符号表，程序中定义的函数名和全局静态变量名都属于符号，与这些符号相关的信息也保存在符号表中。<br><br>.rel.text: .text节相关的可重定位信息。当链接器将某一个目标文件和其他目标文件组合时，.text节中的代码被合并后，一些指令中引用的操作地址信息或跳转目标指令的位置信息等都可以能被修改，通常，调用外部函数或引用全局变量的指令中的地址字段需要修改。<br><br>.rel.data:.data节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时, .data节中的代码被合并后，一些全局静态变量的地址可能被修改。<br><br>.debug:调试用符号表，有些表项对定义的局部变量和定义的类型进行说明，有些表项对定义和引用的全局静态变量进行说明。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.line：C源程序中的行号和.text节中机器指令之间的映射。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.strlab:字符串表，包括.symtab节和.debug节中的符号以及节头表中的节名。字符串表就是以null结尾的字符串序列。<br><br><strong>3.节头表</strong><br><br>节头表由若干个表项组成，每个表现描述相应的一个节的节名，在文件中的偏移，大小，访问属性，对齐方式等。<br>##执行视图<br><br><img src="/.com//fSqCY0UBZnX35qDCxjx67h98ps8JduKzOqgUQBtL.png" srcset="/img/loading.gif" alt><br></p><center> **ELF可执行目标文件**</center><br>与ELF可重定位文件不同的是：<br>**1.**ELF头文件中的字段e\_entry给出了系统将控制权转移到虚拟地址（入口点），即执行程序时第一条指令的地址而可重定位文件中，此字段为0。<br>**2.**多了一个.init节，其中.init节定义了一个_init函数用来可执行目标文件开始执行时的初始化工作，当程序开始时，系统进入主函数之前先执行这个节中的指令代码。<br>**3.**去掉了用去重定位的节.rel.text和.rel.data（因为已经重定位完毕了）。<br>**4.**多了一个程序头表：也叫做段头表，是一个结构数组。<br><p>##可执行文件的存储器映像<br><br><img src="/.com//20170621205440745.png" srcset="/img/loading.gif" alt><br><br>当启动一个一个可执行目标文件时，首先会通过某种方式调出常驻内存的一个称为加载器（loader)的操作系统程序来进行处理，例如，任何的Unix程序的加载执行都是通过调用execve目标文件中相关节的内容与虚拟地址空间中的只读代码段和可读写代码段通过页表建立映射，然后启动可执行目标文件中的第一条指令执行。（这里关系到页表的内容在6.5节还没学到)</p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第4章—程序的链接</title>
    <link href="undefined2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/"/>
    <url>2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-程序的链接-小结《课本214页》"><a href="#第4章-程序的链接-小结《课本214页》" class="headerlink" title="第4章 程序的链接-小结《课本214页》"></a>第4章 程序的链接-小结《课本214页》</h1><p><strong>1.</strong>链接器位于编译器，指令集体系结构和操作系统的交叉点上，涉及指令系统，代码生成，机器语言，程序转换和虚拟存储管理等诸多概念。<br><br><strong>2.</strong>链接处理涉及三种目标文件格式：可重定位目标文件，可执行目标文件和共享库目标文件。<br><br><strong>3.</strong>共享库文件是一中特殊的可定位目标文件。<br><br><strong>4.</strong>ELF目标文件格式有链接视图和执行视图两种，前者是可重定位目标格式，后者是可执行目标格式。<br><br>链接视图包括：ELF头，各种节，节头表。<br><br>执行视图包括：ELF头，程序头表，各种节组成的段。<br><br><strong>5.</strong>链接包括两种链接形式：一是：静态链接，二是：动态链接。<br><br>静态链接：就是将多个可重定位文件中的相同类型的节合并起来以生成完全链接的可执行目标文件，它的所有符号引用都是确定的虚拟地址空间中的最终地址，因而可以直接被加载执行。<br><br>动态链接：动态链接模式下的可执行目标文件是部分链接的，还有一部分的引用地址没有确定，需要利用共享库中的定义符号进行重定位，因而需要由动态链接器来加载共享库并重定位可执行文件中部分文件的引用。<br><br>动态链接又有两种形式分别是：一种是可执行目标文件加载时进行共享库的动态链接；另一种时可执行目标文件执行时进行共享库的动态链接。<br><br><strong>6.</strong>在不同模块可能会定义相同的符号 <strong>（这里说的符号指的是被写入.data节.bss节中的符号，不包括执行时栈中的符号）</strong>，因为相同的多个符号只能分配一个地址，所以链接器以哪个符号为准？编译器通过对定义符号标识是强符号还是弱符号，由链接器根据一套规则来确定多重定义符号中哪个为唯一的定义符号。<br><br><strong>7.</strong>加载器在加载可执行目标文件时，实际上只是把可执行目标文件中的只读代码段和可读写数据段通过页表映射到了虚拟地址空间中的确定位置，并没有真正的把代码和数据从磁盘装入主存。<br>##过程梳理：<br><strong>预处理–&gt;编译–&gt;汇编–&gt;链接</strong><br><br>###<strong>(1.)</strong>预处理<br>对预处理文件命令进行处理，包括对头文件的包含，对宏的扩展，条件编译的选择等，例如：#include&lt;xxxx.h&gt;把xxxx.h文件的内容插入源程序文件中。<br><br>gcc命令：“gcc - E main.c -o main.i”和“ cpp main.c -o main.i”<br></p><p>###<strong>(2.)</strong>编译<br>编译器把代码进行优化（也可以不进行优化）和存储分配，最终把C语言源程序翻译成汇编语言程序。<br><br>gcc命令：“gcc -S main.i -o main .s”和 “ccl main.i -o main.s”<br></p><p>###<strong>(3.)</strong>汇编<br>把汇编语言代码转化为机器语言代码生成可重定位目标文件(.o文件）。<br><br>gcc命令：“gcc -c main.s -o main.o” 和 “as main.s -o main.o”<br><br>###<strong>(4.)</strong>链接<br>将所以有关联的可重定位目标文件组合起来，以生成一个可执行文件。（好处：模块化，效率高）<br><br>链接包括两步：<br>####1.符号解析<br>将每一个符号引用与一个确定的符号定义建立关联。<br><br>符号包括:全局静态变量名和函数名，而非静态局部变量名则不是符号。编译器将所有的符号存放在可重定位目标文件的符号表中。<br><br>####2.重定位<br>可重定位目标文件中的代码区和数据区都是从地址0开始的，链接器需要将不同模块中相同的节合并起来生成一个新的单独的节，并将合并后的代码区和数据区按照ABI规范确定虚拟地址空间划分（也称存储器映像）来重新确定位置。<br><br>例如，对于32位Linux系统存储器映像，其只读代码总是从地址0x8048000开始，而可读可写数据段总是在代码段后面（从下到上）第一个4KB对齐的地址处开始，因而链接器余姚重新确定每条指令的每个数据的地址，并且在指令中需要明确给定的引用符号的地址，这种重新定义代码和数据地址并更新指令中引用地址符号的地址的工作叫做重定位。<br></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC内嵌汇编中常见的constraint</title>
    <link href="undefined2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/"/>
    <url>2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/</url>
    
    <content type="html"><![CDATA[<p>1.”a”代表AL/AX/EAX/RAX寄存器<br><br>2.”b”代表BL/BX/EBX/RBX寄存器<br><br>3.”c”代表CL/CX/ECX/RCX寄存器<br><br>4.”d”代表DL/DX/EDX/RDX寄存器<br><br>5”D”代表DI寄存器<br><br>6.”S”代表SI寄存器<br><br>7.”m”代表内存操作数<br><br>8.”r”,”q”代表寄存器操作数（就是随便一个寄存器）<br><br>9.”i”代表立即数操作数<br><br>10.”f”代表浮点寄存器操作数<br><br>11.”F”代表浮点立即数操作数<br><br>12.”o”内存操作数，要求内存地址范围是在同样一个段内<br><br>13.”v”内存操作数，但是不在同一个段内<br><br>14.”n”一个确定值的立即数<br></p>]]></content>
    
    
    <categories>
      
      <category>内嵌汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内嵌汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏，#define</title>
    <link href="undefined2019/10/27/%E5%AE%8F%EF%BC%8C-define/"/>
    <url>2019/10/27/%E5%AE%8F%EF%BC%8C-define/</url>
    
    <content type="html"><![CDATA[<p>转载<br><br>原文链接：<a href="https://blog.csdn.net/Boring_Wednesday/article/details/78756696" target="_blank" rel="noopener">https://blog.csdn.net/Boring_Wednesday/article/details/78756696</a><br></p><div id="content_views" class="markdown_views">                    <!-- flowchart 箭头图标 勿删 -->                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/>                    </svg>                                            <h3 id="写在前面"><a name="t0"></a>写在前面：</h3><h3 id="本文所有代码均在linux环境下运行"><a name="t1"></a>本文所有代码均在<strong>Linux</strong>环境下运行</h3><h3 id="linux版本为centos-74"><a name="t2"></a><strong>Linux</strong>版本为CentOS 7.4</h3><hr><h3 id="宏定义"><a name="t3"></a>宏定义</h3><blockquote>  <h4 id="语法">语法</h4>  <h4 id="define-name-stuff">#define name Stuff</h4></blockquote><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PI 3.14</span><span class="hljs-comment">//定义一个M，值为3.14</span><span class="hljs-preprocessor">#define DO_FOREVER for(;;)</span><span class="hljs-comment">//定义一个死循环</span><span class="hljs-preprocessor">#define REG register</span><span class="hljs-comment">//定义REG来作为register的别名</span><span class="hljs-preprocessor">#define CASE break;case</span><span class="hljs-comment">//在switch中用CASE来补上break;</span><span class="hljs-preprocessor">#define DEBUG_PRINT printf("file:%s\tline:%d\tdate:%s\ttime:%s\n",\</span>                        __FILE__, __LINE__, __DATE__, __TIME__);<span class="hljs-comment">//测试预定义符号</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre><h3 id="1宏的作用范围"><a name="t4"></a>1、<strong>宏</strong>的<strong>作用范围</strong></h3><h4 id="先看下面代码">先看下面代码：</h4><p><img src="https://img-blog.csdn.net/20171209164450664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="让我们查看上图中代码经过预处理后的样子">让我们查看上图中代码经过预处理后的样子</h4><p><img src="https://img-blog.csdn.net/20171209165200867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以发现宏只对宏定义后的行数起作用且与定义在哪里无关即使函数不被调用也可以使用宏"><strong>可以发现宏只对宏定义后的行数起作用，且与定义在哪里无关，即使函数不被调用，也可以使用宏</strong></h4><h3 id="2宏替换的原则"><a name="t5"></a>2、<strong>宏替换</strong>的<strong>原则</strong></h3><h4 id="在程序中扩展define定义符号和宏时需要涉及几个步骤">在程序中扩展#define定义符号和宏时，需要涉及几个步骤。</h4><blockquote>  <h4 id="1-在调用宏时首先对参数进行检查看看是否包含任何由define定义的符号如果是它们首先被替换">1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。</h4>  <h4 id="2-替换文本随后被插入到程序中原来文本的位置对于宏参数名被他们的值替换">2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。</h4>  <h4 id="3-最后再次对结果文件进行扫描看看它是否包含任何由define定义的符号如果是就重复上述处理过程">3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。</h4></blockquote><h4 id="注意"><strong>注意</strong>：</h4><blockquote>  <h4 id="1宏函数不能出现递归">1、宏函数<strong>不能</strong>出现<strong>递归</strong></h4>  <h4 id="2宏定义的符号即name部分不会在预处理替换的时候被搜索">2、宏定义的符号，即name部分<strong>不会</strong>在预处理替换的时候被搜索</h4></blockquote><h3 id="3宏定义define后不需要加"><a name="t6"></a>3、宏定义#define后不需要加<code>;</code></h3><blockquote>  <h4 id="例如">例如：</h4>  <h4 id="define-m-100">#define M 100;</h4>  <h4 id="这里在100后面加上了">这里在100后面加上了<code>;</code></h4>  <h4 id="在句子中有时候就会出现问题">在句子中有时候就会出现问题</h4></blockquote><h4 id="观察下面代码片段">观察下面代码片段：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define M 100;</span><span class="hljs-keyword">if</span> (condition)    m = M；<span class="hljs-keyword">else</span>    max = <span class="hljs-number">0</span>；<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="在该选择语句中会出现语法错误没有与else与之匹配的if语句">在该选择语句中会出现语法错误，没有与else与之匹配的if语句</h4><h3 id="4宏函数申明"><a name="t7"></a>4、<strong>宏函数</strong>申明</h3><blockquote>  <h4 id="宏函数申明格式"><strong>宏函数申明格式：</strong></h4>  <h4 id="define-name-parament-list-stuff">#define name ( parament-list ) stuff</h4>  <h4 id="parament-list为参数表可以包含多个参数他们会在stuff出现">parament-list为参数表，可以包含多个参数，他们会在stuff出现</h4></blockquote><h4 id="例如-1"><strong>例如：</strong></h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQARE( X ) X*X</span><span class="hljs-comment">//定义一个计算乘方的宏函数</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><h4 id="但是这么定义是会出现预料之外的错误的观察下面代码片段">但是这么定义是会出现<strong>预料之外</strong>的错误的，观察下面代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQUARE(X) X*X</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, SQUARE(a+<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="本来结果应该为62-36">本来结果应该为6^2 = 36</h4><p><img src="https://img-blog.csdn.net/20171209161434163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="但是实际计算机输出的结果为11">但是实际计算机输出的结果为11</h4><h4 id="我们用gcc观察预处理后的代码片段是怎么样的">我们用gcc观察预处理后的代码片段是怎么样的</h4><h4 id="使用命令-gcc-e-testc-o-testi来查看预处理后的代码">使用命令<code>$ gcc -E test.c -o test.i</code>来查看预处理后的代码</h4><p><img src="https://img-blog.csdn.net/20171209162424712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以看到这里原式被替换成-a-1-a-1-11而这个结果显然不是我们期望的">可以看到这里原式被替换成 a + 1 * a + 1 = 11，而这个结果显然不是我们期望的</h4><h4 id="这里我们提出解决方案将-x-用括号括起来x这样就避免上述代码因符号优先级带来的错误">这里我们提出解决方案，将 X 用括号括起来（X），这样就避免上述代码因符号优先级带来的错误</h4><h4 id="至此上面代码解决了来看下面的宏函数定义">至此，上面代码解决了，来看下面的宏函数定义：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define DOUBLE(X) (X) + (X)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">10</span> * DOUBLE(a));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="期望结果为100而看程序执行结果">期望结果为100，而看程序执行结果：</h4><p><img src="https://img-blog.csdn.net/20171209163654504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="程序再次出现预料之外的结果原因是原式被替换成了">程序再次出现预料之外的结果，原因是原式被替换成了</h4><h4 id="10-5-5-55">10 * 5 + 5 = 55</h4><h4 id="解决方法"><strong>解决方法：</strong></h4><h4 id="在宏函数定义时对stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题">在宏函数定义时，对Stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题</h4><h3 id="5宏中的和"><a name="t8"></a>5、宏中的<strong>#</strong>和<strong>##</strong></h3><h4 id="的用法"><strong>#的用法</strong></h4><h4 id="首先要理解一个原则即邻近字符串连接原则">首先要理解一个原则，即<strong>邻近字符串连接原则</strong></h4><blockquote>  <h4 id="在c语言中">在C语言中</h4>  <h4 id="printfhello-worldn">printf(“hello”” world!”“\n”);</h4>  <h4 id="这句话是合法的">这句话是合法的</h4>  <h4 id="打印结果为">打印结果为：</h4>  <h4 id="hello-world">hello world!</h4></blockquote><h4 id="按照上述原则我们可以写出下列代码">按照上述原则，我们可以写出下列代码:</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PRINT(FORMAT, VALUE) printf("the value of " #VALUE " is "FORMAT"\n", VALUE)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    PRINT(<span class="hljs-string">"%d"</span>, i + <span class="hljs-number">3</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="看下gcc编译后的代码程序正常运行">看下gcc编译后的代码，程序正常运行：</h4><p><img src="https://img-blog.csdn.net/20171209173118273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="我们再通过gcc生成testi文件看下预处理是怎么样的">我们再通过gcc生成test.i文件看下预处理是怎么样的：</h4><p><img src="https://img-blog.csdn.net/20171209173520670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="所以我们可以看出来的作用">所以我们可以看出来<strong>#的作用：</strong></h4><h4 id="将一个宏参数变成一个对应的字符串">将一个<strong>宏参数</strong>变成一个<strong>对应的字符串</strong></h4><h4 id="在上述例子中">在上述例子中：</h4><blockquote>  <h4 id="value被替换成了i-3"><strong>#VALUE</strong>被替换成了<strong>“i + 3”</strong></h4>  <h4 id="别忘了被替换的时候i-3两边加上了双引号">别忘了被替换的时候i + 3两边<strong>加上了双引号</strong></h4></blockquote><h4 id="的用法-1"><strong>##的用法</strong></h4><h4 id="看下面的代码片段">看下面的代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define ADD_TO_AN(num, value) a##num += value</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">0</span>;    ADD_TO_AN(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);    ADD_TO_AN(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><h4 id="解释一下上面这段代码">解释一下上面这段代码</h4><h4 id="假设有一个变量叫a1">假设有一个变量叫a1</h4><h4 id="此时代码片段为addtoan1-5">此时代码片段为ADD_TO_AN(1, 5)</h4><h4 id="即替换为a1-5给a1变量增加5">即替换为a1 += 5，给a1变量增加5</h4><h4 id="同理addtoan2-6则替换成a2-6">同理ADD_TO_AN(2, 6)则替换成a2 += 6</h4><blockquote>  <h4 id="的作用"><strong>##的作用</strong></h4>  <h4 id="将两边的字符连在一起作为一个标识符">将##两边的字符连在一起作为一个标识符</h4>  <h4 id="前提连接后的标识符必须合法否则编译出现标识符未定义">前提连接后的标识符必须合法，否则编译出现标识符未定义</h4></blockquote><h3 id="6宏和函数"><a name="t9"></a>6、<strong>宏</strong>和<strong>函数</strong></h3><h4 id="宏通常被应用于执行简单的运算">宏通常被应用于执行简单的运算</h4><h4 id="和函数相比宏有他的优点">和函数相比，宏有他的优点</h4><blockquote>  <h4 id="宏的优点"><strong>宏的优点：</strong></h4>  <h4 id="1-用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多所以宏比函数在程序的规模和速度方面更胜一筹">1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以<strong>宏比函数在程序的规模和速度方面更胜一筹</strong></h4>  <h4 id="2-更为重要的是函数的参数必须声明为特定的类型所以函数只能在类型合适的表达式上使用反之这个宏怎可以适用于整形长整型浮点型等可以用于来比较的类型宏的参数与类型无关的">2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于<code>&gt;</code>来比较的类型。<strong>宏的参数与类型无关的</strong></h4>  <h4 id="3-宏参数可以使用变量类型而函数不可以例如">3. 宏参数<strong>可以使用变量类型</strong>，而函数不可以，例如：</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs cs has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MALLOC(num, type) (type *)malloc(num * sizeof(type))</span>MALLOC(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>);<span class="hljs-comment">//类型作为参数</span><span class="hljs-comment">//预处理器替换之后：</span>(<span class="hljs-keyword">int</span> *)malloc(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="但是宏参数与类型无关是一把双刃剑和函数比较也有他的缺点">但是，宏参数与类型无关是一把双刃剑，和函数比较也有他的缺点</h4><blockquote>  <h4 id="宏的缺点"><strong>宏的缺点：</strong></h4>  <h4 id="1-每次使用宏的时候一份宏定义的代码将插入到程序中除非宏比较短否则可能大幅度增加程序的长度">1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能<strong>大幅度增加程序的长度</strong></h4>  <h4 id="2-宏是没法调试的">2. <strong>宏</strong>是<strong>没法调试的</strong></h4>  <h4 id="3-宏由于类型无关也就不够严谨">3. <strong>宏由于类型无关</strong>，也就<strong>不够严谨</strong></h4>  <h4 id="4-宏可能会带来运算符优先级的问题导致程序容易出现问题">4. 宏可能会<strong>带来运算符优先级的问题</strong>，导致程序<strong>容易出现问题</strong></h4></blockquote><h4 id="我的建议"><strong>我的建议：</strong></h4><blockquote>  <h4 id="当有一部分功能既可以用函数实现也可以用宏实现且在调用函数的过程与宏使用过程所消耗的资源相当时优先考虑代码的严谨性使用函数">当有一部分功能既可以用函数实现也可以用宏实现，且在<strong>调用函数的过程</strong>与<strong>宏使用过程</strong>所<strong>消耗的资源相当时</strong>，<strong>优先考虑代码的严谨性</strong>，使用函数</h4></blockquote><h3 id="7宏参数的副作用"><a name="t10"></a>7、<strong>宏参数</strong>的<strong>副作用</strong></h3><blockquote>  <h4 id="当宏参数在宏的定义中出现超过一次的时候如果参数带有副作用那么你在使用这个宏的时候就可能出现危险导致不可预测的后果副作用就是表达式求值的时候出现的永久性效果">当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs perl has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-comment">#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )</span><span class="hljs-keyword">x</span> = <span class="hljs-number">5</span>;<span class="hljs-keyword">y</span> = <span class="hljs-number">8</span>;z = MAX(<span class="hljs-keyword">x</span>++, <span class="hljs-keyword">y</span>++);<span class="hljs-keyword">printf</span>(<span class="hljs-string">"x=<span class="hljs-variable">%d</span> y=<span class="hljs-variable">%d</span> z=<span class="hljs-variable">%d</span>\n"</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, z);<span class="hljs-regexp">//</span>结果为<span class="hljs-keyword">x</span>=<span class="hljs-number">6</span> <span class="hljs-keyword">y</span>=<span class="hljs-number">10</span> z=<span class="hljs-number">9</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre><h4 id="可以看到上面代码中y带来了副作用所以在使用宏的时候避免使用运算和-运算">可以看到上面代码中y++带来了副作用，所以在使用宏的时候，避免使用<code>++</code>运算和<code>--</code>运算</h4><h3 id="8宏的命名"><a name="t11"></a>8、宏的<strong>命名</strong></h3><h4 id="宏和函数的使用很类似我们平时的使用习惯是">宏和函数的使用很类似，我们平时的使用习惯是：</h4><blockquote>  <h4 id="1-宏名全部大写"><strong>1. 宏名全部大写</strong></h4>  <h4 id="2-函数名不全大写"><strong>2. 函数名不全大写</strong></h4></blockquote><h2 id="最后感谢所有访问我博客的来访者"><a name="t12"></a><strong>最后，感谢所有访问我博客的来访者</strong></h2>                                    </div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ main函数中参数argc和argv含义以及用法</title>
    <link href="undefined2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>原文链接:<a href="https://www.cnblogs.com/mtcnn/p/9412008.html" target="_blank" rel="noopener">https://www.cnblogs.com/mtcnn/p/9412008.html</a></p><div id="cnblogs_post_body" class="blogpost-body "><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argc 是 argument count的缩写，表示传入main函数的参数个数；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">简单用法示例，新建工程键代码：</span></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><p><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</p><p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;argv[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><p></p><p></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">argv是指向指针的指针，main函数的第二个参数<strong>“char *argv[]“也可以替换为 “char **argv“</strong>，两者是等价的。</span></p><span style="font-size:14px;">在编译环境下按F5运行，输出如下：</span><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721225702418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">可见，在没有参数传入的情况下，保存程序名称的第一个变量argv[0]依然存在。</span></p><p><span style="font-size:14px;">传参数给main函数有两种方法，第一种方式是在编译环境中设置，以vs2012为例，右击项目—&gt;属性—&gt;配置属性—&gt;调试—&gt;命令参数，在命令参数中输入，每个参数之间用空格隔开。</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721231958740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">之后点击确定并应用，运行之后显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232144436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">第二种方式也是经常会用到的方式是通过命令提示符传入。首先需要打开命令提示符窗口，点击开始菜单在“搜索程序和文件”里输入命令“cmd”或者直接按<strong>快捷键 Windows+R</strong>，在弹出的对话框里输入“cmd”即可打开命令提示符窗口：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232732806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">打开命令提示符窗口后需要输入生成的exe文件所在的完整路径，一个简便的方法是</span><span style="font-size:14px;background-color:rgb(255,0,0);">把exe文件直接拖入提示符窗口即可</span><span style="font-size:14px;">，之后输入传入参数，以空格分隔，之后回车，显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721233522377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">如果你坚持要手工输入完整路径的话，你会发现等你“Ctrl+C”路径后，在提示符窗口中按“Ctrl+V”却不能粘贴，这时候可以在窗口中右键单击一下试试，你会发现<strong><span style="color:#ff0000;">右键菜单里的粘贴功能还是有效的</span></strong>。</span></p><p><span style="font-size:14px;">下一个例子演示使用opencv显示一幅图片：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span><br></span>{<br>    Mat image=imread(argv[<span class="hljs-number">1</span>]);<br>    imshow(<span class="hljs-string">“Lena”</span>,image);<br>    waitKey();<br>}</p></code></pre><span style="font-size:14px;"></span><p></p><p></p><p><span style="font-size:14px;"><br></span></p>注意读入的参数是argv[1]，在命令提示符窗口运行：<p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721235245942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">最后说明一下：<span style="color:#ff0000;"><strong>一般编译器默认使用argc和argv两个名称作为main函数的参数，但这两个参数如此命名并不是必须的，你可以使用任何符合C++语言命名规范的变量名作为入参</strong></span>，效果是一样的：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,<span class="hljs-keyword">char</span> **point)</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;value;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;point[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><span style="font-size:14px;"><br><br></span><br><p></p><p></p></div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈工大-操作系统(实验二）-系统调用</title>
    <link href="undefined2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>此次实验的基本内容是：在linux-0.11上添加两个系统调用，并编写两个简单的应用程序测试他们。<br><br>感谢两位大佬的博客指点：<br><br><a href="https://www.jianshu.com/p/5786cd42b152" target="_blank" rel="noopener" title="寒夏凉秋">https://www.jianshu.com/p/5786cd42b152</a>  <br><br>  <a href="https://github.com/Wangzhike/HIT-Linux-0.11" target="_blank" rel="noopener" title="qiuyu_mac">https://github.com/Wangzhike/HIT-Linux-0.11</a><br></p><h1 id="应用程序怎么调用系统调用？"><a href="#应用程序怎么调用系统调用？" class="headerlink" title="应用程序怎么调用系统调用？"></a>应用程序怎么调用系统调用？</h1><blockquote><p>通常情况下，调用系统调用与调用一个普通的自定义代码没什么区别，但是调用后发生的事情不同，调用自定义函数通常通过call指令直接跳转到目标函数的地址处，继续运行，但是调用系统调用，是调用系统库中为系统调用编写的一个接口函数，叫做API（Application Programming Interface）（它对应一个宏_syscallx，在unistd.h中）。<br>API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用。</p><h2 id="（1）系统调用的基本过程"><a href="#（1）系统调用的基本过程" class="headerlink" title="（1）系统调用的基本过程"></a>（1）系统调用的基本过程</h2><p>1.应用程序调用库函数（API）<br><br>2.API函数要么通过自己添加含有int $0x80的嵌入汇编代码,要么调用syscall0到syscall3这四个宏函数（这四个函数在include/unistd.h中定义）将系统调用号存入EAX寄存器，通过int $0x80编程异常处理进入到内核态的<strong>系统调用</strong>处理函数system_call<br><br>3.<strong>系统调用</strong> 处理函数system_call根据系统调用号，调用对应的内核函数（真正的<strong>系统调用</strong>实现函数）<br><br>4.system_call处理完成后返回API函数中，并将内核函数的返回值通过EAX寄存器传递给API函数<br><br>5.API函数将返回值返回给应用程序</p><h2 id="（2）在Linux-0-11中添加一个系统调用foo（）的步骤："><a href="#（2）在Linux-0-11中添加一个系统调用foo（）的步骤：" class="headerlink" title="（2）在Linux 0.11中添加一个系统调用foo（）的步骤："></a>（2）在Linux 0.11中添加一个系统调用foo（）的步骤：</h2><p>1.编写API函数 foo()，根据器参数的个数，调用syscall0到syscall3这四个宏函数的其中一个，或者手动添加含有int $0x80的嵌入汇编代码，通过EAX寄存器传入系统调用号，进入内核。<br><br>2.在内核中实现 真正的系统调用函数sys_foo，并修改对应的makefile文件<br><br>3.同时在sys_call_table中加入sys_foo()函数的函数名，既入口地址，在该头文件中声明sys_foo()函数<br><br>4.在include/unistd.h中定义sys_foo()函数的系统调用号<br><br>5.修改kernel/system_call.s中代表系统调用总数的变量nr_system_calls的值<br><br>6.编写测试程序，修改添加了foo（）系统调用的Linux 0.11的文件系统下的unistd.h的文件，加入foo（）的系统调用号，运行测试程序，检验效果。</p><h3 id="实操："><a href="#实操：" class="headerlink" title="实操："></a>实操：</h3><p>(1).在虚拟机中编写号iam.c跟whoami.c两个文件（这两个文件就是我们全部完成实验步骤后在boch中运行的程序）<br><br>写好这两个文件后，在oslab中运行<br><br><code>sudo ./mount-hdc</code><br><br>可以把虚拟机硬盘挂载在oslab/hdc目录下然后再将文件复制到oslab/hdc/usr/root/下，usr/root/就是你的linux 0.11开机后所在的目录&lt;就相当于window的桌面上的东西&gt;<br><br>iam.c<br></p></blockquote><pre><code>//为什么要写#define __LIBRARY__这句话呢？我猜测是因为unistd.h中有一句#ifdef __LIBRARY__,//只有__LIBRARY__被定义过才能展开_syscall1().#define __LIBRARY__  #include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;_syscall1(int,iam,const char*,name)int main(int argc,char* argv[]){    iam(argv[1]);    return 0;}</code></pre><p>这里的int main中的两个参数分别代表的是<br><br>argc代表传入main函数的参数的个数<br><br>argv代表传入main函数的参数序列或指针<br><br>具体看这里：<a href="https://lexssama.github.io/2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">C++ main函数中参数argc和argv含义以及用法</a></p><p>whoami.c<br></p><blockquote></blockquote><pre><code>#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt; _syscall2(int, whoami, char*, name, unsigned int, size);int main(int argc, char ** argv){char t[30];whoami(t, 30);printf(&quot;%s\n&quot;, t);return 0;}</code></pre><p>(2).编写who.c文件（里面包括sys_iam()和sys_whoami()文件),将完成的who.c放进linux-0.11/kernel目录下<br><br>who.c<br></p><blockquote></blockquote><pre><code>#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;asm/segment.h&gt;char msg[24]; int sys_iam(const char * name){char tep[26];int i = 0;for(; i &lt; 26; i++){tep[i] = get_fs_byte(name+i);if(tep[i] == &#39;\0&#39;)  break;}if (i &gt; 23) return -(EINVAL);strcpy(msg, tep);return i;    }int sys_whoami(char * name, unsigned int size){int len = 0;for (;msg[len] != &#39;\0&#39;; len++);if (len &gt; size) {return -(EINVAL);}int i = 0;for(i = 0; i &lt; size; i++){put_fs_byte(msg[i], name+i);if(msg[i] == &#39;\0&#39;) break;}return i;}</code></pre><p>(3).修改linux-0.11/kernel中的makefile文件。<br><br>修改makefile文件为的是让添加的who.c文件可以和其他Linux代码链接在一起。<br><br><strong>修改完成后“make all”就能自动把who.c加入到内核中了</strong></p><blockquote></blockquote><pre><code>OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o改为：OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o who.o另一处：### Dependencies:exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h改为：### Dependencies:who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.hexit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h</code></pre><p>(4).在sys_call_table中(<strong>sys_call_table是一个指针变量存在于linux-0.11/include/linux/sys.h</strong>)加入sys_iam和sys_whoami函数的函数名，即入口地址，在改头文件中声明sys_iam和sys_whoami函数。</p><blockquote></blockquote><pre><code>extern int sys_setup();extern int sys_exit();extern int sys_fork();extern int sys_read();extern int sys_write();extern int sys_open();extern int sys_close();extern int sys_waitpid();extern int sys_creat();extern int sys_link();extern int sys_unlink();extern int sys_execve();extern int sys_chdir();extern int sys_time();extern int sys_mknod();extern int sys_chmod();extern int sys_chown();extern int sys_break();extern int sys_stat();extern int sys_lseek();extern int sys_getpid();extern int sys_mount();extern int sys_umount();extern int sys_setuid();extern int sys_getuid();extern int sys_stime();extern int sys_ptrace();extern int sys_alarm();extern int sys_fstat();extern int sys_pause();extern int sys_utime();extern int sys_stty();extern int sys_gtty();extern int sys_access();extern int sys_nice();extern int sys_ftime();extern int sys_sync();extern int sys_kill();extern int sys_rename();extern int sys_mkdir();extern int sys_rmdir();extern int sys_dup();extern int sys_pipe();extern int sys_times();extern int sys_prof();extern int sys_brk();extern int sys_setgid();extern int sys_getgid();extern int sys_signal();extern int sys_geteuid();extern int sys_getegid();extern int sys_acct();extern int sys_phys();extern int sys_lock();extern int sys_ioctl();extern int sys_fcntl();extern int sys_mpx();extern int sys_setpgid();extern int sys_ulimit();extern int sys_uname();extern int sys_umask();extern int sys_chroot();extern int sys_ustat();extern int sys_dup2();extern int sys_getppid();extern int sys_getpgrp();extern int sys_setsid();extern int sys_sigaction();extern int sys_sgetmask();extern int sys_ssetmask();extern int sys_setreuid();extern int sys_setregid();</code></pre><blockquote></blockquote><pre><code>extern int sys_iam();//需要新增的地方extern int sys_whoami();</code></pre><blockquote></blockquote><pre><code>fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid,sys_setregid, sys_iam, sys_whoami };//记得在中断向量表的最后填上系统调用</code></pre><blockquote></blockquote><p>(5).在include/unistd.h中定义sys_iam和sys_whoami的函数系统调用号。<br><br><strong>注意：unistd.h不能直接在oslab中修改</strong>，需要运行<br></p><blockquote></blockquote><p><code>sudo ./mount-hdc</code><br><br>把虚拟机硬盘挂载在oslab/hdc目录下，在hdc/usr/include目录中修改unistd.h。<br><br>至于为什么要这么做自己也没搞懂。</p><blockquote></blockquote><pre><code>#define __NR_setup    0   /* used only by init, to get system going */#define __NR_exit    1#define __NR_fork    2#define __NR_read    3#define __NR_write    4#define __NR_open    5#define __NR_close    6#define __NR_waitpid    7#define __NR_creat    8#define __NR_link    9#define __NR_unlink    10#define __NR_execve    11#define __NR_chdir    12#define __NR_time    13#define __NR_mknod    14#define __NR_chmod    15#define __NR_chown    16#define __NR_break    17#define __NR_stat    18#define __NR_lseek    19#define __NR_getpid    20#define __NR_mount    21#define __NR_umount    22#define __NR_setuid    23#define __NR_getuid    24#define __NR_stime    25#define __NR_ptrace    26#define __NR_alarm    27#define __NR_fstat    28#define __NR_pause    29#define __NR_utime    30#define __NR_stty    31#define __NR_gtty    32#define __NR_access    33#define __NR_nice    34#define __NR_ftime    35#define __NR_sync    36#define __NR_kill    37#define __NR_rename    38#define __NR_mkdir    39#define __NR_rmdir    40#define __NR_dup    41#define __NR_pipe    42#define __NR_times    43#define __NR_prof    44#define __NR_brk    45#define __NR_setgid    46#define __NR_getgid    47#define __NR_signal    48#define __NR_geteuid    49#define __NR_getegid    50#define __NR_acct    51#define __NR_phys    52#define __NR_lock    53#define __NR_ioctl    54#define __NR_fcntl    55#define __NR_mpx    56#define __NR_setpgid    57#define __NR_ulimit    58#define __NR_uname    59#define __NR_umask    60#define __NR_chroot    61#define __NR_ustat    62#define __NR_dup2    63#define __NR_getppid    64#define __NR_getpgrp    65#define __NR_setsid    66#define __NR_sigaction    67#define __NR_sgetmask    68#define __NR_ssetmask    69#define __NR_setreuid    70#define __NR_setregid    71   /*Linux system_call total 72*/#define __NR_iam    72     /*new system_call 72 and 73*/#define __NR_whoami    73</code></pre><p>(6).修改kernel/systeam_call.s中代表系统调用总个数的变量 nr_systeam_calls的值（原值是72，改为74）<br></p><blockquote></blockquote><pre><code>sa_handler = 0sa_mask = 4sa_flags = 8sa_restorer = 12nr_system_calls = 74</code></pre><p>(7).自此大功告成，cd 进入oslab中执行 ./run运行系统，<br>在boch中编译iam.c和whoam.c。</p><blockquote></blockquote><pre><code>gcc -o iam iam.c gcc -o whoami whoami.c </code></pre><p>运行./iam 和 ./whoami 。</p>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>系统调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的常用指令</title>
    <link href="undefined2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h1><blockquote><p>hexo n “我的博客” == hexo new “我的博客” —–&gt;新建文章<br><br>hexo p == hexo publish <br><br>hexo g == hexo generate —-&gt;生成<br><br>hexo s == hexo server —–&gt; 启动服务预览<br><br>hexo d == hexo deploy —–&gt;部署到博客上<br></p></blockquote><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><blockquote><p>hexo clean —&gt;清除缓存<br><br>hexo g —-&gt;生成静态网页<br><br>hexo d —-&gt;开始部署<br></p></blockquote><h1 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h1><blockquote><p>hexo generate –watch –&gt;监视文件变动</p></blockquote><h1 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h1><blockquote><p>hexo generate –deploy == hexo g -d<br><br>hexo deploy –generate == hexo d -g<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>