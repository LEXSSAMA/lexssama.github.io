<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>bootsect.s源码分析</title>
    <link href="undefined2019/11/17/bootsect-s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>2019/11/17/bootsect-s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本博客大部分搬运于《Linux内核完全注释》赵烔编著，小部分增加一些自己阅读源码过程中遇到问题的解答。<br><br>目的是：希望在自己搬运的过程中，可以加深对Linux-0.11内核的理解和印象。<br><br>感谢：<a href="https://blog.csdn.net/longintchar/article/details/79323783" target="_blank" rel="noopener">https://blog.csdn.net/longintchar/article/details/79323783</a><br><a href="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md" target="_blank" rel="noopener" title="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md">https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md</a></p><h1 id="Bootsect-s"><a href="#Bootsect-s" class="headerlink" title="Bootsect.s"></a>Bootsect.s</h1><p>bootsect.s代码时磁盘引导块程序，驻留在磁盘的第一个扇区中（引导扇区，0磁道（柱面），0磁头，第一个扇区）。在PC机加电ROM BIOS自检后，引导扇区由BIOS加载到内存，0x7C00处，然后将自己移动到内存0x90000处，该程序的主要作用是首先将setup模块（由setup.s编译成），从磁盘加载到内存，紧接在bootsect的后面位（0x90200），然后利用BIOS中断0x13取磁盘参数表中当前启动引导盘的参数，接着在屏幕上显示“Loading system…”字符串，再将system模块从磁盘上加载到内存0x10000开始的地方，随后确定根文件系统的设备号，若没有指定，则根据所保存的引导盘的每磁道扇区数判别出盘的类型和种类（是1.44MB的A盘？）并保存其设备号于root_dev（引导块的508地址处），最后长跳到setup程序的开始处（0x90200）执行setup程序。<br></p><pre><code>SYSSIZE = 0x3000  ;system模块的长度.globl begtext, begdata, begbss, endtext, enddata, endbss.textbegtext:.databegdata:.bssbegbss:.textSETUPLEN = 4                ! setup模块的长度，4个扇区BOOTSEG  = 0x07c0           ! original address of boot-sectorINITSEG  = 0x9000           ! bootsect把自身搬运到0x90000SETUPSEG = 0x9020           ! setup模块被加载到 0x90200SYSSEG   = 0x1000           ! system模块被加载到0x10000ENDSEG   = SYSSEG + SYSSIZE ! where to stop loading, 0x1000 + 0x3000 = 0x4000, 停止加载的段地址(加载system模块时使用)ROOT_DEV = 0x306            !第2个硬盘的第1个分区   !这里开始把bootsect.s程序复制到0x90000去。entry _start_start:    mov ax,#BOOTSEG     mov ds,ax      !ds = 0x07c0    mov ax,#INITSEG    mov es,ax      !ex = 0x9000    mov cx,#256    !搬运256次    sub si,si      !si = 0    sub di,di      !di = 0                   !ds:si=0x07c0:0x0, es:di=0x9000:0x0    rep    movw           !每次搬运2个字节    jmpi go,INITSEG   !跳转到 0x9000:go （jmpi是段内跳转指令跳转目的地是INITSEG:go）  ! 这里开始设置栈，为的是待会装入setup程序go: mov ax,cs    mov ds,ax    mov es,ax     !ds=es=cs=0x9000    mov ss,ax    mov sp,#0xFF00                    !es:sp = 0x9000:0xff00 ，栈的设置    ! dx，cx，bx，ax都是传递给in0x13中断服务程序的参数load_setup:    mov dx,#0x0000      ! 驱动器号(DL)0，磁头号(DH)0    mov cx,#0x0002      ! 起始扇区号CL=2, 磁道号（柱面号），CH=0    mov bx,#0x0200      ! 偏移地址0x200,(setup程序读入的开始地址es：bx，es在上面程序已经设置成0x9000，所以就是将setup程序读到0x90200处)    mov ax,#0x0200+SETUPLEN ! 功能号AH=0x02,AL=要读的扇区数目=SETUPLEN=4 （in0x13的AH=0x02的中断服务程序功能是读软盘或硬盘上的若干物理扇区到内存的ES:BX处）    int 0x13            ! read it（当载入出现错误则把CF置成1，把出错的代码位置送到AH，返回实际读到的扇区数给AL）    jnc ok_load_setup   ! ok - continue（如果CF（进位标志）=0，则跳转，因为上面中断服务程序如果出错就把CF置为1,CF=0代表没有出错则跳转）    ! 如果上面载入出错则执行这一步    mov dx,#0x0000      !需要复位的驱动器号=DL=0    mov ax,#0x0000      !功能号AH=0（int0x13的AH=0，执行中断服务程序中的复位程序）    int 0x13            ! 复位磁盘    j   load_setup    !如果没有出错则跳到这一步执行,这一步的目的主要是把一些磁盘信息存入到0x90000处。ok_load_setup:! Get disk drive parameters, specifically nr of sectors/track    mov dl,#0x00    !驱动器号为0，说明是软盘    mov ax,#0x0800  ! AH=8 is get drive parameters（INT 13H AH=08H：读取驱动器参数）    int 0x13    mov ch,#0x00    !这里用不上软盘的最大磁道号，可以使CH=0    seg cs          !把段超越前缀设置为cs,（段超越指的是把默认的段地址寄存器改成自己希望的段地址寄存器）只影响下一条语句    mov sectors,cx  ! 把cx寄存器中的内容装入cs:[sectors]处。（sectors在后面有定义）    !保存每磁道最大扇区数。对于软盘，最大磁道号不会超过256，所以CH足以表示，CL[7:6]为0    mov ax,#INITSEG    mov es,ax       !因为上面ES的值被修改，所以令ES=0x9000    mov ah,#0x03    !读光标的位置    xor bh,bh       !bh=页号    int 0x10        ! INT 10H AH=03H：获取光标位置和形状    mov cx,#24          ! 24个字符    mov bx,#0x0007      ! page 0, attribute 7 (normal)    mov bp,#msg1        ! 在代码后面有定义    mov ax,#0x1301      ! write string, move cursor    int 0x10 ! ok, we&#39;ve written the message, now ! # we want to load the system (at 10000h)  现在开始将system 模块加载到10000h(64k)处。    mov    ax,SYSSEG    mov    es,ax        ;! segment of 010000h  es = 存放system的段地址。    call read_it            ; !读磁盘上system模块，es为输入参数。    call kill_motor        ;! 关闭驱动器马达，这样就可以知道驱动器的状态了。 !call read_it时程序跳到下面read_it处执行!call kill_motor时程序跳到kill_motor处执行!此后，我们检查要使用哪个根文件系统设备（简称根设备）。如果已经指定了设备（!=0）! 就直接使用给定的设备。否则就需要根据BIOS报告的每磁道扇区数来! 确定到底使用/dev/PS0(2,28)还是/dev/at0(2,8)。!        上面一行中两个设备文件的含义：!        在Linux中软驱的主设备号是2（参加第43行注释），次设备号 = type*4 + nr, 其中!        nr为0－3分别对应软驱A、B、C或D；type是软驱的类型（2-&gt;1.2M或7-&gt;1.44M等）。!        因为7*4 + 0 = 28，所以/dev/PS0(2,28)指的是1.44M A驱动器，其设备号是021c!    同理 /dev/at0(2,8)指的是1.2M A驱动器，其设备号是0208。    seg cs    mov    ax,root_dev    cmp ax,#0    jne    root_defined    ! 如果 ax != 0, 转到root_defined    seg cs    mov    bx,sectors        !取上面保存的每磁道扇区数。如果sectors=15                        !则说明是1.2Mb的驱动器；如果sectors=18，则说明是                        ! 1.44Mb软驱。因为是可引导的驱动器，所以肯定是A驱。    mov    ax,#0x0208        ! /dev/ps0 - 1.2Mb    cmp bx,#15            ! 判断每磁道扇区数是否=15    je    root_defined    !如果等于，则ax中就是引导驱动器的设备号。    mov    ax,#0x021c            ! /dev/PS0 - 1.44Mb    cmp     bx,#18    je    root_definedundef_root:                ! 如果都不一样，则死循环（死机）。    jmp undef_rootroot_defined:    seg cs    mov    root_dev,ax        ! 将检查过的设备号保存起来。! 到此，所有程序都加载完毕，我们就跳转到被! 加载在bootsect后面的setup程序去。    jmpi    0,SETUPSEG        !跳转到9020:0000（setup程序的开始处）。sread:  .word 1+SETUPLEN !当前磁道已经读取的扇区数, 前面的1表示引导扇区bootsect.shead:   .word 0          ! current head，当前磁头号track:  .word 0          ! current track，当前磁道号read_it:    mov ax,es    test ax,#0x0fff     !使ax与0xfff按位与，测试es是否为0x1000的整数倍die:    jne die         !结果不为0（说明es不是0x1000的整数倍）则陷入死循环    xor bx,bx           ! bx（作为段内偏移地址）清零rp_read:    mov ax,es    cmp ax,#ENDSEG      ! 实际上求(ax-ENDSEG)    jb ok1_read         ! 当CF=1（ax&lt;ENDSEG, 有借位）时跳转到ok1_read    ret                 ! 当ax&gt;=ENDSEG时返回（我认为不会出现大于的情况）ok1_read:    seg cs    mov ax,sectors      ! 这两句相当于 mov ax, cs:[sectors]; 获得每磁道扇区数    sub ax,sread        ! ax = ax - sread, 得出本磁道未读扇区数    mov cx,ax    shl cx,#9           ! cx乘以512，求出字节数    add cx,bx           ! 以上3行相当于 cx = ax * 512 + bx                        ! 假设再读ax个扇区，cx就是段内共读入的字节数    jnc ok2_read        ! 若cx &lt; 0x10000（CF=0,没有进位）则跳转到ok2_read    je ok2_read         ! 若cx = 0（ZF=1），说明刚好读入64KB，则跳转到ok2_read    xor ax,ax            ! ax = 0x0000    sub ax,bx            ! 求bx对0x10000的补数，结果在ax中    shr ax,#9            ! 除以512,得到扇区数，AL作为参数，传给read_trackok2_read:                   call read_track  ！调用read_track过程，用AL传参,读取AL个扇区到ES:BX    mov cx,ax        ！cx是该次操作已经读取的扇区数    add ax,sread     ！ax是当前磁道已经读取的扇区数    seg cs    cmp ax,sectors       jne ok3_read     ！如果当前磁道还有扇区未读，跳转到ok3_read    mov ax,#1        ！说明当前磁道的扇区都已读完    sub ax,head      ！ax = 1 - 磁头号    jne ok4_read     ！不为0则跳转到 ok4_read，说明磁头号为0    inc track        ！说明磁头号为1，磁道号增加1ok4_read:    mov head,ax  !更新磁头号（如果是37行跳转过来，则 head=1；否则 head=0）    xor ax,ax    !ax=0, 因为更换了磁道，所以当前磁道已读扇区数置0ok3_read:    mov sread,ax      ！更新当前磁道已经读取的扇区数    shl cx,#9           ! ok2_read处有更新cx。    add bx,cx         ！更新偏移地址    jnc rp_read       ！没有进位，则跳转到rp_read    mov ax,es         ！有进位，说明BX达到了64KB边界    add ax,#0x1000        mov es,ax         ！es增加0x1000    xor bx,bx         ！bx = 0    jmp rp_read       ！继续读取! 读当前磁道上指定开始扇区和需读扇区数的数据到es:bx开始处。! al － 需读扇区数； es:bx － 缓冲区开始位置。read_track:    push ax    push bx    push cx    push dx!dx,cx,ax都是传给中断服务程序的参数。    mov dx,track        !取当前磁道号。（磁道号其实存在低8位也就是dl的位置，dh都为0）    mov cx,sread        ! 取当前磁道上已读扇区数。（已读扇区不会超过255所以已读扇区号其实存在cl，ch都为0）    inc cx                ! cl = 开始读扇区号，inc为加一指令。    mov ch,dl            ! ch = 当前磁道号（用ch来存当前的磁道号）。    mov dx,head            ! 取当前磁头号。（同理磁头号也不可能超出255所以磁头号这时实际上时存在dl中，dh为0）    mov dh,dl            ! dh = 磁头号。（把磁头号放到dh上，dl在下面改为驱动器号）    mov dl,#0            ! dl = 驱动器号（为0表示当前驱动器）。    and dx,#0x0100        ! 磁头号不大于1    mov ah,#2            ! ah = 2, 读磁盘扇区功能号。    int 0x13    jc bad_rt            ! 若出错，则跳转至bad_rt。    pop dx    pop cx    pop bx    pop ax    ret! 执行驱动器复位操作（磁盘中断功能号0），再跳转到read_track处重试。bad_rt:        mov ax,#0    mov dx,#0    int 0x13（磁盘复位中断程序）    pop dx    pop cx    pop bx    pop ax    jmp read_trackkill_motor:    push dx    mov dx,# 0x3f2！ 软驱控制卡的驱动端口，只写。    mov al,#0            ! A驱动器，关闭FDC，禁止DMA和中断请求，关闭马达。    outb        ! 将al中的内容输出到dx指定的端口去。outb:I/O端口操作函数,I/O 上写入 8 位数据 ( 1 字节 )；    pop dx    retsectors:             .word 0                ! 存放当前启动软盘每磁道的扇区数。msg1:.byte 13,10            ! 回车、换行的ASCII码。     .ascll &quot;Loading my system ...&quot;! 我加了my，共有27个字符了     byte 13,10,13,10    ! 共24个ASCII码字符。org 508:        ! 表示下面语句从地址508(1FC)开始，所以root_dev            ！ 在启动扇区的第508开始的2个字节中。root_dev          .word  ROOT_DEV    ！ 这里存放根文件系统所在的设备号（init/main.c中会用）。boot_flag ：            .word  0xAA55h        ！ 硬盘有效标识。.text endtext：.dataenddata.bssendbss:</code></pre><p><img src="https://i.imgur.com/GKftX8i.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bootsect.s</title>
    <link href="undefined2019/11/16/bootsect-s/"/>
    <url>2019/11/16/bootsect-s/</url>
    
    <content type="html"><![CDATA[<h1 id="阅读bootsect-s源码时遇到的问题记录和解决"><a href="#阅读bootsect-s源码时遇到的问题记录和解决" class="headerlink" title="阅读bootsect.s源码时遇到的问题记录和解决"></a>阅读bootsect.s源码时遇到的问题记录和解决</h1><p>1.<br><code>56.  jmpi   go，INITSEG</code><br><br>jmpi指令是段内跳转指令，跳转的目的地是INITSEG:go,这句话的意思是跳到INITSEG处偏移地址为go处的指令执行。</p><p>2.<br>bootsect.s中用到的各种中断<br></p><pre><code>INT 0x10, AH = 1 -- set up the cursorINT 0x10, AH = 3 -- cursor positionINT 0x10, AH = 0xE -- display charINT 0x10, AH = 0xF -- get video page and modeINT 0x10, AH = 0x11 -- set 8x8 fontINT 0x10, AH = 0x12 -- detect EGA/VGAINT 0x10, AH = 0x13 -- display stringINT 0x10, AH = 0x1200 -- Alternate print screenINT 0x10, AH = 0x1201 -- turn off cursor emulationINT 0x10, AX = 0x4F00 -- video memory sizeINT 0x10, AX = 0x4F01 -- VESA get mode information callINT 0x10, AX = 0x4F02 -- select VESA video modesINT 0x10, AX = 0x4F0A -- VESA 2.0 protected mode interfaceINT 0x11 -- Hardware detection(see ATA using BIOS for more detail on these BIOS function calls)INT 0x13, AH = 0 -- reset floppy/hard diskINT 0x13, AH = 2 -- read floppy/hard disk in CHS modeINT 0x13, AH = 3 -- write floppy/hard disk in CHS modeINT 0x13, AH = 0x15 -- detect second diskINT 0x13, AH = 0x41 -- test existence of INT 13 extensionsINT 0x13, AH = 0x42 -- read hard disk in LBA modeINT 0x13, AH = 0x43 -- write hard disk in LBA mode(see Detecting Memory (x86) for more detail on these BIOS function calls)INT 0x12 -- get low memory sizeINT 0x15, EAX = 0xE820 -- get complete memory mapINT 0x15, AX = 0xE801 -- get contiguous memory sizeINT 0x15, AX = 0xE881 -- get contiguous memory sizeINT 0x15, AH = 0x88 -- get contiguous memory sizeINT 0x15, AH = 0xC0 -- Detect MCA busINT 0x15, AX = 0x0530 -- Detect APM BIOSINT 0x15, AH = 0x5300 -- APM detectINT 0x15, AX = 0x5303 -- APM connect using 32 bitINT 0x15, AX = 0x5304 -- APM disconnectINT 0x16, AH = 0 -- read keyboard scancode (blocking)INT 0x16, AH = 1 -- read keyboard scancode (non-blocking)INT 0x16, AH = 3 -- keyboard repeat rate</code></pre><br>![](https://i.imgur.com/USbgQLK.png)<br><p>3.<code>87.  seg cs</code> <br><br>seg是段超越指令，某些时候你不想使用默认的段地址寄存器，那么你可以强制指定一个段地址寄存器（这里强制指定段地址寄存器为CS）。<br><br>默认的段寄存器是：<br><br>CS：IP<br><br>DS：SI<br><br>ES：DI <br><br>SS:SP<br><br>而且seg指令能影响的只有下一条指令，也就是说seg只能把下一条指令中的默认段寄存器改为自己指定的段寄存器。<br></p><p>4.<code>147. sread :   .word1+SETUPLEN</code> <br><br>sread 是一个标号，处理到sread时，ASM会把1+SETUPLEN的值按16bit放在此标号中。<br><br>.word就是在这个地方放一个值，相当于在这里定义了一个数据变量，用.word定义的是16bit的数据<br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bootsect.s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常控制流</title>
    <link href="undefined2019/11/11/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>2019/11/11/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p><strong>教材：《计算机系统基础》，本博客主要用来梳理学习思路。（不然会很乱）</strong></p><h1 id="7-1-进程与进程的上下文切换"><a href="#7-1-进程与进程的上下文切换" class="headerlink" title="7.1 进程与进程的上下文切换"></a>7.1 进程与进程的上下文切换</h1><h2 id="7-1-1-程序与进程的概念"><a href="#7-1-1-程序与进程的概念" class="headerlink" title="7.1.1 程序与进程的概念"></a>7.1.1 程序与进程的概念</h2><p><strong>程序：</strong>程序就是代码与数据的集合，程序的代码是一个机器指令序列，因而程序是一种静态的概念，它作为目标模块存放在磁盘中，或者作为一个存储段存在一个地址空间中。<br><br><strong>进程：</strong>进程就是程序的一次运行过程（进程具有动态的含义），计算机处理的所有任务实际上是由进程完成的。<br><br><strong>计算机系统中的任务通常是指进程，例如Linux内核中把进程称为任务，每个进程主要通过一个称为进程描述符的结构来描述，其结构类型定义为task_structure，包括了一个进程的所有信息，所有进程通过一个双向循环环链表实现的任务列表（task list）来描述，任务列表中的每个元素是一个进程描述符，IA-32中的任务状态段（TSS），任务门（task gate）等概念中所称的任务，实际上也是指进程。<br></strong></p><p><strong>进程的引入为应用程序提供了以下两个方面的抽象：一个独立的逻辑控制流和一个私有的虚拟地址空间。每个进程拥有一个独立的逻辑控制流使得程序员以为自己的程序在执行过程中独占使用处理器，每个进程拥有一个私有的虚拟地址空间，使得程序员以为自己的程序在执行过程中独占存储器。<br></strong></p><h2 id="7-1-2-进程的逻辑控制流"><a href="#7-1-2-进程的逻辑控制流" class="headerlink" title="7.1.2 进程的逻辑控制流"></a>7.1.2 进程的逻辑控制流</h2><p><strong>逻辑控制流：</strong>指令的执行过程中，会形成一个指令执行的地址序列，对于确定的输入数据，其指令执行的地址序列也是确定的，这个确定的指令执行地址序列称为逻辑控制流.（<strong>不知道定义在说些什么直接上图</strong>）<br><img src="https://i.imgur.com/vJTH0zM.png" srcset="/img/loading.gif" alt><br><br><strong>进程p1的逻辑控制流是：A<sub>11</sub><del>A<sub>13</sub>,A<sub>11</sub></del>A<sub>14</sub>,A<sub>15</sub>~A<sub>16</sub>。（其他进程同理）<br></strong><br><strong>并发：</strong>不同进程的逻辑控制流在时间上交错或者重叠的情况称为并发。<br><br><strong>并行：</strong>我们称两个同时执行的进程的逻辑控制流是并行的。<br><br><strong>并行是并发的一个特例。</strong></p><h2 id="7-1-3-进程的上下文切换"><a href="#7-1-3-进程的上下文切换" class="headerlink" title="7.1.3 进程的上下文切换"></a>7.1.3 进程的上下文切换</h2><p><strong>上下文切换：</strong> 操作系统通过处理器让处理器轮流执行多个进程，实现不同进程中指令交替执行的机制称为进程的上下文切换。<br><br><strong>进程的上下文：</strong> 进程的物理实体（代码和数据）和支持进程运行的环境合称进程的上下文。<br><br><strong>进程的上下文包括：用户级上下文和系统级上下文。</strong><br><br><img src="https://i.imgur.com/b9nyp7P.png" srcset="/img/loading.gif" alt><br><br><strong>系统级上下文和用户级上下文包括的内容如上图所示<br><br>进程的控制信息包括各种内核数据结构，例如记录有关进程信息表，页表，打开文件列表等。（具体如下图所示）</strong><br><img src="https://i.imgur.com/kMOm5Jn.png" srcset="/img/loading.gif" alt><br><br><strong>寄存器上下文：</strong>处理器中各个寄存器的内容被称为寄存器上下文。<br></p><p>**上下文切换发生在操作系统调度一个新进程到处理器运行时，需要完成三件事：<br></p><ol><li>将当前处理器的寄存器上下文保存在当前进程的系统上下文的现场信息中；<br></li><li>将新进程系统上下文中的现场信息作为新的就寄存器上下文恢复到处理器的各个寄存器中；</li><li>将控制转移到新进程执行。这里，一个重要的上下文信息是PC的值，当前进程被打断的断点处的PC作为寄存器上下文的一部分被保存在进程现场信息中，这样，下次该进程再次被调度到处理器上执行时，就可以从现场信息中获得断点处的PC，从而能从断点处开始执行。<br>**</li></ol><p><img src="https://i.imgur.com/fIhPaLr.png" srcset="/img/loading.gif" alt><br></p><p>从上图可以看出，<strong>在一个进程的整个生命周期中，可能会有其他不同的进程在处理器中交替运行</strong>，例如上图给出了上述shell命令行执行过程中shell进程与hello进程上下文切换过程，首先运行shell进程，从shell命令行中读入字符串“./hello”到主存；当shell进程读到字符“[Enter]”后，shell进程将通过系统调用从用户态转到内核态执行，由操作系统内核程序进行上下文切换，以保存shell进程的上下文并创建hello进程的上下文，hello进程结束后，再转到操作系统完成控制权从hello进程回到shell进程的切换。<br></p><h2 id="7-1-4进程的存储器映射"><a href="#7-1-4进程的存储器映射" class="headerlink" title="7.1.4进程的存储器映射"></a>7.1.4进程的存储器映射</h2><p>以Linux系统为例，对进程的存储器映射进行介绍，进程的存储器映射，是指将进程的虚拟地址空间的一个区域或者硬盘上的对象建立关联，已初始化一个vm_area_struct结构中的信息，使用mmap（）函数实现存储器的映射并通过缺页中断处理进行读写操作。(<strong>虚拟地址空间和硬盘建立关联后，以后CPU运行程序的时候就是通过虚拟地址来存取指令和数据，CPU给出虚拟地址后由MMU来把虚拟地址变为线性地址（分段方式）,再由线性地址转化为物理地址（分页方式），这就与第六章联系起来</strong>)<br></p><h3 id="lt-1-gt-mmap函数的功能"><a href="#lt-1-gt-mmap函数的功能" class="headerlink" title="&lt;1&gt;.mmap函数的功能"></a>&lt;1&gt;.mmap函数的功能</h3><p><code>void* mmap(void* start ,size\_t length ,int flags, int fd,off_t offset)</code><br><br>若该函数的返回值式-1（MAP_FAILED），则表示出错；否则，返回值为指向映射区域的指针。该函数的功能是，将指向文件fd中偏移量offset开始的长度为length字节的一块信息，映射到虚拟地址空间中起始位置为start，长度为length字节的一块区域。<br></p><p><img src="https://i.imgur.com/eaNZfe8.png" srcset="/img/loading.gif" alt><br><br>参数prot指定该区域页面的访问权限，对应vm_area_struct结构中的vm_prot字段，可能的取值包括以下几种：<br></p><ol><li>PROT_EXE：区域内页面由可执行指令组成<br></li><li>PROT_READ：区域内容可读<br></li><li>PROT_WRITE：区域内容可读可写<br></li><li>PROT_NONE：区域内容不可被访问<br><br>参数flags指定该区域映射对象的类型，对应vm_area_struct结构中的vm_flags字段，可能的取值包括以下两种：<br></li><li>普通文件：最典型的是可执行文件和共享库文件，通常映射到只读代码区域（.init .text .rodata）和已初始化数据区域（.data）的对象再可执行文件中，这些对象都属于私有对象，采用写时拷贝的技术映射到虚拟地址空间，所映射到的区域称为私有区域，对应对象称为私有的写时拷贝对象，此时参数flags设置为MAP_PRIVATE；映射到共享库区域的对象在共享库文件中，这些对象都属于共享对象，所映射的区域称为共享区域，此时flags设置为MAP_SHARED。<br><br>CPU<strong>第一次访问</strong>对应虚拟页面时，内核在主存中找到一个空闲页框（没有则淘汰一个），然后从硬盘上的文件装入所映射的对象信息，如果文件中的对象不是正好为页面大小的整数倍，内核将用零来填充余下的部分。<br></li></ol><p>2.匿名文件：由内核创建，全部由0组成，对应区域中的每个虚拟页面称为<strong>请求零的页面</strong>。参数flags设置为MAP_ANON。通常未初始化数据区（.bss），运行时堆和用户栈等区域中都为私有的，请求零的页，此时flags设置为MAP_PRIVATE | MAP_ANON。<br></p><h3 id="lt-2-gt-共享对象和私有的写时拷贝对象"><a href="#lt-2-gt-共享对象和私有的写时拷贝对象" class="headerlink" title="&lt;2&gt;.共享对象和私有的写时拷贝对象"></a>&lt;2&gt;.共享对象和私有的写时拷贝对象</h3><p><strong>共享库的动态链接具有共享性，其优点是：虽然由很多进程都调用共享库中的代码（例如 printf（）），但是共享库代码段在内存和硬盘中都由一个副本。</strong><br><br>那么问题来了,怎么实现一个共享库副本由多个进程共享呢？答案是：通过存储器映射机制来实现。<br><br><img src="https://i.imgur.com/NMtcu18.png" srcset="/img/loading.gif" alt><br><br><strong>映射过程：</strong><br><br><strong>因为共享对象在硬盘上只有一个副本，也即对应的共享库文件名是唯一的，（如上图）所以内核可以判断出进程1已经在主存给共享对象分配了页框，因而进程2的加载运行过程中，内核只要将进程2对应区域内页表项中的页框号直接填上即可。在多个进程共享同一个共享对象时，在主存中仅保存一个副本，每个进程在访问各自的共享区域时，实际上都在同一个对应页框中存取信息，因此，一个进程共享区域进行写操作结果，对于所有共享一个共享对象的进程都是可见的，而且结果也会反映在硬盘上对应的共享对象中。<br></strong></p><p><strong>私有的写时拷贝对象（A）有点像共享对象（B）（A也是像B一样，相同的代码或者数据共用主存页框不过对应的是私有对象，但是A在需要修改页框内数据时会生成一个私有的写时拷贝页，不会影响其他进程，写回硬盘时也仅仅只会修改对应进程的文件，不会影响其他进程。)<br></strong><br>具体如下说明：<br><br>一个可执行文件被多次加载执行以形成不同的进程，因而系统中多个进程可能由同样的只读代码区域和可读可写数据区域，也即不同进程的区域可能会映射到同一个对象。与共享库文件中的共享文件不同，可执行文件中的对象是私有的，映射到的是进程的私有区域，因此在这种私有区域中写操作结果，对于其他进程是不可见的，也不会反映在对于的硬盘对象中。要实现这种功能，内核可以为不同进程中对于区域的虚拟页主存中分配各自独立的页框。但是这会浪费很多空间。<br></p><p>为了解决这个问题就有了私有对象的写时拷贝技术。</p><p><strong>具体做法是：</strong><br><br>假设可执行文件a.out对应的两个进程在系统中并发执行，先启动的进程1会将a.out中私有对象映射到自己的VM用户空间区域中，<strong>内核将这些区域中的页面标记为私有的写时拷贝页，并将对应页表项中的访问权限标记为只读</strong>，在进程1运行过程中，内核为这个私有对象在主存中分配了若干页框，同样，后启动的进程2也会将a.out中的私有对象映射到自己的VM用户空间区域中，标记对应页面为私有的写时拷贝页和只读访问权限，并使页表项中的页框号与进程1的页框号相同，如下图所示，如果两个进程都没进行写操作，例如只读代码区就不会发生写操作，那么该区域中的虚拟页在主存中就只有一个副本，可以节省主存空间。<br><img src="https://i.imgur.com/3wn4nrh.png" srcset="/img/loading.gif" alt><br></p><p>若进程2对私有的写时拷贝页面（例如，可读可写数据区域所在页面）发生了写操作，那么就与只读访问权限不符合，发生保护异常，内核就会进行页故障处理，在处理过程中，内核判断出保护异常时由于进程试图对私有的写时拷贝页面进行写操作造成的，此时，内核就会在主存中为这个页面分配一个新页框（如下图所示），把页面的内容拷贝到新页框中，并修改进程2中对应的页表项，填入新分配的页框号，将访问权限改成可读可写，页故障处理完后回到发生故障的指令重新执行，此时进程2就可以正常执行写操作了，写时拷贝技术通常延迟拷贝私有对象所在页面，使得主存物理地址得到最充分的使用。<br><br><img src="https://i.imgur.com/LnVFAfz.png" srcset="/img/loading.gif" alt><br></p><h3 id="7-1-5程序的加载和启动"><a href="#7-1-5程序的加载和启动" class="headerlink" title="7.1.5程序的加载和启动"></a>7.1.5程序的加载和启动</h3><p>启动一个可执行目标文件时，首先会通过某种方式调出加载器（loader）的操作系统程序来处理，在Linux/UNIX系统中通过调用execve（）函数来启动加载器。<br><br>execve()函数的功能是在当前进程的上下文加载并运行一个新的程序<br></p><p><code>int execve(char* filename,char *argv[],*envp[])</code><br></p><p>filename是加载并运行的可执行文件名(如./hello)，可带参数列表 argv和环境变量列表envp。若错误（如找不到指定文件filename） ，则返回-1，并将控制权交给调用程序； 若函数执行成功，则不返回 ，而是将PC（EIP）设定指向EIF头中定义的入口点Entry Point(即符号_start处)。符号\start在启动例程crtl.o中定义，每个C程序都一样。<br><br>符号_start处定义的启动代码主要是一系列过程调用，首先依次调用_libe_init_file和_init两个初始化过程；随后通过调用atexit（）对程序正常结束时需要调用的函数进行登记注册，这些函数被称为终止处理函数；然后，再调用可执行目标中的主函数main（）；最后调用_exit（）过程，以结束进程的执行，返回操作系统内核。<br></p><p><strong>因此启动代码的调用过程为_libe_init_file—-&gt;_init—-&gt;atexit（）—–&gt;main（）—-&gt;_exit（）。</strong></p><p>主函数main（）的原型<br><br><code>int main(int argc, char **argv, char **envp);</code><br><br><code>int main(int argc, char *argv[], char *envp[f]);</code><br><br><img src="https://i.imgur.com/CvC1omZ.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/Ovzj3At.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/d8YR9sb.png" srcset="/img/loading.gif" alt><br><br><img src="https://i.imgur.com/199tIah.png" srcset="/img/loading.gif" alt><br><br><strong>最后运行新程序main()函数的用户栈如下图：</strong><br><br><img src="https://i.imgur.com/JCnItEa.png" srcset="/img/loading.gif" alt><br><br>关于main（）函数参数的问题可以看这篇文章<br><a href="https://lexssama.github.io/2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">C++ main函数中参数argc和argv含义以及用法</a><br></p><h1 id="7-2-异常和中断"><a href="#7-2-异常和中断" class="headerlink" title="7.2 异常和中断"></a>7.2 异常和中断</h1><h2 id="7-2-1-基本概念"><a href="#7-2-1-基本概念" class="headerlink" title="7.2.1 基本概念"></a>7.2.1 基本概念</h2><p>从80286开始，Intel统一把“内中断”称为异常，“外中断”称为中断。<br><br>异常和中断的例子：<br><br><strong>异常：</strong><br><br>内部“异常”：再CPU内部发生的意外或者特殊事件：<br><br>按发生原因分为<strong>硬故障中断</strong> 和 <strong>程序性中断</strong>两类<br><br>硬故障中断：电源断电，硬件故障等<br><br>程序性中断：执行某条指令时发生的例外事件：如溢出，缺页，越界，越权，越级，非法指令，除数为0，堆/栈溢出，访问超时，断点设置，单步，系统调用等。<br></p><p>外部“中断”：在CPU外部发生的特殊事件，通过“中断请求”信号向CPU请求处理，如实时钟，控制台，打印机缺纸，采样计时到，DMA传输结束等。<br></p><h2 id="7-2-2-异常的分类"><a href="#7-2-2-异常的分类" class="headerlink" title="7.2.2 异常的分类"></a>7.2.2 异常的分类</h2><p><strong>异常被分为三类：故障（fault），陷阱（Trap），和终止（abort）。</strong><br></p><h3 id="lt-1-gt-故障"><a href="#lt-1-gt-故障" class="headerlink" title="&lt;1&gt;.故障"></a>&lt;1&gt;.故障</h3><p>故障是引起故障的指令在执行过程中CPU检测到一类与指令执行相关的意外事件，这种意外事件有的可以恢复，有的则不能恢复。<br><br><strong>溢出的情况：</strong><br><br>对于像是溢出和非法操作码等这类故障，因为无法通过异常处理程序恢复，所以不能回到中断的程序继续执行，通常异常处理程序程序在屏幕上显示一个对话框告知发生了某种故障，然后调用内核中的abort例程，以终止发生故障的当前进程。<br><br><strong>除数为0的情况：</strong><br><br>根据定点除法指令还是浮点除法指令有不同的处理方式，对于浮点数除0，异常处理程序可以选择将指令执行结果用特殊值（如∞或者NaN）表示，然后返回到用户进程继续执行除法指令后面的一条指令；而对于整数除0，则会发生“整除0”故障，通常调用abort例程来终止当前用户进程。<br><br><strong>页故障的情况：</strong><br><br>“page fault”异常中包括了多种不同情况，需要页故障处理程序根据不同的情况进行进行不同的处理，首先检查是否发生地址越界或者访问越权，如果是的话，则故障不可以恢复；否则是真正的缺页故障，此时，可以通过从硬盘读入页面来恢复故障，Linux中不可以恢复的访存故障（地址越界或者地址越权）都称为“段故障（segmentation fault）”<br><br><img src="https://i.imgur.com/8UHrtiT.png" srcset="/img/loading.gif" alt><br></p><p><strong>故障处理后有三种情况：终止（abort），返回当前指令（再执行一遍故障指令，“缺页”），返回下条指令（例如浮点数除法，除0）。</strong><br></p><h3 id="lt-2-gt-陷阱"><a href="#lt-2-gt-陷阱" class="headerlink" title="&lt;2&gt;.陷阱"></a>&lt;2&gt;.陷阱</h3><p>陷阱也称为“自陷”或“陷入”与“故障”等其他异常事件不同，是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。当执行到陷阱指令时，CPU就会调出特定的程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令执行。<br><br><img src="https://i.imgur.com/i22SV5W.png" srcset="/img/loading.gif" alt><br><br><strong>执行陷阱指令返回是回到陷阱指令的下一条指令执行。</strong><br></p><p>陷阱的作用：<br></p><ol><li>陷阱的重要作用之一就是再用户程序和内核之间提供一个像过程一样的接口，这个接口叫做<strong>系统调用</strong>，用户程序利用这个接口可以方便地使用操作系统内核提供的一些服务。操作系统给每个服务编一个号，称为<strong>系统调用号</strong> ，每个服务功能通过一个对应的<strong>系统调用服务例程</strong>提供<br></li><li>陷阱机制可以实现程序调试功能，包括设置断点和单步跟踪<br></li></ol><p><strong>单步跟踪：</strong>在IA-32中，当CPU处于单步跟踪状态（TF=1且IF=1）时，每条指令都被设置成陷阱指令，执行每条指令后，都会发生中断类型型号为1的“调试”异常，从而转去特定的“单步跟踪处理程序”。<br><br><strong>单步跟踪处理程序执行具体过程：<br></strong><br><img src="https://i.imgur.com/YAP7Egj.jpg" srcset="/img/loading.gif" alt><br><br>单步跟踪处理前CPU会自动把标志寄存器压栈，然后将TF和IF清0，这样在单步跟踪处理程序执行过程中CPU能以正常方式工作工作，单步处理结束， <strong>返回断点处执行之前（注意是回到断点处执行，而不是回到断点处的下一条指令执行）</strong> ，再从栈中取出标志，以恢复TF和IF的值，是CPU回到单步跟踪状态，这样下一条指令又是陷阱指令，将被跟踪执行。<br></p><p><strong>断点设置：</strong><br><br>在IA-32中，用于程序调试的“断电设置”陷阱指令为int 3 ，对应机器码为CCH，若调试程序在被调试程序某处设置了断点，则调试程序就把该处指令第一字节改为CCH。当CPU执行到该指令是，就会暂停当前被调试程序的运行，并发出一个“EXCEPTION_BREAKPOINT”异常，从而最终调出相应的调试程序来执行，执行结束后再回到设定的断点的调试程序执行。<br></p><h3 id="lt-3-gt-终止"><a href="#lt-3-gt-终止" class="headerlink" title="&lt;3&gt;.终止"></a>&lt;3&gt;.终止</h3><p>如果再执行指令过程中发生了严重错误，例如控制器出现问题，访问DRAM或者SRAM时发生校检错等，则程序将无法继续执行，只好终止发生问题的进程，在有些严重的情况下，甚至要重启系统，显然，这种异常时随机发生的，无法确定发生异常的是哪一条指令，其处理过程如下图：<br><br><img src="https://i.imgur.com/9vE3Wfc.png" srcset="/img/loading.gif" alt><br></p><h2 id="7-2-3-中断的分类"><a href="#7-2-3-中断的分类" class="headerlink" title="7.2.3 中断的分类"></a>7.2.3 中断的分类</h2><p>中断时外部I/O设备请求处理器进行的处理的一种信号，它不是由当前执行的指令引起的。<br></p><p>Intel将外部中断分为可屏蔽中断（maskable interrupt）和不可屏蔽中断（nonmaskable interrupt，NMI）<br></p><ol><li><p>可屏蔽中断（maskable interrupt）<br>可屏蔽中断时指通过可屏蔽中断请求线（INTR）向CPU进行请求的中断，主要来自I/O设备的中断请求。CPU可以通过在中断控制器中设置相应的屏蔽字来屏蔽它或者不屏蔽它，若一个I/O设备的中断请求被屏蔽，则它的中断请求信号不会被送到CPU<br></p></li><li><p>不可屏蔽中断<br><br>不可屏蔽中断时非常紧急的硬件故障（电源断点，硬件线路故障），通过专门的不可以屏蔽中断请求线NMI向CPU发出中断请求。这类中断请求信号一旦产生，任何情况下都不可被屏蔽，因此一定会被送到CPU，以便CPU快速处理这类紧急事件，通常这种情况下，中断服务程序会尽快保存系统重要信息，然后再屏幕上显示相应的消息或者直接重启系统。<br></p></li></ol><p><img src="https://i.imgur.com/vTJ4Oes.png" srcset="/img/loading.gif" alt></p><h2 id="7-2-4-异常和中断的响应具体过程"><a href="#7-2-4-异常和中断的响应具体过程" class="headerlink" title="7.2.4 异常和中断的响应具体过程"></a>7.2.4 异常和中断的响应具体过程</h2><p>CPU对异常和中断的响应过程可以分为以下三个步骤：保护断点和程序状态，关中断，识别异常和中断事件并转到相应处理程序执行。</p><h3 id="1-保护断点和程序状态"><a href="#1-保护断点和程序状态" class="headerlink" title="1.保护断点和程序状态"></a>1.保护断点和程序状态</h3><p><strong>保护断点：</strong><br><br>对于不同的异常事件，其返回地址不同（即断点不同），例如“缺页故障”异常的断点时发生页故障的当前指令的地址；为了能在异常处理后正确返回到原被中断的程序继续执行，数据通路必须能正确计算断点处的地址。<strong>保护断点时只要将计算出的断点地址送到栈中或者特定的寄存器中即可。</strong><br><br>IA-32处理器的断点保存在栈中<br><br>MIPS处理器用EPC寄存器专门存放断点<br><br><strong>保护程序状态：</strong><br><br>因为异常处理后可能还要回到原被中断的程序中继续执行，所以被中断时源程序的状态（如产生的各自标志信息，允许自陷标志等）都必须保存起来，通常每个正在运行的程序的状态信息存放在一个专门的寄存器中，这些专门的寄存器统称为<strong>程序状态字寄存器（PSWR）—&gt;如IA-32中的EFLAGS寄存器就是PSWR</strong>，存放在PSWR的信息称为<strong>程序状态字（PSW）</strong>，与断点一样PSWR中的PSW也要保存在栈或者特定的寄存器中。<br></p><h3 id="2-关中断"><a href="#2-关中断" class="headerlink" title="2.关中断"></a>2.关中断</h3><p><strong>如果中断处理程序在保存原被打断程序现场的过程中又发生了新的中断，那么就会因为要处理新的中断，而把原被打断程序的现场以及已保存的断点和程序状态等破坏掉。因此因该有一种机制来禁止在处理中断时在响应新的中断</strong><br><br>通常通过设定“中断允许位”（“中断允许”触发器）来实现，若中断允许位为1，则为开中断，表示允许响应中断；若中断允许位清0，表示不允许响应中断 则为关中断。例如 IA-32中的“中断允许位”就是EFLAGS的寄存器中的中断标志位IF。<br><br>在IA-32中通过执行指令sti或者cli，将标志寄存器EFLAGS中的位 （置1或清0），以使CPU处在开中断或者关中断状态。<br></p><h3 id="3-识别异常和中断事件并转相应的处理程序执行"><a href="#3-识别异常和中断事件并转相应的处理程序执行" class="headerlink" title="3.识别异常和中断事件并转相应的处理程序执行"></a>3.识别异常和中断事件并转相应的处理程序执行</h3><p>在调出异常和中断处理从程序之前，必须知道发生了什么异常或哪个I/O设备发出了中断请求，一般来说，内部异常事件和外部中断源的识别方式不同，大多数处理器会将两者分开来。<br><br><strong>内部异常事件的识别：</strong><br><br>内部异常事件识别比较简单，只要把CPU在执行指令时把检测到的事件对于的异常类型号或标识异常类型的信息记录到特定的内部寄存器即可。<br><br><strong>外部中断源的识别：</strong><br><br>外部中断源的识别比较复杂。由于外部中断的发生与CPU正在执行的指令没有必然联系，相对于指令来说，外部中断时不可预测的，与当前指令无关，所以并不能根据指令执行过程中的某些现象判断是否发生了中断请求，必须时每条指令执行完之后，在加载下一条指令之前CPU通过采样对应的中断请求引脚（INTR，NMI）来进行查询，如果发现中断请求引脚有效，则说明有中断请求，但是到底时哪个I/O设备发出的请求还需要进一步识别，通常是由CPU外部的中断控制器根据IO设备的中断请求和中断屏蔽情况，结合中断响应优先级，来识别当前的中断类型号，并通过数据总线将中断类型号送到CPU。<br></p><p>异常和中断源的识别可以采用<strong>软件识别</strong>和<strong>硬件识别</strong>两种方式<br></p><p><img src="https://i.imgur.com/fh0f94U.png" srcset="/img/loading.gif" alt><br></p><h1 id="7-3-IA-32-Linux中的异常和中断"><a href="#7-3-IA-32-Linux中的异常和中断" class="headerlink" title="7.3 IA-32+Linux中的异常和中断"></a>7.3 IA-32+Linux中的异常和中断</h1><h2 id="7-3-1-IA-32的中断向量"><a href="#7-3-1-IA-32的中断向量" class="headerlink" title="7.3.1 IA-32的中断向量"></a>7.3.1 IA-32的中断向量</h2><p>IA-32采用向量中断方式，可以处理256种不同类型的异常和中断，每个异常或者中断都有唯一的编号，称之为中断类型号（也称向量号），并且还有与其对应的异常处理程序或者中断服务程序，其入口地址放在一个专门的中断向量表种。<br><br>256个中断类型前32个（0~31）保留给处理器用，剩余的可以由用户自行定义功能，这里的用户是操作系统。<br></p><h2 id="7-3-2-IA-32的中断描述符表"><a href="#7-3-2-IA-32的中断描述符表" class="headerlink" title="7.3.2 IA-32的中断描述符表"></a>7.3.2 IA-32的中断描述符表</h2><p><img src="https://i.imgur.com/vPTsaGo.jpg" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/ALWm2Oz.jpg" srcset="/img/loading.gif" alt><br><br>保护模式下，借助中断描述符表来获得异常处理程序或中断服务程序的入口地址，中断描述符表，（interrupt Descriptor Table，IDT）是操作系统内核种的一个表，共有256个表项，每个表项是一个中断门描述符，陷阱门描述符或任务门描述符（用TYPE区分，如下图，中断门TYPE=1110B，陷阱门TYPE=1111B,任务门TYPE=0101B）。<br><br>P=1时表示段存在，P=0表示段不存在，Linux总是把P置成1，因为它从来不会把一个段交换到磁盘上，而是以页面为单位交换。<br><br>DPL给出访问本段要求的最低特权等级<br></p><p><img src="https://i.imgur.com/TyHMAP6.png" srcset="/img/loading.gif" alt><br><strong>任务门描述符：</strong><br><br>任务门描述符中不包括偏移地址，只包括TSS段选择符，这个段选择符指向GDT中的一个TSS段描述符，CPU根据TSS段中的相关信息装载EIP和ESP等寄存器，从而执行相应的异常处理程序。<br></p><h2 id="7-3-2-IA-32中异常和中断的处理"><a href="#7-3-2-IA-32中异常和中断的处理" class="headerlink" title="7.3.2 IA-32中异常和中断的处理"></a>7.3.2 IA-32中异常和中断的处理</h2><p>在每条指令的执行过程中会根据执行情况判定是否发生了某种内部异常事件，在每条指令执行结束时判定是否发生了外部中断，因此在CPU根据CS和EIP去取下条指令之前，会根据检测的结果判断是否进入异常和中断响应阶段。<br><br>若由异常和中断发生:<br></p><ol><li>确定检测到的异常中断号i，从IDTR指向的IDT中取出第i个表项<br></li><li>根据IDTi中的段选择符，从GDTR指向的GDT中取出相应的段描述符，得到对应异常处理程序和中断服务程序所在段的DPL，基地址等信息。<br></li><li>将当前特权级CPL与段描述符中的DPL比较。若CPL小于DPL，则产生13号异常，内核代码段DPL总是等于0，因此不管怎样都不会发生CPL小于DPL的情况，这个检查主要是为了防止而已应用程序通过INT n 指令模拟非法异常和中断进入内核态执行非法性破坏。<br></li><li>检查是否发生了特权级变化，即判断CPL是否与相应的段描述符中的DPL不同，如果是的话，就需要从用户态切换到内核态，以使用内核对应的栈。Linux中若CPL=DPL，则发生异常或中断指令也在内核态执行；（即在一个内核态中执行的过程中又遇到了异常或者中断），若CPL&gt;DPL，则从用户态转到内核态执行，因此，因从用户态切换到内核态执行，因此应从用户栈切换到内核栈。<br></li></ol><p><strong>用户栈切换到内核栈步骤：</strong><br><br>读TR寄存器，以访问正在运行的TSS段，将TSS段中保存的内核栈的段选择符和栈指针分别装入寄存器SS和ESP,然后再内核栈中保存原来的用户栈的SS和ESP。<br><br>5. 如果发生的事故障，则将发生故障的指令的逻辑地址写入CS和EIP，以保证故障处理后能回到发生故障的指令执行。<br><br>6. 在当前栈中保存EFLAGS，CS和EIP寄存器的内容（内核栈）。若是中断门，则将EFLAGS寄存器中的IF清0(关中断)。<br><br>7. 将IDTi中的段选择符装入CS，IDTi中的偏移地址装入EIP，它们事异常处理程序或中断服务程序第一条指令的逻辑地址<br><br>8. 这样从下一个时钟周期开始，就执行异常处理程序和中断服务程序的第一条指令，在异常处理程序中或中断服务程序中，处理完异常或者中断程序后，通过执行最后一条指令IRET回到原被中断的进程继续执行<br></p><p>CPU在执行IRET指令的过程中完成以下工作：<br></p><ol><li>从内核栈中弹出EIP，CS和EFLAGS，恢复断点和程序状态。<br></li><li>检查当前异常或中断处理程序的CPL是否等于CS中的低两位，若是，则说明异常或中断响应前后都属于一个特权级，IRET指令完成操作；否则再进行下一步工作。<br></li><li>从内核栈中弹出SS和ESP(弹出来的是用户栈的SS和ESP)，以恢复到异常或中断响应前的特权级进程所使用的栈。</li><li>检查DS，ES，FS和GS寄存器的内容，若其中又某个寄存器的段选择符指向的一个段描述符且器DPL小于CPL则将段寄存器的内容清0，这是为了防止恶意应用程序（CPL=3）利用内核以前使用过的段寄存器（DPL=0）,来访问内核地址空间<br><br>执行完IRET指令后，CPU自然回到原来发生异常或中断的进程继续执行。<br></li></ol><p><img src="https://i.imgur.com/Cx9kqLD.png" srcset="/img/loading.gif" alt><br></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础-袁春风</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次结构存储系统</title>
    <link href="undefined2019/11/04/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <url>2019/11/04/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>教材：《计算机系统基础》，本博客主要用来梳理学习思路。(不然好乱）<br><br>不同类型的存储器设置的计算机中，其设置的顺序为：<br><br><strong>寄存器-&gt;cache-&gt;主存-&gt;硬盘-&gt;光盘和磁带。</strong><br><br>接下来就是详细的按顺序的介绍上面的存储器。<br></p><h1 id="6-1-存储器概述"><a href="#6-1-存储器概述" class="headerlink" title="6.1 存储器概述"></a>6.1 存储器概述</h1><h2 id="6-1-1-存储器的分类"><a href="#6-1-1-存储器的分类" class="headerlink" title="6.1.1 存储器的分类"></a>6.1.1 存储器的分类</h2><h3 id="1-按照存储元件分类"><a href="#1-按照存储元件分类" class="headerlink" title="1.按照存储元件分类"></a>1.按照存储元件分类</h3><p>半导体存储器，磁表面存储器：磁盘存储器和磁带存储器，光介质存储器：光盘存储器。</p><h3 id="2-按存取方式分类"><a href="#2-按存取方式分类" class="headerlink" title="2.按存取方式分类"></a>2.按存取方式分类</h3><h4 id="1-RAM-随机存取存储器）"><a href="#1-RAM-随机存取存储器）" class="headerlink" title="(1).RAM(随机存取存储器）"></a>(1).RAM(随机存取存储器）</h4><p>RAM特点是：按地址访问存储单元，RAM的存储介质是半导体存储器件，每个地址译码时间相同，在不用考虑行缓冲的前提下，每个单元的访问时间是一个常数，与地址无关（但是现在DRAM芯片大多都有行缓冲）。</p><h4 id="2-SAM-顺序存取存储器"><a href="#2-SAM-顺序存取存储器" class="headerlink" title="(2).SAM(顺序存取存储器)"></a>(2).SAM(顺序存取存储器)</h4><p>SAM的特点是：信息按照顺序存放和读出，其存取时间时间取决于信息存放的位置，以记录块为单位编址。例如：磁带存储器。（存储量大，存取速度慢）</p><h4 id="3-DAM-直接存取存储器"><a href="#3-DAM-直接存取存储器" class="headerlink" title="(3).DAM(直接存取存储器)"></a>(3).DAM(直接存取存储器)</h4><p>DAM的特点是：兼有随机访问和顺序访问的特点。首先直接定位在需要读写的位置，然后顺序方式存取，磁盘存储器就是如此。</p><h4 id="4-CAM-AM-相联存储器"><a href="#4-CAM-AM-相联存储器" class="headerlink" title="(4).CAM/AM(相联存储器)"></a>(4).CAM/AM(相联存储器)</h4><p>CAM/AM特点是：按照内容访问存储器(上面的RAM，CAM，SAM，都需要给出地址，CAM不用，CAM按照内容定位),例如：快表（TLB）。</p><h3 id="3-按照信息的可更改性分类。"><a href="#3-按照信息的可更改性分类。" class="headerlink" title="3. 按照信息的可更改性分类。"></a>3. 按照信息的可更改性分类。</h3><p>读写存储器(RAM),只读存取器（ROM）。RAM芯片和ROM芯片都采用随机存取的方式进行信息的访问。</p><h3 id="4-按断电后的信息的可保存性分类"><a href="#4-按断电后的信息的可保存性分类" class="headerlink" title="4.按断电后的信息的可保存性分类"></a>4.按断电后的信息的可保存性分类</h3><p>非易失性存储器：ROM，磁表面存储器，光盘存储器等。<br><br>易失性存储器：RAM,cache等。<br></p><h3 id="5-按照功能分类"><a href="#5-按照功能分类" class="headerlink" title="5.按照功能分类"></a>5.按照功能分类</h3><h4 id="1-高速缓存存储器（cache）"><a href="#1-高速缓存存储器（cache）" class="headerlink" title="(1).高速缓存存储器（cache）"></a>(1).高速缓存存储器（cache）</h4><p>cache：位于主存和CPU之间，由静态RAM芯片组成，存放CPU常用的指令和数据，速度接近CPU的工作速度。</p><h4 id="2-主存储器-主存"><a href="#2-主存储器-主存" class="headerlink" title="(2).主存储器(主存)"></a>(2).主存储器(主存)</h4><p>CPU执行指令是给出的存储地址最终必须转换为主存地址，主存用来存放系统启动运行的程序及其数据。</p><h4 id="3-辅助存储器（辅存）"><a href="#3-辅助存储器（辅存）" class="headerlink" title="(3).辅助存储器（辅存）"></a>(3).辅助存储器（辅存）</h4><p>系统运行时直接和主存交换信息的存储器叫做辅助存储器。例如：磁盘，辅存的内容要导入主存才能被CPU访问。</p><h4 id="4-海量后备存储器"><a href="#4-海量后备存储器" class="headerlink" title="(4).海量后备存储器"></a>(4).海量后备存储器</h4><p>磁带，光盘，U盘一类的吧。<br></p><p><strong>海量后备存储器和辅助存储器统称外存。</strong></p><h2 id="6-1-2-主存的组成和基本操作"><a href="#6-1-2-主存的组成和基本操作" class="headerlink" title="6.1.2 主存的组成和基本操作"></a>6.1.2 主存的组成和基本操作</h2><p><img src="https://i.imgur.com/mXC6RaT.png" srcset="/img/loading.gif" alt="主存储器的基本框图"><br>记忆单元（存储元）：是具有两种稳态的能表示二进制0和1的物理器件。<br><br>指令执行过程：（这里不考虑虚拟地址，cache的情况大略宏观上梳理一下CPU访存的过程，这里CPU给出的就是主存地址）<br><br>CPU先把欲访问的主存单元的地址送到主存地址寄存器(MAR)——&gt;MAR通过地址线把主存地址送到主存中的地址寄存器———&gt;地址译码器根据地址寄存器中的地址进行译码后选中存储阵列（存储体）中相应单元，同时CPU将读/写控制信号通过控制线送到主存的读写控制电路，进行读写操作，读写的数据通过MDR&lt;—&gt;数据线&lt;—&gt;存储阵列传输。<br><br><strong>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。</strong><br><br>图中采用64位数据线，因此在按字节编址下最多一次可以取8个字节的内容，地址线的位数决定主存地址空间最大可寻址范围：例如36位地址的最大可寻址范围位0~2<sup>36</sup>-1。</p><h2 id="6-1-3-存储器的主要性能指标"><a href="#6-1-3-存储器的主要性能指标" class="headerlink" title="6.1.3 存储器的主要性能指标"></a>6.1.3 存储器的主要性能指标</h2><p>存储器速度可以用访问时间，存储周期或者存储器带宽来表示。<br><br>(1).访问时间一般用读出时间（T<sub>A</sub>)和写入时间（T<sub>w</sub>)来表示。<br><br>(2).存储周期（T<sub>M</sub>)是指存储器进行一次读写操作所需要的全部时间。<br><br>(3).存储器带宽(B)：每秒传输信息的位数（字节）。</p><h2 id="6-1-4-各类存储元件"><a href="#6-1-4-各类存储元件" class="headerlink" title="6.1.4 各类存储元件"></a>6.1.4 各类存储元件</h2><p>半导体芯片：RAM芯片和ROM芯片。<br><br>RAM分为静态RAM芯片(SRAM)和动态RAM芯片(DRAM)。<br><br>ROM分为不可在线改写内容ROM和闪存(Flash ROM)。<br><br>SRAM:<strong>优点：</strong>速度快，无需刷新和读后再生。<strong>缺点：</strong>MOS管多，占硅面积大，功耗大，集成度低，价格贵。 <strong>应用：</strong>cache<br><br>DRAM: <strong>优点</strong>：MOS管少，占硅面积小，集成度高，价格便宜。 <strong>缺点</strong>：速度慢，需要定时刷新和读后再生。 <strong>应用</strong>：主存</p><h2 id="6-1-5-存储器的层次结构"><a href="#6-1-5-存储器的层次结构" class="headerlink" title="6.1.5 存储器的层次结构"></a>6.1.5 存储器的层次结构</h2><p><img src="https://i.imgur.com/M3VPO5U.png" srcset="/img/loading.gif" alt="存储器层次化体系结构示意图"></p><h1 id="6-2-主存与CPU的连接及其读写操作"><a href="#6-2-主存与CPU的连接及其读写操作" class="headerlink" title="6.2 主存与CPU的连接及其读写操作"></a>6.2 主存与CPU的连接及其读写操作</h1><h2 id="6-2-1-主存芯片技术"><a href="#6-2-1-主存芯片技术" class="headerlink" title="6.2.1 主存芯片技术"></a>6.2.1 主存芯片技术</h2><p>1.DRAM芯片技术<br><br>2.SDRAM芯片技术(同步DRAM)<br><br>3.DDR SDRAM芯片技术。<br><br>4.DDR2 SDRAM芯片技术。<br><br>5.DDR3 SDRAM芯片技术<br><br>不展开讲，因为涉及数字逻辑电路，不是很重点（自己觉得)，现在比较主要用SDRAM.</p><h2 id="6-2-2-主存与CPU的连接及其读写"><a href="#6-2-2-主存与CPU的连接及其读写" class="headerlink" title="6.2.2 主存与CPU的连接及其读写"></a>6.2.2 主存与CPU的连接及其读写</h2><h3 id="1-宏观上主存和CPU的关系"><a href="#1-宏观上主存和CPU的关系" class="headerlink" title="(1).宏观上主存和CPU的关系"></a>(1).宏观上主存和CPU的关系</h3><p><img src="https://i.imgur.com/7xQkMrt.jpg" srcset="/img/loading.gif" alt><br><br><strong>（什么什么）总线是连接其上的各部件的传输介质，通常由控制线，数据线，地址线构成。</strong><br><br>CPU通过系统总线和内存总线与主存相连，在CPU与主存之间交换信息时，CPU通过总线接口把总线控制信息和地址信息分别送到控制线和地址线，CPU和主存之间交换的数据信息则通过数据线传输。<br></p><p>受集成度和功耗等因数影响，单个芯片的容量不能很大，所以就要通过存储器芯片扩展技术将多个芯片做成一个内存条，然后通过多个内存条，以及主板或者扩充板上的RAM芯片和ROM芯片组成一台计算机所需要的主存空间，在通过总线，桥接器和CPU相连。<br></p><p>内存条插槽就是存储器总线，内存条中的信息通过内存条的引脚，再通过插槽内的引线连接到主板上，通过主板上的导线连接到北桥芯片或者CPU芯片。现在的计算机可以实现多条存储器总线同时进行传输，支持两条总线进行传输的内存条插槽为两通道内存插槽，还有三通道 四通道内存插槽，其总线传输的带宽可以提升2，3，4倍，<strong>在主机主板上相同颜色的插槽可以并行传输，如果有两个内存条可以插在两个颜色相同的内存条插槽上，其带宽可以增加一倍。（这个实用！）</strong><br></p><hr><h3 id="2-DRAM的扩展"><a href="#2-DRAM的扩展" class="headerlink" title="(2).DRAM的扩展"></a>(2).DRAM的扩展</h3><p>由若干个存储器构成的一个存储器，需要在字方向和位方向上进行扩展。<br><br><strong>位扩展：</strong>用若干片位数较少的存储器芯片构成给定字长的存储器（如下图z方向的扩展）<br><br><strong>字扩展：</strong>容量上的扩充，位数不变（z不变而一片DRAM芯片上的容量扩大）<br><br><strong>读写过程：CPU通过存储器控制器对内存条中的DRAM芯片进行读写，CPU读写的存储单元地址通过总线被送到存储控制器，然后由存储控制器将存储单元地址转化为DRAM芯片的行地址i和列地址j，分别在行地址选通信号RAS和列地址选通信号CAS的控制下，通过DRAM芯片的地址引脚，分时送到DRAM芯片内部的行地址译码器和列地址译码器，以选择行，列地址交叉点(i,j)【一个超元】，的8位数据同时进行读写，8个芯片就可以同时读取64位，组合成总线所需要的64位传输宽度，再通过存储器总线进行传输。</strong><br></p><p>正是主存这种存取数据的方式，就决定了计算机信息储存数据要对齐。<br><br><img src="https://i.imgur.com/tTYo7Cq.jpg" srcset="/img/loading.gif" alt="DRAM芯片的扩展"></p><hr><h3 id="3-DRAM芯片内部结构"><a href="#3-DRAM芯片内部结构" class="headerlink" title="(3). DRAM芯片内部结构"></a>(3). DRAM芯片内部结构</h3><p>图中芯片容量为16x8位，存储阵列为4行x4列，地址引脚采用复用方式，因此仅需2根地址引脚，再RAS和CAS的控制下分时传送2位行地址和2位列地址。每一个超元，有8位，需要8根数据引脚，有一个内部行缓冲，用来缓存指定行中每一列的数据，通常用SRAM元件实现。<br><br><img src="https://i.imgur.com/p4sbQ4i.png" srcset="/img/loading.gif" alt="DRAM芯片内部结构示意图"></p><p><strong>读写过程：图中反应了存储控制器再RAS有效时将行地址“2”送到行译码器后选中，第“2”行时的状态，此时，整一行数据被送到内部行缓存中，然后存储控制器再CAS有效时将列地址“1”送到选中的第“1”列时的状态，此时将内部行缓冲中第“1”列的8位数据超元（2，1）读到数据线，并向CPU传送。</strong><br><img src="https://i.imgur.com/Jj0AiXI.jpg" srcset="/img/loading.gif" alt="DRAM芯片读写原理示意图"></p><hr><h3 id="4-“装入”指令和存储“存储”指令操作过程"><a href="#4-“装入”指令和存储“存储”指令操作过程" class="headerlink" title="(4).“装入”指令和存储“存储”指令操作过程"></a>(4).“装入”指令和存储“存储”指令操作过程</h3><p>以 IA-32中的“movl 8(%ebp),%eax”指令为例：(这里8(%ebp)的计算在CPU中完成，涉及IA-32中的分段和分页存储管理机制，这里不展开说明)<br><br><strong>具体过程：<br><br>(1).图aCPU将主存地址A通过总线接口送到地址线，然后由存储控制器将地址A分解成行，列按分时的方式送给DRAM芯片。在进行这些操作的同时CPU还会把“存储器读”控制命令通过控制线送到主存。<br><br>(2).图b主存将地址A中的数据x通过数据线送到总线接口部件。<br><br>(3).图cCPU从总线接口部件中取出x存放在寄存器EAX中。<br></strong><br><img src="https://i.imgur.com/Fz80FzY.jpg" srcset="/img/loading.gif" alt="主存单元取数到寄存器的操作过程"></p><h1 id="6-3-硬盘存储器"><a href="#6-3-硬盘存储器" class="headerlink" title="6.3 硬盘存储器"></a>6.3 硬盘存储器</h1><h2 id="6-3-1磁盘存储器的结构"><a href="#6-3-1磁盘存储器的结构" class="headerlink" title="6.3.1磁盘存储器的结构"></a>6.3.1磁盘存储器的结构</h2><p><img src="https://i.imgur.com/opv5DqD.png" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/zyz1Nnp.png" srcset="/img/loading.gif" alt><br><img src="https://i.imgur.com/wASJplS.jpg" srcset="/img/loading.gif" alt><br><br><strong>注意：每一个盘片都有两个磁头，正面一个反面一个。多个盘片上相同磁道形成一个柱面，所以磁道号就是柱面号</strong></p><hr><p><img src="https://i.imgur.com/hIxCGei.png" srcset="/img/loading.gif" alt></p><p><strong>读写过程：<br><br>(1).寻道操作：磁盘控制器把盘地址送到磁盘驱动器的磁盘地址寄存器后，便形成寻道命令，启动磁头定位伺服系统，根据磁头号和柱面号，选择指定的磁头移动到指定的柱面，此操作完成后，发出寻道结束信号给磁盘控制器，转入旋转等待操作。<br><br>(2).旋转等待操作：盘片旋转之前，首先将扇区计数器清零，以后每来一个扇区标志脉冲，扇区计数器加1，把计数器内容与磁盘地址寄存器中的扇区地址进行比较，如果一致则输出扇区符合信号，说明读写的信息已经转入磁头下方。<br><br>(3).读写操作：扇区符合信号送到磁盘控制器后，磁盘控制器的读写控制电路开始动作，如果是写操作，就将数据送到写入电路，写入电路根据记录方式生成相应的写电流脉冲；如果是读操作，则由读出放大电路读出内容送给磁盘控制器。<br></strong></p><hr><p>数据在磁盘上的记录格式分为定长记录格式和不定长记录格式两种，目前大多采用定长记录格式。<br></p><p>最早的硬盘由IBM开发：温切斯特盘（温盘），它采用定长记录格式。<br><br><img src="https://i.imgur.com/aAnzL0v.jpg" srcset="/img/loading.gif" alt><br><br> <strong>每个磁道由若干个扇区（也称扇段）组成，每个扇区记录一个数据块。</strong><br><br>头空（间隙1）占17个字节，全是1，磁盘转过该区域的时间是留给磁盘控制器作准备用的。</p><h2 id="6-3-2-磁盘存储器的性能指标"><a href="#6-3-2-磁盘存储器的性能指标" class="headerlink" title="6.3.2  磁盘存储器的性能指标"></a>6.3.2  磁盘存储器的性能指标</h2><p>(1).记录密度：道密度和位密度。<br><br>位密度：单位长度内存放的二进制信息数目叫做位密度。<br><br>道密度：沿磁道分布方向上单位长度内的磁道数目叫做道密度<br><br><img src="https://i.imgur.com/JcU1fAH.jpg" srcset="/img/loading.gif" alt></p><hr><p>(2).存储容量<br><br>硬盘的未格式化容量：按照道密度和位密度计算出来的容量，包括头空，ID域，CRC码等信息，是所有可利用的所有磁化单元的总数，未格式化容量，比格式化后的实际容量要大。<br></p><p>对于低密度存储方式的<strong>未格式化容量</strong>的计算方法为：<br><br><code>磁盘总容量 = 记录面数 (一个盘有两面) * 理论柱面数 * 内圆周长 * 最内道位密度</code><br><br><code>理论柱面数 =（有效记录去外径-有效记录区内径）/ 2 * 道密度</code><br></p><p><strong>格式化后实际容量只包括数据区(这里假定每个扇区512字节算)</strong><br><code>磁盘实际数据容量= 盘面数 * 磁道数/面 * 扇区数/磁道 * 512B/扇区</code></p><p>(3).数据传输速率 <br><br>数据传输速率：指的是磁表面存储器完成磁头定位和旋转等待以后，单位时间内从存储介质上读出或者写入的二进制信息量。</p><p>(4).平均存取时间 <br><br>通常，磁盘的平均存取时间近似等于平均寻道时间和平均等待时间之和。而且磁盘第一位数据的读写延时非常长，相当于平均存取时间，而以后的二位数据的读写则几乎没有延迟。</p><h2 id="6-3-3-磁盘存储器的连接"><a href="#6-3-3-磁盘存储器的连接" class="headerlink" title="6.3.3 磁盘存储器的连接"></a>6.3.3 磁盘存储器的连接</h2><p>现代计算机中，通常将复杂的磁盘物理扇区抽象成固定大小的逻辑块，物理扇区和逻辑块之间的映射由磁盘控制器来维护。磁盘控制器是一个内置固件的硬件设备，它能将主机送来的请求逻辑块号转化为磁盘的物理地址（柱面号，磁头号，扇区号），并控制磁盘驱动器进行相应的动作。</p><h2 id="6-3-4-固态硬盘-SSD"><a href="#6-3-4-固态硬盘-SSD" class="headerlink" title="6.3.4 固态硬盘(SSD)"></a>6.3.4 固态硬盘(SSD)</h2><p>#6.4 高速缓冲存储器(cache)<br> 由于CPU和主存所使用的半导体工艺不同导致两者在速度上由差距导致速度较快的CPU常常需要等到慢速的主存，为了加快CPU访存的速度，所以在CPU和主存之间增加 cache。（cache的速度与CPU的速度差不多）<br>\</p><h2 id="6-4-1-程序访问的局限性"><a href="#6-4-1-程序访问的局限性" class="headerlink" title="6.4.1 程序访问的局限性"></a>6.4.1 程序访问的局限性</h2><p>程序访问的局限性分为时间局部性和空间局限性。<br><br><strong>时间局部性：指的被访问的某个存储单元在一个较短的时间间隔内很可能又被访问。<br><br>空间局限性：指的是被访问的某个存储单元的临近的一个存储单元在一个较短的时间内很可能被访问。（例如循环访问数组）。<br></strong><br>为了更好的利用程序反问的空间局部性，通常把当前访问单元以及临近的单元作为一个主存块一起调入cache，在CPU和主存之间设置cache，总是把主存中被频繁访问的活跃的程序块和数据块复制到cache中，由于程序访问的局限性，大多情况下，CPU能直接从cache中取得指令和数据，而不必访问慢速的主存。<br></p><h2 id="6-4-2-cache的基本工作原理"><a href="#6-4-2-cache的基本工作原理" class="headerlink" title="6.4.2 cache的基本工作原理"></a>6.4.2 cache的基本工作原理</h2><p>为了便于cache与主存间交换信息，cache和主存空间被划分为相等的区域，例如，将主存按照每512个字节分成一个区域，同时把cache也划成同样大小的区域，这样主存中的信息可以按照512字节为单位送到cache中，我们把主存中的区域称为<strong>块</strong>，也称为<strong>主存块</strong> ，它是cache和主存之间的信息交换单位cache中存放一个主存块的区域叫做<strong>行</strong>或者<strong>槽</strong>。</p><h3 id="1-cache的有效位"><a href="#1-cache的有效位" class="headerlink" title="(1).cache的有效位"></a>(1).cache的有效位</h3><p>为了说明cache行中的信息是否有效，每个cache行都需要一个有效位。<br><br>有了有效位，就可以将有效位清0来淘汰某cache行中的主存；装入一个新主存块时在使有效位为1。<br></p><h3 id="2-CPU在cache中的访问过程"><a href="#2-CPU在cache中的访问过程" class="headerlink" title="(2).CPU在cache中的访问过程"></a>(2).CPU在cache中的访问过程</h3><p><img src="https://i.imgur.com/w5agUbu.png" srcset="/img/loading.gif" alt></p><h3 id="3-cache-—-主存层次的平均访问时间"><a href="#3-cache-—-主存层次的平均访问时间" class="headerlink" title="(3).cache —-主存层次的平均访问时间"></a>(3).cache —-主存层次的平均访问时间</h3><p><strong>cache命中</strong>：若CPU访问单元所在的主存块在cache中，则称为cache命中（hit），命中的概率称为命中率p，它等于命中次数与访问总次数之比。<br><br><strong>cache不命中</strong>：若CPU访问单元所在的主存块不在cache中，则称为cache不命中，其概率称为缺失率（miss rate），它等于不命中次数与访问总次数之比。<br><br><strong>命中时间：</strong>命中时CPU在cache中直接存取所用的时间开销就是cache访问时间T<sub>c</sub>称为命中时间。<br><br>缺失时需要从主存读取一个主存块送cache，并同时将所需信息送到CPU，所用时间时主存访问时间T<sub>m</sub>和cache访问时间T<sub>c</sub>之和。<br><br><strong>缺失损失:</strong>通常把从主存读入一个主存块到cache的时间T<sub>m</sub>缺失损失。<br></p><h2 id="6-4-3-cache行和主存块的映射"><a href="#6-4-3-cache行和主存块的映射" class="headerlink" title="6.4.3 cache行和主存块的映射"></a>6.4.3 cache行和主存块的映射</h2><p>把主存块复制到cache行时，主存块和cache行之间必须遵循一定的映射规则。<br><br><strong>主要分为三种映射规则：直接映射，全相联映射，组相联映射。</strong></p><h3 id="1-直接映射"><a href="#1-直接映射" class="headerlink" title="(1).直接映射"></a>(1).直接映射</h3><p>直接映射的基本思想是：把主存每一块映射到一个固定的cache行中，也称<strong>模映射</strong>，其映射关系如下：<br><br><code>cache行号 = 主存块号 mod cache行数</code><br></p><p>直接映射方式下：主存地址被分为标记，cache行号，块内地址三个字段。<br><br><img src="https://i.imgur.com/L37b3uQ.jpg" srcset="/img/loading.gif" alt><br><br>举例：假定共有2<sup>c</sup>行，主存共有2<sup>m</sup>块，主存块大小占2<sup>b</sup>字节，则按照字节编址，则上图中cache行号占c位，主存块号占m位，块内地址有b位，<strong>因为主存块号分解成标记字段和cache行号字段</strong>，因而标记字段占t=m-c位。<br></p><p><strong>直接映射的CPU访存过程：</strong><br><br><img src="https://i.imgur.com/1PTb7VT.png" srcset="/img/loading.gif" alt><br><br><strong>首先根据CPU给出的主存地址中的cache行号（如图cache字块地址）选择cache中对应的cache行，将行中的标记和CPU给出的主存地址中高t位进行比较，若相等而且有效位为1，则命中，此时根据CPU给出的主存地址低b位块内地址，在对应的cache行中存取信息。若不想等或者有效位为0，则cache 缺失，此时CPU从主存中读出该主存地址所在一块信息通过系统总线送到对应的cache行中，将有效位置1，并将标记设置为该地址的高t位，同时将该地址中的内容送CPU。</strong></p><p>直接映射的优缺点：<br><br><strong>优点</strong>：容易实现，命中时间短。<br><br><strong>缺点</strong>：cache行得不到充分利用，命中率比较低。<br></p><h3 id="2-全相联映射"><a href="#2-全相联映射" class="headerlink" title="(2).全相联映射"></a>(2).全相联映射</h3><p>全相联映射的基本思想是一个主存块可装入cache任意行中。<br><br>全相联映射cache中，每行的标记用于指出该行取自主存的哪个块，因为一个主存块可能出现在任意一个cache行中，所以需要比较所以cache行的标记，<strong>因此 主存地址中不需要cache行索引。</strong>，只有标记和块内地址两个字段。<br>所以全相联映射方式下，只要有空闲的cache行，就不会发生冲突，因而块冲突概率低。<br><br><img src="https://i.imgur.com/b2G6pQF.jpg" srcset="/img/loading.gif" alt><br></p><p>全相联映射优缺点：<br><br>优点是：块冲突率低。<br><br>缺点是：为了加快比较速度，通常每个cache行都设置一个比较器，比较器的位数等于标记字段的位数。全关联cache访存是根据标记字段的内容来访问cache行中的主存块，它查找主存块是”按内容访问”所以全关联映射的时间开销和所用元件都较大，实现起来困难。</p><h3 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="(3).组相联映射"></a>(3).组相联映射</h3><p>组相联映射的主要思想是：将cache分为大小相等的组，每个主存块被映射到固定组中的任意一行，也即采用<strong>组间模映射，组内全映射</strong>的方法。<br><br>映射关系如下：<br><br><code>cache组号 = 主存块号 mod cache组数</code><br></p><p>组相联方式下，主存地址被分为 标记 ，cache组号 ， 块内地址三个字段。<br><img src="https://i.imgur.com/36n3gxi.jpg" srcset="/img/loading.gif" alt><br><br> 假定cache共有2<sup>c</sup>行，被分为2<sup>q</sup>组，每组有2<sup>c</sup>/2<sup>q</sup>=2<sup>c-q</sup>行设s=c-q，则cache映射方向称为2<sup>s</sup>路组相联映射<strong>（即每组有多少行相联映射）</strong>。</p><p><strong>2路组相联映射的访存过程：<br><br>根据主存地址中的cache组号找到对应组—–&gt;找到对应组后就是“按内容访问”全关联模式了，根据主存地址中的标记字段与对应组中每一行的标记tag进行比较。——–&gt;若相等而且有效位为1则命中，执行相关操作，若不相等或者有效位为0，则不命中，也执行相应操作。</strong></p><h2 id="6-4-4-cache中主存块的替换算法"><a href="#6-4-4-cache中主存块的替换算法" class="headerlink" title="6.4.4 cache中主存块的替换算法"></a>6.4.4 cache中主存块的替换算法</h2><ol><li>FIFO算法(先进先出算法）</li><li>LRU算法（最近最少用算法）</li><li>LFU算法（最不经常用算法）</li><li>随机替换算法</li></ol><h2 id="6-4-5-cache的一致性问题"><a href="#6-4-5-cache的一致性问题" class="headerlink" title="6.4.5 cache的一致性问题"></a>6.4.5 cache的一致性问题</h2><ol><li>全写法</li><li>回写法(一般用回写法)</li></ol><h2 id="6-4-6-影响cache性能的因数"><a href="#6-4-6-影响cache性能的因数" class="headerlink" title="6.4.6 影响cache性能的因数"></a>6.4.6 影响cache性能的因数</h2><p><strong>&lt;1&gt;.</strong>决定系统访存性能的重要因数之一是cache 命中率，它与许多元素有关。</p><ol><li>命中率与关联度有关，关联度越高，命中率越高，关联度反映一个主存块对应的cache行的个数（直接映射的关联度为1，2路组相联映射的关联度为2，4路组相联映射的关联度为4；全关联映射为cache和行数。）</li><li>命中率与cache容量有关，显然cache容量越大，命中率就越高。</li><li>命中率与主存块的大小有关，采用大单位的主存块就能很好的利用空间的局部性，但是较大的主存块需要比较多的时间来存取，因此缺失损失会变大，由此可见，主存块大小必须适中，不能太大也不能太小。<br>&lt;2&gt;. 单级/多级cache，联合/分离cache的选择问题。<br></li></ol><p>&lt;3&gt;. 主存-总线-cache间的连接结构问题。<br>主存，总线和cache之间可以有三种连接方式：<br></p><ol><li>窄型结构:即在主存，总线和cache之间每次按一个字的宽度来进行传送。<br></li><li>宽型结构：即在它们之间每次传输多个字。<br></li><li>交叉存储结构:即在主存采用多模块交叉存取方式，在主存，总线和cache之间每次按照一个字的宽度来进行传送,例如：传输一个4字，第一个模块准备好第一个字，然后在总线上传输一个字，同时第二个模块已经准备好第二个字了，然后再总线上传输第二个字的时候，第三个模块已经准备好第三个字了，以此类推）。</li></ol><h1 id="6-5-虚拟存储器"><a href="#6-5-虚拟存储器" class="headerlink" title="6.5 虚拟存储器"></a>6.5 虚拟存储器</h1><h2 id="6-5-1虚拟存储器的基本概念"><a href="#6-5-1虚拟存储器的基本概念" class="headerlink" title="6.5.1虚拟存储器的基本概念"></a>6.5.1虚拟存储器的基本概念</h2><p>在采用虚拟存储技术的计算机中，指令执行时，通过存储器管理部件（MMU）将指令中的逻辑地址（虚拟地址 VA）转化为主存的物理地址（主存地址或实地址 PA）。在地址转换的过程中由硬件检查是否发生了访问信息不在主存或者地址越界或者访问越权，若发现信息不在主存，则由操作系统将数据从硬盘读到主存。若发生地址越界或访问越权，则由操作系统进行相应的因此处理。由此看出，虚拟技术即解决了编程空间受限的问题，又解决了多到程序共享主存带来的安全问题。<strong>{这里忽略cache，因为主存的空间是一定的所以如果没有虚拟存储技术的话，程序受到物理内存大小的限制，而且无法让多道程序共享主存，有了虚拟存储技术，就可以把主存看作一个比较大的cache}<br></strong></p><h2 id="6-5-2-虚拟地址空间"><a href="#6-5-2-虚拟地址空间" class="headerlink" title="6.5.2 虚拟地址空间"></a>6.5.2 虚拟地址空间</h2><p>每个高级语言源程序经过编译，汇编，链接等处理后都会生成可执行的二进制机器目标代码时，都被映射到一个统一的虚拟地址空间。所谓“统一”是指不同的可执行文件所映射的虚拟地址空间大小一样，地址空间中的区域划分结构也相同。<strong>（虚拟地址空间不是真实存在的，只是人们创造出来好理解CPU的寻址的，自己理解，有错请纠正）</strong></p><p><img src="https://i.imgur.com/JAGtXPH.jpg" srcset="/img/loading.gif" alt></p><h2 id="6-5-3-虚拟存储器的实现"><a href="#6-5-3-虚拟存储器的实现" class="headerlink" title="6.5.3 虚拟存储器的实现"></a>6.5.3 虚拟存储器的实现</h2><h3 id="1-分页式虚拟存储器"><a href="#1-分页式虚拟存储器" class="headerlink" title="1.分页式虚拟存储器"></a>1.分页式虚拟存储器</h3><p>分页式虚拟存储系统中，虚拟地址空间被划分为大小相等的页面，硬盘和主存之间按页面为单位交换信息。虚拟地址空间中的页称为虚拟页，逻辑页或虚页（简称VP）；主存空间也被划分为同样大小的页宽（物理页，实页，PF或者PP)。<br></p><ol><li>未分配页: 虚拟空间中没有和任何内容相关联的页称为“未分配页”。（堆区和栈区）<br></li><li>已分配页：虚拟空间中对于代码和数据等有内容的区域所关联的页面。（已分配页又分为缓存页和未缓存页)<br></li><li>缓存页和未缓存页:已调入主存而被缓存在DRAM中的页面称为缓存页，未调入主存而存在硬盘中的页称为未缓存页。<br><blockquote><p><strong>主存和cache之间交换单位为主存块，硬盘和主存之间交换的单位为页面。</strong><br><br>由于硬盘和主存之间交换数据太慢，所以缺页的代价特别大。所以考虑到缺页代价的问题，通常将主存和硬盘交换的页设置的比较大。<br><br>因为缺页的的代价比较大，所以主存页框和虚拟页之间采用全映射的方式，处理一致性的问题用回写法。<br></p></blockquote></li></ol><p>与cache必须使用一种方法来建立各个虚拟页和所存放的主存页框号或磁盘上的存储位置之间的关系，通常用<strong>页表</strong>来描述这种对应关系。<br></p><p>(1).页表(进程页表和内核页表）</p><p>进程页表和内核页表区别可以看这篇博客<a href="https://blog.csdn.net/yyf_it/article/details/52460359" target="_blank" rel="noopener">https://blog.csdn.net/yyf_it/article/details/52460359</a><br></p><p><img src="https://i.imgur.com/OjOz1Ch.png" srcset="/img/loading.gif" alt><br></p><p><strong>系统中每个进程都有一个页表，操作系统在加载程序时，根据可执行文件中的程序头表，确定每个可分配段（如只读代码段，可读可写数据段）所在的虚页号及磁盘中存放的位置，在主存中生成一个初始页表，初始页表中的每个页表项对应装入位都是0，在程序执行过程中，通过缺页异常处理程序，将磁盘上的代码和数据页面装入分配的主存页框中，并修改页表中相应页表项，例如，将存放位置改为主存页框号，将页表项中装入位置1.(—-&gt;这里指的是进程页表)</strong></p><p>(2).地址转换<br><br>采用虚存机制的系统，指令给出的地址时虚拟地址，CPU执行指令时，首先要将虚拟地址转化成主存的物理地址，才能到主存中取指令和数据，地址转化又MMU来完成.<br></p><p><img src="https://i.imgur.com/FZ6Uorq.png" srcset="/img/loading.gif" alt></p><p>(3). 快表<br><br>采用虚拟内存后，访存的次数增多了，为了减少访存次数，所以往往把页表中最活跃的几个页表复制到高速缓存中，这种高速缓存中的页表项组成的页表称为<strong>后备转化缓存器（TLB）</strong>，通常<strong>快表</strong>。相应的主存中的页表称为 <strong>慢表</strong>。<br><br>TLB的概述:<br><br>TLB是一个内存管理单元用于改进虚拟地址到物理地址转换速度的缓存.<br><br>TLB是位于内存中的页表的cache，如果没有TLB，则每次取数据都需要两次访问内存,即查页表获得物理地址和取数据.<br><br><img src="https://i.imgur.com/5bB23Rs.png" srcset="/img/loading.gif" alt><br><br><strong>上图中访存过程解释:CPU给出一个32位的虚拟地址，首先，由CPU中的MMU进行虚拟地址到物理地址的转换；然后，由处理cache的硬件根据物理地址进行存储访问。<br><br>MMU对TLB查表时，20位虚拟页号被分为标记Tag和组索引两部分，首先由组索引确定到TLB中的那一组进行查找，查找时将虚拟页号的标记部分和TLB中该组每个标记字段同时进行比较。若由某个相等而且有效位为1，则TLB命中，此时可以通过TLB进行地址转化；否则TLB缺失，此时就需要去访问主存去查慢表。图中所示的是两级页表方式，虚拟地址被分为页目录索引和页表索引两部分，根据这两部分可得到对应的页表项，从而进行地址转化，并将对应页表项的内容送入TLB形成一个新的TLB表项，同时，将虚拟页号的高位分作为TLB标记填入新的TLB表项中，若TLB已满，还需要进行TLB替换，TLB采用随机替换策略。</strong></p><p>(4). CPU访存过程<br><br><img src="https://i.imgur.com/D6Enyiw.png" srcset="/img/loading.gif" alt></p><h3 id="2-分段式虚拟存储器"><a href="#2-分段式虚拟存储器" class="headerlink" title="2.分段式虚拟存储器"></a>2.分段式虚拟存储器</h3><p>可以把段作为基本的信息单位在主存-辅存之间传送和定位，分段方式下，将主存空间按实际程序中的段来划分，每个段在主存中的位置记录在段表中，段的长度可以变化，所以段表中需有长度指示，即段长。每个进程都有一个段表，每个段在段表中有个段表项，可以用来指明对应段在主存中的位置，段长，访问权限，使用和装入情况，段表本身映射一个可定位段，可以存在外存中，需要时调入主存，但一般驻留在主存。<br></p><p>优点：段的分界与程序的自然分界相对应，易于编译，管理，修改和保护。<br><br>缺点：段的起点和终点不定，给主存空间分配带来麻烦，而且容易在主存中留下许多空白的零碎空间，造成浪费。<br><br><img src="https://i.imgur.com/wiXjxF0.png" srcset="/img/loading.gif" alt></p><h3 id="3-段页式虚拟存储器（IA-32-Linux就是采用段页式）"><a href="#3-段页式虚拟存储器（IA-32-Linux就是采用段页式）" class="headerlink" title="3. 段页式虚拟存储器（IA-32+Linux就是采用段页式）"></a>3. 段页式虚拟存储器（IA-32+Linux就是采用段页式）</h3><p>在段页式虚拟存储器中，程序按模块分段，段内在分页，用段表和页表（每个段一个页表)进行两级定位管理。段表中每个表项对应一个段，每个段表项中包含一个指向该段页表起始位置的指针，以及该段其他的控制和存储包含信息，有页表指明该段各页在主存中的位置以及是否装入，修改等状态信息。</p><h2 id="6-5-4-存储保护"><a href="#6-5-4-存储保护" class="headerlink" title="6.5.4 存储保护"></a>6.5.4 存储保护</h2><p>目的：为了避免主存中多道程序互相干扰，防止某进程出错而破坏其他进程的正确性，或某进程不合法地访问其他进程的代码或者数据区，应该对每个进程进行存储保护。<br><br><strong>条件：为了对操作系统的存储保护提供支持，硬件必须具有以下三种基本功能:</strong><br></p><ol><li>使部分CPU状态只能由操作系统内核程序写，而用户进程只能读不能写。（例如：TLB内容，页表首地址等，只能操作系统内核程序才能用特殊的指令来写）<br></li><li>支持至少两种特权模式。(用户态，内核态)<br></li><li>提供让CPU在内核态和用户态之间相互转化的机制。（如果用户进程需要访问内核代码和数据，那么必须通过系统调用接口（执行陷阱指令）来间接访问，响应异常和中断可使CPU从用户态转到内核态，异常和中断处理后返回指令可以使CPU从内核态转到用户态。<br></li></ol><p>存储保护包括以下两种情况：访问权限保护和存储器区域保护。</p><ol><li>访问权限保护</li><li>存储区域保护（加界重定位，键保护，环保护）<br>加界重定位：每个程序和程序段都有起始和终止地址，不可以越界，在分段式虚存中，通过段表来记录段的上界和下届。<br><br>键保护：操作系统给主存中的每一个页框分配一个存储键，给每个用户程序设置一个程序键。进程运行时，将程序状态字寄存器中的键（程序键）和所访问的页的键（存储键）进行核对相符才可以访问。（相当于锁和钥匙的关系）。<br><br>环保护;主存中各进程按其重要性分为多个保护级，各个级别构成同心环，最内环的进程保护级别最高，向外逐次降低。<br></li></ol><h2 id="6-6-IA-32-Linux中的地址转换"><a href="#6-6-IA-32-Linux中的地址转换" class="headerlink" title="6.6 IA-32+Linux中的地址转换"></a>6.6 IA-32+Linux中的地址转换</h2><p>在保护模式下，IA-32采用段页式虚拟存储管理方式，存储空间采用逻辑地址，线性地址，物理地址来进行描述。逻辑地址就是虚拟地址，IA-32中的逻辑地址由48位组成，包括16位段选择符和32位段内偏移量（即有效地址），为了便于多用户，多任务下的存储管理，IA-32采用分段基础上的分页机制。分段过程实现逻辑地址转换为线性地址，分页过程再实现将线性地址转换为物理地址。<br></p><h3 id="6-6-1逻辑地址到线性地址的转换"><a href="#6-6-1逻辑地址到线性地址的转换" class="headerlink" title="6.6.1逻辑地址到线性地址的转换"></a>6.6.1逻辑地址到线性地址的转换</h3><p>1.段选择符和段寄存器<br><br>TI表示段选择符要选择哪一个段描述符表，TI=0选全局描述符表（GDT），TI=1选局部描述符表（LDT）。<br><br>RPL用来定义段选择符的特权等级RPL=00 表示第0级，是最高级的内核态，若RPL=11，则为第3级是最低级的用户态。<br><br><img src="https://i.imgur.com/nJ5XZzb.png" srcset="/img/loading.gif" alt></p><p>段寄存器：<br><br>CS：代码段寄存器<br><br>SS:   栈段寄存器<br><br>DS：数据段寄存器<br><br>ES，FS，GS：可以指向任意段寄存器。<br></p><p>2.段描述符<br></p><p><img src="https://i.imgur.com/WbAh8dm.png" srcset="/img/loading.gif" alt><br><br>特权位和访问权限的含义说明如下：<br><br>G:表示粒度大小，G=1说明段以页（4KB）为基本单位；G=0则段以字节为基本单位。由于界限为20位，所以G=0时，最大的段位2<sup>20</sup> X 1B = 1MB;当G = 1时最大的段位2<sup>20</sup> X 4KB=4GB。<br><br>D: D=1表示地址和数据位32位宽，D=0表示地址和数据为16位宽。<br><br>P: 说明段是否存在主存中。P=1表示存在，P=0表示不存在。Linux总是把P置成1，因为它从来不会把一个段交换到磁盘上而是以页为单位进行交换。<br><br>DPL：访问段时对当前特权级的最低等级要求，只有CPL=0（内核态)时才能访问DPL=0的段，任何进程（CPL=3或者0) 都可以访问DPL=3的段。<br><br>S: S=0表示是系统控制段描述符，S=1表示是普通代码段或者数据段描述段。<br><br>TYPE： 指示段的访问权限或者系统控制段描述符的类型。<br><br>A：说明段是否被访问过。A=1代表段被访问过，A=0代表没有被访问过。<br><br>AVL：可以由操作系统定义使用。Linux忽略这个字段。<br></p><p>3.段描述符表<br><br>段描述符表就是分段方式下的段表，由段描述符组成，主要有三个类型：全局描述符表（GDT），段描述符表（LDT）和中断描述符表（IDT）。</p><p>4.用户不可见寄存器<br><br>除了六个段寄存器以外，还提供了多个用户进程不可以直接访问的内部寄存器，它们包括描述符cache，任务寄存器（TR），局部描述符表寄存器（LDTR），全局描述表寄存器（GDTR）和中断描述符寄存器（IDTR）。操作系统通过特权指令可对寄存器TR，LDTR，GDTR，IDTR进行读写。<br></p><p><img src="https://i.imgur.com/iIjOFER.jpg" srcset="/img/loading.gif" alt><br>描述符cache：其作用如上图描述。<br><br>全局描述符表寄存器（GDTR）：高32位存放GDT首地址，低16位存放界限。<br><br>中断描述符表寄存器（IDTR）：高32位存放IDT首地址，低16位存放界限<br><br><strong>局部描述符表寄存器（LDTR）（LDTR有点不同）：是16位寄存器，存放局部描述符表LDT的段选择符，通过该选择符可把GDT中的LDT描述符表中的部分信息（包括LDT首地址，LDT界限和访问权限）装入LDT描述符cache中从而使CPU可以快速访问LDT</strong><br><br>任务寄存器（TR）也是16位，用来存放任务状态段（TSS）的段选择符，通过该段选择符可把GDT表中的TSS描述符中部分信息（包括TSS首地址，TSS界限和访问权限等），装入TSS描述符cache中，从而可以方便的对任(即用户进程）的状态信息进行访问。<br></p><p>5.逻辑地址向线性地址的转换<br><br><strong>访问LDT表的过程<br></strong><br><img src="https://i.imgur.com/zbAkDhE.jpg" srcset="/img/loading.gif" alt><br><br><strong>访问GDT表的过程<br></strong><br><img src="https://i.imgur.com/F1oceHG.jpg" srcset="/img/loading.gif" alt><br></p><p><strong>注意：Linux中用户态和内核态的每个段的线性地址都是从基地址0开始，都是以4KB为粒度（G=1),所以所有逻辑地址中的段内偏移量（即有效地址）就是其线性地址。</strong></p><h3 id="6-6-2-线性地址到物理地址的转换"><a href="#6-6-2-线性地址到物理地址的转换" class="headerlink" title="6.6.2 线性地址到物理地址的转换"></a>6.6.2 线性地址到物理地址的转换</h3><p>IA-32采用段页式虚拟存储管理方式，通过分段方式完成逻辑地址到线性地址的转换后，再进行一步<strong>通过分页方式将线性地址转化为物理地址</strong>。<br></p><p>先介绍IA-32中的控制寄存器：<br><br>1.控制寄存器<br><br>CR0：CR0控制寄存器定义了多个控制位：<br></p><blockquote><p>1.保护模式允许位PE:PE=0(实地址模式），PE=1（保护地址模式）。<br><br>2.分页允许位PG: PG=1启用分页部件工作，PG=0则禁止分页部件工作，此时线性地址被直接作为物理地址使用。<br><br>3.任务切换位TS:每次任务切换时将其置1，任务切换完毕则清0。<br><br>4.对齐屏蔽位AM:它可以与EFLAGS中的AC位配合使用，若AM=1且AC=1，则进行对齐检查，若AM=0，则禁止对齐检查。<br><br>5.cache功能控制位NW和CD，只有NW和CD均为0时，cache才能工作。<br></p></blockquote><p>CR2是页故障线性地址寄存器，存放引起页故障（即缺页）的线性地址。只有CR0中的PG=1时,CR2才有效。<br><br>CR3是页目录基址寄存器，用来保存页目录再内存的起始地址，只有CR0中的PG=1时，CR3才有效。<br></p><p>2.线性地址向物理地址的转换<br><br><img src="https://i.imgur.com/4uRy7dZ.jpg" srcset="/img/loading.gif" alt><br><br>上述转换过程中10位的页目录索引（Directory）和页表索引（Table）都要乘以4，因为每个页目录项和页表项都是32位（4B),占4个字节。<br><br><img src="https://i.imgur.com/Ws6ibdj.png" srcset="/img/loading.gif" alt><br></p><blockquote><p>P: P=1表示页表或者页在主存中，P=0表示不再主存中，此时页故障（缺页异常），需要将页故障线性地址记录在CR2中，操作系统在处理页故障时会将缺失的页表或页从硬盘装入主存中，并重新执行页故障的指令。<br><br>R/W:该位为0时表示页表或者页只能读不能写，为1时表示可读可写。<br><br>U/S：该为为0时表示用户进程不能访问，为1时允许用户进程访问，该位可以保护操作系统所使用的页不受用户进程的破坏。<br><br>PWT: 用来控制页表对应的cache写策略时全写还是回写。<br><br>PCD：用来控制页表或者页能否被缓存到cache中。<br><br>A: A=1表示页或者页表被访问过，初始化时操作系统将其清0，利用该标志，操作系统可以清楚的了解哪些页表或者页正在使用，一般选择长期未用的页或者最少使用的页调出主存。<br><br>D :脏位或者叫修改位，该位在页目录项中没有意义，在页表项中有意义，D=1表示该页被修改过，D=0表示没有被修改过，修改过的页，操作系统在把该页清理出主存时会把它回写到硬盘中。<br></p></blockquote><h2 id="Linux系统的虚拟存储管理"><a href="#Linux系统的虚拟存储管理" class="headerlink" title="Linux系统的虚拟存储管理"></a>Linux系统的虚拟存储管理</h2><p>“进程”的引入 除了为应用程序提供一个独立的逻辑控制流，还为应用程序提供了私有的地址空间，<strong>使的程序员以为自己的程序在执行的过程中独占拥有存储器（幻觉！）</strong>，这个私有地址空间就是虚拟地址空间。<br><br><img src="https://i.imgur.com/xHjPSX3.png" srcset="/img/loading.gif" alt><br></p><p><strong>目前比较新的Linux发行版，用objdump去查看这些可执行文件的反汇编代码，会发现其代码起始位置不是在0x8048000（IA-32）或者0x400000(x86-64)而是在地址0附近，这主要是为了提高代码的安全性而采用了ASLR技术（地址空间随机化技术）。</strong></p><h3 id="Linux虚拟地址空间中的区域"><a href="#Linux虚拟地址空间中的区域" class="headerlink" title="Linux虚拟地址空间中的区域"></a>Linux虚拟地址空间中的区域</h3><p>Linux内核为每个进程维护了一个<strong>进程描述符</strong>（类似段描述符之类的），数据类型为task_struct结构，task_struct中记录了内核运行该进程所需要的所有信息，例如，进程的PID，指向用户栈的指针，可执行目标文件的文件名等。<br><br><img src="https://i.imgur.com/vqiVOte.png" srcset="/img/loading.gif" alt><br><br>task_struct结构中有个指针mm指向一个mm_struct描述的对应进程虚拟存储空间的当前状态，其中有一个字段是pgd，它指向对应进程的第一级页表（页目录表）的首地址，因此，当处理器运行对应的进程时，内核会将它送到CR3控制寄存器中，mm_struct中还有一个字段mmap，它指向一个由vm_area_struct构成的链表表头。Linux采用链表方式管理用户空间中的区域，使得内核不用记录那些不存在的“空洞”页面。<br><br>每个vm_area_struct描述了对应进程虚拟存储空间中的一个区域，vm_area_struct中部分字段如下：<br><br>vm_start: 指向区域开始处<br><br>vm_end:指向区域结束处<br><br>vm_prot：描述区域包含的所有页面的访问权限<br><br>vm_flags：描述区域包含的页面是否与其他进程共享<br><br>vm_next：指向链表下一个vm_area_struct<br></p><h3 id="Linux中页故障处理"><a href="#Linux中页故障处理" class="headerlink" title="Linux中页故障处理"></a>Linux中页故障处理</h3><p><strong>当CPU中的MMU在对某地址VA进行地址转换时，若检测到页故障，则转入操作系统内核进行页故障处理，Linux内核根据上述对虚拟地址空间中各区域的描述，将VM与vm_area_struct链表中每一个vm_start，vm_end进行比较，以判断VA是否属于空洞页面。若是，则发生“段故障”，若不是，则在判断所进行的操作是否和所在区域的访问权限 相符（由vm_prot描述）。若不相符，例如 假定VA为代码区，访问权限是PROT_EXE（可执行），但对地址VA的操作是“写”,那么就发生了“访问越权”；假定在用户态下访问属于内核的区域，访问权限为PORT_NONE（不可访问），那么就发生了“访问越级”，段故障和访问越级和访问越权都会导致终止当前进程。<br><br>若不是发生上述的情况，则内核判断发生了正常的缺页异常，把硬盘内的页装入主存中返回缺页指令处继续执行。<br></strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础-袁春风</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符号表和符号解析</title>
    <link href="undefined2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/"/>
    <url>2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h1><p>链接器在生成一个可执行文件时，必须完成符号解析，而要进行符号解析就必须要使用符号表。<br></p><p>符号类型：全局符号，外部符号，本地符号。<br><br>以模块m为例：包括在符号表中的符号有以下三种不同类型<br><br>全局符号：在模块m中定义并被其他模块引用的符号，这类符号包括：非静态的函数名和定义为不带static属性的全局变量名。<br><br>外部符号：在其他模块定义并被m引用的符号，包括在其他模块定义的外部函数名和外部变量名。<br><br>本地符号：在模块m中定义并在m中引用的本地符号，这类符号包括带static属性的函数名和全局变量名。<br></p><p><strong>注意：上述三类符号不包括分配在栈中的非静态局部变量（auto变量），链接器不需要这一类变量的信息，因而他们不在节.symtab定义的符号表中。（指的是符号表中的符号在.data和.bss中的符号，和栈中的符号没关系）</strong><br></p><p>符号表里面装了：<br>1.符号在字符串表中的索引（st_name）<br><br>2.符号的值（st_value)在可重定位文件中，是指符号所在位置相对于所在节起始位置的字节偏移量。在可执行目标文件和共享文件中，st_value则是符号所在的虚拟地址。<br><br>3.符号的类型（st_info)指出符号的类型和绑定属性，如未指定的（NOTYPE），变量（OBJECT），函数（FUNC），节（SECTION)等。<br></p><h1 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h1><p>符号解析的目的是将每个模块中引用的符号与某个目标模块中的定义符号建立关联。每个定义符号在代码段或数据段都被分配了存储空间，因此，将引用符号与对应的定义符号建立关联后，就可以在重定位时将引用符号的地址重定位为定义符号的地址。<br></p><p>编译器的对源程序编译时，会把每个全局符号输出在汇编代码文件中，每个全局符号或者是强符号或者弱符号。编译器把全局符号的强弱特性，隐含地编码在可重定位目标文件的符号表中，以供链接时符号解析所用。<br></p><h2 id="全局符号的强，弱特性"><a href="#全局符号的强，弱特性" class="headerlink" title="全局符号的强，弱特性"></a>全局符号的强，弱特性</h2><p><strong>强符号：函数名或者已初始化的全局变量名是强符号，未初始化的全局变量是弱符号，本地符号没有强弱之分。</strong><br></p><p>1.强符号不能多次定义，也就是强符号只能被定义一次，否者链接错误。<br><br>2.若一个符号被说明为一次强符号定义和多次弱符号定义，则按照强符号定义为准。<br><br>3.若有多个弱符号定义，则任选其中一个。<br></p><h2 id="符号解析过程"><a href="#符号解析过程" class="headerlink" title="符号解析过程"></a>符号解析过程</h2><p>链接器按照所有可重定位目标文件和静态库文件出现在命令行中的顺序从做到右依次扫描他们，在此期间要维护多个集合。<br><br>集合E：是将被合并在一起组成可执行文件的所有目标文件的集合。<br><br>集合U：是为解析符号的集合。<br><br>集合D：是指当前为止已被加入到E的所有目标文件中定义符号的集合。<br></p><p>符号解析开始时三个集合都是空集：然后对命令行输入一个文件f<br><br>如果f是目标文件就把f加入E，在根据f文件中未解析的符号和定义符号分别对U,D进行修改。<br><br>如果f文件是库文件，链接器就会尝试把U中未解析的符号和f中各个模块的符号进行匹配。如果f中的某个目标模块定义了一个U中的一个或者多个符号就把这个模块加入E，被定义的符号加入D，若没有定义则抛弃。<br><br>如果处理过程中出现双重定义就是一个符号在D中出现两次，或者扫描完成了U中还有未定义符号（U非空的话），链接器报错。<br></p><p>静态链接时，命令时从左到右读，而且库文件的顺序要按照引用关系来写。<br><br>命令：gcc - static -o xxxxx main.o ./libc.a （libc.a也可以不写，链接器会自动在最后加上去）<br></p><img src="/2019/10/30/%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90/%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5.jpg" srcset="/img/loading.gif" class title="可重定位目标文件与静态库的链接">]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标文件格式</title>
    <link href="undefined2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="ELF目标文件格式"><a href="#ELF目标文件格式" class="headerlink" title="ELF目标文件格式"></a>ELF目标文件格式<br></h1><p>目标文件格式有很多种，例如：System V UNIX 的COFF，window 的PE，Linux 的ELF。<br></p><h1 id="链接视图"><a href="#链接视图" class="headerlink" title="链接视图"></a>链接视图</h1><h3 id="可重定位目标文件格式"><a href="#可重定位目标文件格式" class="headerlink" title="可重定位目标文件格式"></a>可重定位目标文件格式</h3> <img src="/2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20180708185336199.png" srcset="/img/loading.gif" class title="ELF可重定位目标文件"><br><p><strong>(1).ELF头</strong><br><br>ELF头位于目标文件的起始位置，包括文件结构说明信息。ELF头的数据结构分为32位系统对于结构和64位系统对应结构。(可以使用readelf -h 命令对某个可重定位目标文件的ELF头进行解析。例如：对main.o头文件进行解析：readelf -h main.o）<br><br><strong>(2).节</strong><br><br>节是ELF文件的主体信息，包含了链接过程所用的目标代码信息，包括指令，数据，符号表和重定位信息等。<br><br>.text :目标代码部分<br><br>.rodata:只读数据节<br><br>.data:已初始化全局变量<br><br>.bss:未初始化的全局变量（不占据实际的磁盘空间）<br><br>.symtab：符号表，程序中定义的函数名和全局静态变量名都属于符号，与这些符号相关的信息也保存在符号表中。<br><br>.rel.text: .text节相关的可重定位信息。当链接器将某一个目标文件和其他目标文件组合时，.text节中的代码被合并后，一些指令中引用的操作地址信息或跳转目标指令的位置信息等都可以能被修改，通常，调用外部函数或引用全局变量的指令中的地址字段需要修改。<br><br>.rel.data:.data节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时, .data节中的代码被合并后，一些全局静态变量的地址可能被修改。<br><br>.debug:调试用符号表，有些表项对定义的局部变量和定义的类型进行说明，有些表项对定义和引用的全局静态变量进行说明。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.line：C源程序中的行号和.text节中机器指令之间的映射。只有使用带-g选项的gcc命令才能得到这张表。<br><br>.strlab:字符串表，包括.symtab节和.debug节中的符号以及节头表中的节名。字符串表就是以null结尾的字符串序列。<br><br><strong>(3).节头表</strong><br><br>节头表由若干个表项组成，每个表现描述相应的一个节的节名，在文件中的偏移，大小，访问属性，对齐方式等。</p><h2 id="执行视图"><a href="#执行视图" class="headerlink" title="执行视图"></a>执行视图</h2><img src="/2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/fSqCY0UBZnX35qDCxjx67h98ps8JduKzOqgUQBtL.png" srcset="/img/loading.gif" class title="ELF可执行目标文件"><br><p>与ELF可重定位文件不同的是：<br><br><strong>1.</strong>ELF头文件中的字段e_entry给出了系统将控制权转移到虚拟地址（入口点），即执行程序时第一条指令的地址而可重定位文件中，此字段为0。<br><br><strong>2.</strong>多了一个.init节，其中.init节定义了一个_init函数用来可执行目标文件开始执行时的初始化工作，当程序开始时，系统进入主函数之前先执行这个节中的指令代码。<br><br><strong>3.</strong>去掉了用去重定位的节.rel.text和.rel.data（因为已经重定位完毕了）。<br><br><strong>4.</strong>多了一个程序头表：也叫做段头表，是一个结构数组。<br></p><h2 id="可执行文件的存储器映像"><a href="#可执行文件的存储器映像" class="headerlink" title="可执行文件的存储器映像"></a>可执行文件的存储器映像</h2><img src="/2019/10/29/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20170621205440745.png" srcset="/img/loading.gif" class title="可执行文件的存储器映像"><br><p>当启动一个一个可执行目标文件时，首先会通过某种方式调出常驻内存的一个称为加载器（loader)的操作系统程序来进行处理，例如，任何的Unix程序的加载执行都是通过调用execve目标文件中相关节的内容与虚拟地址空间中的只读代码段和可读写代码段通过页表建立映射，然后启动可执行目标文件中的第一条指令执行。（这里关系到页表的内容在6.5节还没学到)</p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第4章—程序的链接</title>
    <link href="undefined2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/"/>
    <url>2019/10/29/%E7%AC%AC4%E7%AB%A0%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-程序的链接-小结《课本214页》"><a href="#第4章-程序的链接-小结《课本214页》" class="headerlink" title="第4章 程序的链接-小结《课本214页》"></a>第4章 程序的链接-小结《课本214页》</h1><p><strong>1.</strong>链接器位于编译器，指令集体系结构和操作系统的交叉点上，涉及指令系统，代码生成，机器语言，程序转换和虚拟存储管理等诸多概念。<br><br><strong>2.</strong>链接处理涉及三种目标文件格式：可重定位目标文件，可执行目标文件和共享库目标文件。<br><br><strong>3.</strong>共享库文件是一中特殊的可定位目标文件。<br><br><strong>4.</strong>ELF目标文件格式有链接视图和执行视图两种，前者是可重定位目标格式，后者是可执行目标格式。<br><br>链接视图包括：ELF头，各种节，节头表。<br><br>执行视图包括：ELF头，程序头表，各种节组成的段。<br><br><strong>5.</strong>链接包括两种链接形式：一是：静态链接，二是：动态链接。<br><br>静态链接：就是将多个可重定位文件中的相同类型的节合并起来以生成完全链接的可执行目标文件，它的所有符号引用都是确定的虚拟地址空间中的最终地址，因而可以直接被加载执行。<br><br>动态链接：动态链接模式下的可执行目标文件是部分链接的，还有一部分的引用地址没有确定，需要利用共享库中的定义符号进行重定位，因而需要由动态链接器来加载共享库并重定位可执行文件中部分文件的引用。<br><br>动态链接又有两种形式分别是：一种是可执行目标文件加载时进行共享库的动态链接；另一种时可执行目标文件执行时进行共享库的动态链接。<br><br><strong>6.</strong>在不同模块可能会定义相同的符号 <strong>（这里说的符号指的是被写入.data节.bss节中的符号，不包括执行时栈中的符号）</strong>，因为相同的多个符号只能分配一个地址，所以链接器以哪个符号为准？编译器通过对定义符号标识是强符号还是弱符号，由链接器根据一套规则来确定多重定义符号中哪个为唯一的定义符号。<br><br><strong>7.</strong>加载器在加载可执行目标文件时，实际上只是把可执行目标文件中的只读代码段和可读写数据段通过页表映射到了虚拟地址空间中的确定位置，并没有真正的把代码和数据从磁盘装入主存。<br></p><h1 id="过程梳理："><a href="#过程梳理：" class="headerlink" title="过程梳理："></a>过程梳理：</h1><p><strong>预处理–&gt;编译–&gt;汇编–&gt;链接</strong><br></p><h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="(1.)预处理"></a>(1.)预处理</h2><p>对预处理文件命令进行处理，包括对头文件的包含，对宏的扩展，条件编译的选择等，例如：#include&lt;xxxx.h&gt;把xxxx.h文件的内容插入源程序文件中。<br><br>gcc命令：“gcc - E main.c -o main.i”和“ cpp main.c -o main.i”<br></p><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="(2.)编译"></a>(2.)编译</h2><p>编译器把代码进行优化（也可以不进行优化）和存储分配，最终把C语言源程序翻译成汇编语言程序。<br><br>gcc命令：“gcc -S main.i -o main .s”和 “ccl main.i -o main.s”<br></p><h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="(3.)汇编"></a>(3.)汇编</h2><p>把汇编语言代码转化为机器语言代码生成可重定位目标文件(.o文件）。<br><br>gcc命令：“gcc -c main.s -o main.o” 和 “as main.s -o main.o”<br></p><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="(4.)链接"></a>(4.)链接</h2><p>将所以有关联的可重定位目标文件组合起来，以生成一个可执行文件。（好处：模块化，效率高）<br></p><p>链接包括两步：<br></p><h3 id="1-符号解析"><a href="#1-符号解析" class="headerlink" title="1.符号解析"></a>1.符号解析</h3><p>将每一个符号引用与一个确定的符号定义建立关联。<br><br>符号包括:全局静态变量名和函数名，而非静态局部变量名则不是符号。编译器将所有的符号存放在可重定位目标文件的符号表中。<br></p><h3 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2.重定位"></a>2.重定位</h3><p>可重定位目标文件中的代码区和数据区都是从地址0开始的，链接器需要将不同模块中相同的节合并起来生成一个新的单独的节，并将合并后的代码区和数据区按照ABI规范确定虚拟地址空间划分（也称存储器映像）来重新确定位置。<br><br>例如，对于32位Linux系统存储器映像，其只读代码总是从地址0x8048000开始，而可读可写数据段总是在代码段后面（从下到上）第一个4KB对齐的地址处开始，因而链接器余姚重新确定每条指令的每个数据的地址，并且在指令中需要明确给定的引用符号的地址，这种重新定义代码和数据地址并更新指令中引用地址符号的地址的工作叫做重定位。<br></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统基础-袁春风</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC内嵌汇编中常见的constraint</title>
    <link href="undefined2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/"/>
    <url>2019/10/27/GCC%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84constraint/</url>
    
    <content type="html"><![CDATA[<p>1.”a”代表AL/AX/EAX/RAX寄存器<br><br>2.”b”代表BL/BX/EBX/RBX寄存器<br><br>3.”c”代表CL/CX/ECX/RCX寄存器<br><br>4.”d”代表DL/DX/EDX/RDX寄存器<br><br>5”D”代表DI寄存器<br><br>6.”S”代表SI寄存器<br><br>7.”m”代表内存操作数<br><br>8.”r”,”q”代表寄存器操作数（就是随便一个寄存器）<br><br>9.”i”代表立即数操作数<br><br>10.”f”代表浮点寄存器操作数<br><br>11.”F”代表浮点立即数操作数<br><br>12.”o”内存操作数，要求内存地址范围是在同样一个段内<br><br>13.”v”内存操作数，但是不在同一个段内<br><br>14.”n”一个确定值的立即数<br></p>]]></content>
    
    
    <categories>
      
      <category>内嵌汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内嵌汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏，#define</title>
    <link href="undefined2019/10/27/%E5%AE%8F%EF%BC%8C-define/"/>
    <url>2019/10/27/%E5%AE%8F%EF%BC%8C-define/</url>
    
    <content type="html"><![CDATA[<p>转载<br><br>原文链接：<a href="https://blog.csdn.net/Boring_Wednesday/article/details/78756696" target="_blank" rel="noopener">https://blog.csdn.net/Boring_Wednesday/article/details/78756696</a><br></p><div id="content_views" class="markdown_views">                    <!-- flowchart 箭头图标 勿删 -->                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/>                    </svg>                                            <h3 id="写在前面"><a name="t0"></a>写在前面：</h3><h3 id="本文所有代码均在linux环境下运行"><a name="t1"></a>本文所有代码均在<strong>Linux</strong>环境下运行</h3><h3 id="linux版本为centos-74"><a name="t2"></a><strong>Linux</strong>版本为CentOS 7.4</h3><hr><h3 id="宏定义"><a name="t3"></a>宏定义</h3><blockquote>  <h4 id="语法">语法</h4>  <h4 id="define-name-stuff">#define name Stuff</h4></blockquote><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PI 3.14</span><span class="hljs-comment">//定义一个M，值为3.14</span><span class="hljs-preprocessor">#define DO_FOREVER for(;;)</span><span class="hljs-comment">//定义一个死循环</span><span class="hljs-preprocessor">#define REG register</span><span class="hljs-comment">//定义REG来作为register的别名</span><span class="hljs-preprocessor">#define CASE break;case</span><span class="hljs-comment">//在switch中用CASE来补上break;</span><span class="hljs-preprocessor">#define DEBUG_PRINT printf("file:%s\tline:%d\tdate:%s\ttime:%s\n",\</span>                        __FILE__, __LINE__, __DATE__, __TIME__);<span class="hljs-comment">//测试预定义符号</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre><h3 id="1宏的作用范围"><a name="t4"></a>1、<strong>宏</strong>的<strong>作用范围</strong></h3><h4 id="先看下面代码">先看下面代码：</h4><p><img src="https://img-blog.csdn.net/20171209164450664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="让我们查看上图中代码经过预处理后的样子">让我们查看上图中代码经过预处理后的样子</h4><p><img src="https://img-blog.csdn.net/20171209165200867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以发现宏只对宏定义后的行数起作用且与定义在哪里无关即使函数不被调用也可以使用宏"><strong>可以发现宏只对宏定义后的行数起作用，且与定义在哪里无关，即使函数不被调用，也可以使用宏</strong></h4><h3 id="2宏替换的原则"><a name="t5"></a>2、<strong>宏替换</strong>的<strong>原则</strong></h3><h4 id="在程序中扩展define定义符号和宏时需要涉及几个步骤">在程序中扩展#define定义符号和宏时，需要涉及几个步骤。</h4><blockquote>  <h4 id="1-在调用宏时首先对参数进行检查看看是否包含任何由define定义的符号如果是它们首先被替换">1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。</h4>  <h4 id="2-替换文本随后被插入到程序中原来文本的位置对于宏参数名被他们的值替换">2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。</h4>  <h4 id="3-最后再次对结果文件进行扫描看看它是否包含任何由define定义的符号如果是就重复上述处理过程">3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。</h4></blockquote><h4 id="注意"><strong>注意</strong>：</h4><blockquote>  <h4 id="1宏函数不能出现递归">1、宏函数<strong>不能</strong>出现<strong>递归</strong></h4>  <h4 id="2宏定义的符号即name部分不会在预处理替换的时候被搜索">2、宏定义的符号，即name部分<strong>不会</strong>在预处理替换的时候被搜索</h4></blockquote><h3 id="3宏定义define后不需要加"><a name="t6"></a>3、宏定义#define后不需要加<code>;</code></h3><blockquote>  <h4 id="例如">例如：</h4>  <h4 id="define-m-100">#define M 100;</h4>  <h4 id="这里在100后面加上了">这里在100后面加上了<code>;</code></h4>  <h4 id="在句子中有时候就会出现问题">在句子中有时候就会出现问题</h4></blockquote><h4 id="观察下面代码片段">观察下面代码片段：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define M 100;</span><span class="hljs-keyword">if</span> (condition)    m = M；<span class="hljs-keyword">else</span>    max = <span class="hljs-number">0</span>；<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="在该选择语句中会出现语法错误没有与else与之匹配的if语句">在该选择语句中会出现语法错误，没有与else与之匹配的if语句</h4><h3 id="4宏函数申明"><a name="t7"></a>4、<strong>宏函数</strong>申明</h3><blockquote>  <h4 id="宏函数申明格式"><strong>宏函数申明格式：</strong></h4>  <h4 id="define-name-parament-list-stuff">#define name ( parament-list ) stuff</h4>  <h4 id="parament-list为参数表可以包含多个参数他们会在stuff出现">parament-list为参数表，可以包含多个参数，他们会在stuff出现</h4></blockquote><h4 id="例如-1"><strong>例如：</strong></h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQARE( X ) X*X</span><span class="hljs-comment">//定义一个计算乘方的宏函数</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><h4 id="但是这么定义是会出现预料之外的错误的观察下面代码片段">但是这么定义是会出现<strong>预料之外</strong>的错误的，观察下面代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define SQUARE(X) X*X</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, SQUARE(a+<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="本来结果应该为62-36">本来结果应该为6^2 = 36</h4><p><img src="https://img-blog.csdn.net/20171209161434163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="但是实际计算机输出的结果为11">但是实际计算机输出的结果为11</h4><h4 id="我们用gcc观察预处理后的代码片段是怎么样的">我们用gcc观察预处理后的代码片段是怎么样的</h4><h4 id="使用命令-gcc-e-testc-o-testi来查看预处理后的代码">使用命令<code>$ gcc -E test.c -o test.i</code>来查看预处理后的代码</h4><p><img src="https://img-blog.csdn.net/20171209162424712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="可以看到这里原式被替换成-a-1-a-1-11而这个结果显然不是我们期望的">可以看到这里原式被替换成 a + 1 * a + 1 = 11，而这个结果显然不是我们期望的</h4><h4 id="这里我们提出解决方案将-x-用括号括起来x这样就避免上述代码因符号优先级带来的错误">这里我们提出解决方案，将 X 用括号括起来（X），这样就避免上述代码因符号优先级带来的错误</h4><h4 id="至此上面代码解决了来看下面的宏函数定义">至此，上面代码解决了，来看下面的宏函数定义：</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define DOUBLE(X) (X) + (X)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">10</span> * DOUBLE(a));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="期望结果为100而看程序执行结果">期望结果为100，而看程序执行结果：</h4><p><img src="https://img-blog.csdn.net/20171209163654504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="程序再次出现预料之外的结果原因是原式被替换成了">程序再次出现预料之外的结果，原因是原式被替换成了</h4><h4 id="10-5-5-55">10 * 5 + 5 = 55</h4><h4 id="解决方法"><strong>解决方法：</strong></h4><h4 id="在宏函数定义时对stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题">在宏函数定义时，对Stuff中的参数以及结果均用括号来避免因符号运算优先级带来的问题</h4><h3 id="5宏中的和"><a name="t8"></a>5、宏中的<strong>#</strong>和<strong>##</strong></h3><h4 id="的用法"><strong>#的用法</strong></h4><h4 id="首先要理解一个原则即邻近字符串连接原则">首先要理解一个原则，即<strong>邻近字符串连接原则</strong></h4><blockquote>  <h4 id="在c语言中">在C语言中</h4>  <h4 id="printfhello-worldn">printf(“hello”” world!”“\n”);</h4>  <h4 id="这句话是合法的">这句话是合法的</h4>  <h4 id="打印结果为">打印结果为：</h4>  <h4 id="hello-world">hello world!</h4></blockquote><h4 id="按照上述原则我们可以写出下列代码">按照上述原则，我们可以写出下列代码:</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define PRINT(FORMAT, VALUE) printf("the value of " #VALUE " is "FORMAT"\n", VALUE)</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    PRINT(<span class="hljs-string">"%d"</span>, i + <span class="hljs-number">3</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h4 id="看下gcc编译后的代码程序正常运行">看下gcc编译后的代码，程序正常运行：</h4><p><img src="https://img-blog.csdn.net/20171209173118273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="我们再通过gcc生成testi文件看下预处理是怎么样的">我们再通过gcc生成test.i文件看下预处理是怎么样的：</h4><p><img src="https://img-blog.csdn.net/20171209173520670?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQm9yaW5nX1dlZG5lc2RheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="欢迎访问jo-qzy的博客" title></p><h4 id="所以我们可以看出来的作用">所以我们可以看出来<strong>#的作用：</strong></h4><h4 id="将一个宏参数变成一个对应的字符串">将一个<strong>宏参数</strong>变成一个<strong>对应的字符串</strong></h4><h4 id="在上述例子中">在上述例子中：</h4><blockquote>  <h4 id="value被替换成了i-3"><strong>#VALUE</strong>被替换成了<strong>“i + 3”</strong></h4>  <h4 id="别忘了被替换的时候i-3两边加上了双引号">别忘了被替换的时候i + 3两边<strong>加上了双引号</strong></h4></blockquote><h4 id="的用法-1"><strong>##的用法</strong></h4><h4 id="看下面的代码片段">看下面的代码片段</h4><pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#define ADD_TO_AN(num, value) a##num += value</span><span class="hljs-keyword">int</span> main(){    <span class="hljs-keyword">int</span> a1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> a2 = <span class="hljs-number">0</span>;    ADD_TO_AN(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);    ADD_TO_AN(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><h4 id="解释一下上面这段代码">解释一下上面这段代码</h4><h4 id="假设有一个变量叫a1">假设有一个变量叫a1</h4><h4 id="此时代码片段为addtoan1-5">此时代码片段为ADD_TO_AN(1, 5)</h4><h4 id="即替换为a1-5给a1变量增加5">即替换为a1 += 5，给a1变量增加5</h4><h4 id="同理addtoan2-6则替换成a2-6">同理ADD_TO_AN(2, 6)则替换成a2 += 6</h4><blockquote>  <h4 id="的作用"><strong>##的作用</strong></h4>  <h4 id="将两边的字符连在一起作为一个标识符">将##两边的字符连在一起作为一个标识符</h4>  <h4 id="前提连接后的标识符必须合法否则编译出现标识符未定义">前提连接后的标识符必须合法，否则编译出现标识符未定义</h4></blockquote><h3 id="6宏和函数"><a name="t9"></a>6、<strong>宏</strong>和<strong>函数</strong></h3><h4 id="宏通常被应用于执行简单的运算">宏通常被应用于执行简单的运算</h4><h4 id="和函数相比宏有他的优点">和函数相比，宏有他的优点</h4><blockquote>  <h4 id="宏的优点"><strong>宏的优点：</strong></h4>  <h4 id="1-用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多所以宏比函数在程序的规模和速度方面更胜一筹">1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以<strong>宏比函数在程序的规模和速度方面更胜一筹</strong></h4>  <h4 id="2-更为重要的是函数的参数必须声明为特定的类型所以函数只能在类型合适的表达式上使用反之这个宏怎可以适用于整形长整型浮点型等可以用于来比较的类型宏的参数与类型无关的">2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于<code>&gt;</code>来比较的类型。<strong>宏的参数与类型无关的</strong></h4>  <h4 id="3-宏参数可以使用变量类型而函数不可以例如">3. 宏参数<strong>可以使用变量类型</strong>，而函数不可以，例如：</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs cs has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MALLOC(num, type) (type *)malloc(num * sizeof(type))</span>MALLOC(<span class="hljs-number">10</span>, <span class="hljs-keyword">int</span>);<span class="hljs-comment">//类型作为参数</span><span class="hljs-comment">//预处理器替换之后：</span>(<span class="hljs-keyword">int</span> *)malloc(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h4 id="但是宏参数与类型无关是一把双刃剑和函数比较也有他的缺点">但是，宏参数与类型无关是一把双刃剑，和函数比较也有他的缺点</h4><blockquote>  <h4 id="宏的缺点"><strong>宏的缺点：</strong></h4>  <h4 id="1-每次使用宏的时候一份宏定义的代码将插入到程序中除非宏比较短否则可能大幅度增加程序的长度">1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能<strong>大幅度增加程序的长度</strong></h4>  <h4 id="2-宏是没法调试的">2. <strong>宏</strong>是<strong>没法调试的</strong></h4>  <h4 id="3-宏由于类型无关也就不够严谨">3. <strong>宏由于类型无关</strong>，也就<strong>不够严谨</strong></h4>  <h4 id="4-宏可能会带来运算符优先级的问题导致程序容易出现问题">4. 宏可能会<strong>带来运算符优先级的问题</strong>，导致程序<strong>容易出现问题</strong></h4></blockquote><h4 id="我的建议"><strong>我的建议：</strong></h4><blockquote>  <h4 id="当有一部分功能既可以用函数实现也可以用宏实现且在调用函数的过程与宏使用过程所消耗的资源相当时优先考虑代码的严谨性使用函数">当有一部分功能既可以用函数实现也可以用宏实现，且在<strong>调用函数的过程</strong>与<strong>宏使用过程</strong>所<strong>消耗的资源相当时</strong>，<strong>优先考虑代码的严谨性</strong>，使用函数</h4></blockquote><h3 id="7宏参数的副作用"><a name="t10"></a>7、<strong>宏参数</strong>的<strong>副作用</strong></h3><blockquote>  <h4 id="当宏参数在宏的定义中出现超过一次的时候如果参数带有副作用那么你在使用这个宏的时候就可能出现危险导致不可预测的后果副作用就是表达式求值的时候出现的永久性效果">当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。</h4></blockquote><pre class="prettyprint" name="code"><code class="hljs perl has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-comment">#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )</span><span class="hljs-keyword">x</span> = <span class="hljs-number">5</span>;<span class="hljs-keyword">y</span> = <span class="hljs-number">8</span>;z = MAX(<span class="hljs-keyword">x</span>++, <span class="hljs-keyword">y</span>++);<span class="hljs-keyword">printf</span>(<span class="hljs-string">"x=<span class="hljs-variable">%d</span> y=<span class="hljs-variable">%d</span> z=<span class="hljs-variable">%d</span>\n"</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, z);<span class="hljs-regexp">//</span>结果为<span class="hljs-keyword">x</span>=<span class="hljs-number">6</span> <span class="hljs-keyword">y</span>=<span class="hljs-number">10</span> z=<span class="hljs-number">9</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre><h4 id="可以看到上面代码中y带来了副作用所以在使用宏的时候避免使用运算和-运算">可以看到上面代码中y++带来了副作用，所以在使用宏的时候，避免使用<code>++</code>运算和<code>--</code>运算</h4><h3 id="8宏的命名"><a name="t11"></a>8、宏的<strong>命名</strong></h3><h4 id="宏和函数的使用很类似我们平时的使用习惯是">宏和函数的使用很类似，我们平时的使用习惯是：</h4><blockquote>  <h4 id="1-宏名全部大写"><strong>1. 宏名全部大写</strong></h4>  <h4 id="2-函数名不全大写"><strong>2. 函数名不全大写</strong></h4></blockquote><h2 id="最后感谢所有访问我博客的来访者"><a name="t12"></a><strong>最后，感谢所有访问我博客的来访者</strong></h2>                                    </div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ main函数中参数argc和argv含义以及用法</title>
    <link href="undefined2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>原文链接:<a href="https://www.cnblogs.com/mtcnn/p/9412008.html" target="_blank" rel="noopener">https://www.cnblogs.com/mtcnn/p/9412008.html</a></p><div id="cnblogs_post_body" class="blogpost-body "><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argc 是 argument count的缩写，表示传入main函数的参数个数；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个；</span></span></p><p><span style="color:rgb(69,69,69);font-family:arial, '宋体', sans-serif, tahoma, 'Microsoft YaHei';line-height:24px;"><span style="font-size:14px;">简单用法示例，新建工程键代码：</span></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><p><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</p><p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;argv[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><p></p><p></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">argv是指向指针的指针，main函数的第二个参数<strong>“char *argv[]“也可以替换为 “char **argv“</strong>，两者是等价的。</span></p><span style="font-size:14px;">在编译环境下按F5运行，输出如下：</span><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721225702418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">可见，在没有参数传入的情况下，保存程序名称的第一个变量argv[0]依然存在。</span></p><p><span style="font-size:14px;">传参数给main函数有两种方法，第一种方式是在编译环境中设置，以vs2012为例，右击项目—&gt;属性—&gt;配置属性—&gt;调试—&gt;命令参数，在命令参数中输入，每个参数之间用空格隔开。</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721231958740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">之后点击确定并应用，运行之后显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232144436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">第二种方式也是经常会用到的方式是通过命令提示符传入。首先需要打开命令提示符窗口，点击开始菜单在“搜索程序和文件”里输入命令“cmd”或者直接按<strong>快捷键 Windows+R</strong>，在弹出的对话框里输入“cmd”即可打开命令提示符窗口：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721232732806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">打开命令提示符窗口后需要输入生成的exe文件所在的完整路径，一个简便的方法是</span><span style="font-size:14px;background-color:rgb(255,0,0);">把exe文件直接拖入提示符窗口即可</span><span style="font-size:14px;">，之后输入传入参数，以空格分隔，之后回车，显示如下：</span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721233522377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt><br></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">如果你坚持要手工输入完整路径的话，你会发现等你“Ctrl+C”路径后，在提示符窗口中按“Ctrl+V”却不能粘贴，这时候可以在窗口中右键单击一下试试，你会发现<strong><span style="color:#ff0000;">右键菜单里的粘贴功能还是有效的</span></strong>。</span></p><p><span style="font-size:14px;">下一个例子演示使用opencv显示一幅图片：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span><br></span>{<br>    Mat image=imread(argv[<span class="hljs-number">1</span>]);<br>    imshow(<span class="hljs-string">“Lena”</span>,image);<br>    waitKey();<br>}</p></code></pre><span style="font-size:14px;"></span><p></p><p></p><p><span style="font-size:14px;"><br></span></p>注意读入的参数是argv[1]，在命令提示符窗口运行：<p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160721235245942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt></span></p><p><span style="font-size:14px;"><br></span></p><p><span style="font-size:14px;">最后说明一下：<span style="color:#ff0000;"><strong>一般编译器默认使用argc和argv两个名称作为main函数的参数，但这两个参数如此命名并不是必须的，你可以使用任何符合C++语言命名规范的变量名作为入参</strong></span>，效果是一样的：</span></p><p><span style="font-size:14px;"><br></span></p><p></p><pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;highgui/highgui.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<p><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value,<span class="hljs-keyword">char</span> **point)</span><br></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;value;i++)<br>    {<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">“argument[“</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">“] is: “</span>&lt;&lt;point[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    }<br>    system(<span class="hljs-string">“pause”</span>);<br>}</p></code></pre><span style="font-size:14px;"><br><br></span><br><p></p><p></p></div>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈工大-操作系统(实验二）-系统调用</title>
    <link href="undefined2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>此次实验的基本内容是：在linux-0.11上添加两个系统调用，并编写两个简单的应用程序测试他们。<br><br>感谢两位大佬的博客指点：<br><br><a href="https://www.jianshu.com/p/5786cd42b152" target="_blank" rel="noopener" title="寒夏凉秋">https://www.jianshu.com/p/5786cd42b152</a>  <br><br>  <a href="https://github.com/Wangzhike/HIT-Linux-0.11" target="_blank" rel="noopener" title="qiuyu_mac">https://github.com/Wangzhike/HIT-Linux-0.11</a><br></p><h1 id="应用程序怎么调用系统调用？"><a href="#应用程序怎么调用系统调用？" class="headerlink" title="应用程序怎么调用系统调用？"></a>应用程序怎么调用系统调用？</h1><blockquote><p>通常情况下，调用系统调用与调用一个普通的自定义代码没什么区别，但是调用后发生的事情不同，调用自定义函数通常通过call指令直接跳转到目标函数的地址处，继续运行，但是调用系统调用，是调用系统库中为系统调用编写的一个接口函数，叫做API（Application Programming Interface）（它对应一个宏_syscallx，在unistd.h中）。<br>API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用。</p><h2 id="（1）系统调用的基本过程"><a href="#（1）系统调用的基本过程" class="headerlink" title="（1）系统调用的基本过程"></a>（1）系统调用的基本过程</h2><p>1.应用程序调用库函数（API）<br><br>2.API函数要么通过自己添加含有int $0x80的嵌入汇编代码,要么调用syscall0到syscall3这四个宏函数（这四个函数在include/unistd.h中定义）将系统调用号存入EAX寄存器，通过int $0x80编程异常处理进入到内核态的<strong>系统调用</strong>处理函数system_call<br><br>3.<strong>系统调用</strong> 处理函数system_call根据系统调用号，调用对应的内核函数（真正的<strong>系统调用</strong>实现函数）<br><br>4.system_call处理完成后返回API函数中，并将内核函数的返回值通过EAX寄存器传递给API函数<br><br>5.API函数将返回值返回给应用程序</p><h2 id="（2）在Linux-0-11中添加一个系统调用foo（）的步骤："><a href="#（2）在Linux-0-11中添加一个系统调用foo（）的步骤：" class="headerlink" title="（2）在Linux 0.11中添加一个系统调用foo（）的步骤："></a>（2）在Linux 0.11中添加一个系统调用foo（）的步骤：</h2><p>1.编写API函数 foo()，根据器参数的个数，调用syscall0到syscall3这四个宏函数的其中一个，或者手动添加含有int $0x80的嵌入汇编代码，通过EAX寄存器传入系统调用号，进入内核。<br><br>2.在内核中实现 真正的系统调用函数sys_foo，并修改对应的makefile文件<br><br>3.同时在sys_call_table中加入sys_foo()函数的函数名，既入口地址，在该头文件中声明sys_foo()函数<br><br>4.在include/unistd.h中定义sys_foo()函数的系统调用号<br><br>5.修改kernel/system_call.s中代表系统调用总数的变量nr_system_calls的值<br><br>6.编写测试程序，修改添加了foo（）系统调用的Linux 0.11的文件系统下的unistd.h的文件，加入foo（）的系统调用号，运行测试程序，检验效果。</p><h3 id="实操："><a href="#实操：" class="headerlink" title="实操："></a>实操：</h3><p>(1).在虚拟机中编写号iam.c跟whoami.c两个文件（这两个文件就是我们全部完成实验步骤后在boch中运行的程序）<br><br>写好这两个文件后，在oslab中运行<br><br><code>sudo ./mount-hdc</code><br><br>可以把虚拟机硬盘挂载在oslab/hdc目录下然后再将文件复制到oslab/hdc/usr/root/下，usr/root/就是你的linux 0.11开机后所在的目录&lt;就相当于window的桌面上的东西&gt;<br><br>iam.c<br></p></blockquote><pre><code>//为什么要写#define __LIBRARY__这句话呢？我猜测是因为unistd.h中有一句#ifdef __LIBRARY__,//只有__LIBRARY__被定义过才能展开_syscall1().#define __LIBRARY__  #include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;_syscall1(int,iam,const char*,name)int main(int argc,char* argv[]){    iam(argv[1]);    return 0;}</code></pre><p>这里的int main中的两个参数分别代表的是<br><br>argc代表传入main函数的参数的个数<br><br>argv代表传入main函数的参数序列或指针<br><br>具体看这里：<a href="https://lexssama.github.io/2019/10/27/C-main%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8F%82%E6%95%B0argc%E5%92%8Cargv%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">C++ main函数中参数argc和argv含义以及用法</a></p><p>whoami.c<br></p><blockquote></blockquote><pre><code>#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt; _syscall2(int, whoami, char*, name, unsigned int, size);int main(int argc, char ** argv){char t[30];whoami(t, 30);printf(&quot;%s\n&quot;, t);return 0;}</code></pre><p>(2).编写who.c文件（里面包括sys_iam()和sys_whoami()文件),将完成的who.c放进linux-0.11/kernel目录下<br><br>who.c<br></p><blockquote></blockquote><pre><code>#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;asm/segment.h&gt;char msg[24]; int sys_iam(const char * name){char tep[26];int i = 0;for(; i &lt; 26; i++){tep[i] = get_fs_byte(name+i);if(tep[i] == &#39;\0&#39;)  break;}if (i &gt; 23) return -(EINVAL);strcpy(msg, tep);return i;    }int sys_whoami(char * name, unsigned int size){int len = 0;for (;msg[len] != &#39;\0&#39;; len++);if (len &gt; size) {return -(EINVAL);}int i = 0;for(i = 0; i &lt; size; i++){put_fs_byte(msg[i], name+i);if(msg[i] == &#39;\0&#39;) break;}return i;}</code></pre><p>(3).修改linux-0.11/kernel中的makefile文件。<br><br>修改makefile文件为的是让添加的who.c文件可以和其他Linux代码链接在一起。<br><br><strong>修改完成后“make all”就能自动把who.c加入到内核中了</strong></p><blockquote></blockquote><pre><code>OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o改为：OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o who.o另一处：### Dependencies:exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h改为：### Dependencies:who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.hexit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h</code></pre><p>(4).在sys_call_table中(<strong>sys_call_table是一个指针变量存在于linux-0.11/include/linux/sys.h</strong>)加入sys_iam和sys_whoami函数的函数名，即入口地址，在改头文件中声明sys_iam和sys_whoami函数。</p><blockquote></blockquote><pre><code>extern int sys_setup();extern int sys_exit();extern int sys_fork();extern int sys_read();extern int sys_write();extern int sys_open();extern int sys_close();extern int sys_waitpid();extern int sys_creat();extern int sys_link();extern int sys_unlink();extern int sys_execve();extern int sys_chdir();extern int sys_time();extern int sys_mknod();extern int sys_chmod();extern int sys_chown();extern int sys_break();extern int sys_stat();extern int sys_lseek();extern int sys_getpid();extern int sys_mount();extern int sys_umount();extern int sys_setuid();extern int sys_getuid();extern int sys_stime();extern int sys_ptrace();extern int sys_alarm();extern int sys_fstat();extern int sys_pause();extern int sys_utime();extern int sys_stty();extern int sys_gtty();extern int sys_access();extern int sys_nice();extern int sys_ftime();extern int sys_sync();extern int sys_kill();extern int sys_rename();extern int sys_mkdir();extern int sys_rmdir();extern int sys_dup();extern int sys_pipe();extern int sys_times();extern int sys_prof();extern int sys_brk();extern int sys_setgid();extern int sys_getgid();extern int sys_signal();extern int sys_geteuid();extern int sys_getegid();extern int sys_acct();extern int sys_phys();extern int sys_lock();extern int sys_ioctl();extern int sys_fcntl();extern int sys_mpx();extern int sys_setpgid();extern int sys_ulimit();extern int sys_uname();extern int sys_umask();extern int sys_chroot();extern int sys_ustat();extern int sys_dup2();extern int sys_getppid();extern int sys_getpgrp();extern int sys_setsid();extern int sys_sigaction();extern int sys_sgetmask();extern int sys_ssetmask();extern int sys_setreuid();extern int sys_setregid();</code></pre><blockquote></blockquote><pre><code>extern int sys_iam();//需要新增的地方extern int sys_whoami();</code></pre><blockquote></blockquote><pre><code>fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid,sys_setregid, sys_iam, sys_whoami };//记得在中断向量表的最后填上系统调用</code></pre><blockquote></blockquote><p>(5).在include/unistd.h中定义sys_iam和sys_whoami的函数系统调用号。<br><br><strong>注意：unistd.h不能直接在oslab中修改</strong>，需要运行<br></p><blockquote></blockquote><p><code>sudo ./mount-hdc</code><br><br>把虚拟机硬盘挂载在oslab/hdc目录下，在hdc/usr/include目录中修改unistd.h。<br><br>至于为什么要这么做自己也没搞懂。</p><blockquote></blockquote><pre><code>#define __NR_setup    0   /* used only by init, to get system going */#define __NR_exit    1#define __NR_fork    2#define __NR_read    3#define __NR_write    4#define __NR_open    5#define __NR_close    6#define __NR_waitpid    7#define __NR_creat    8#define __NR_link    9#define __NR_unlink    10#define __NR_execve    11#define __NR_chdir    12#define __NR_time    13#define __NR_mknod    14#define __NR_chmod    15#define __NR_chown    16#define __NR_break    17#define __NR_stat    18#define __NR_lseek    19#define __NR_getpid    20#define __NR_mount    21#define __NR_umount    22#define __NR_setuid    23#define __NR_getuid    24#define __NR_stime    25#define __NR_ptrace    26#define __NR_alarm    27#define __NR_fstat    28#define __NR_pause    29#define __NR_utime    30#define __NR_stty    31#define __NR_gtty    32#define __NR_access    33#define __NR_nice    34#define __NR_ftime    35#define __NR_sync    36#define __NR_kill    37#define __NR_rename    38#define __NR_mkdir    39#define __NR_rmdir    40#define __NR_dup    41#define __NR_pipe    42#define __NR_times    43#define __NR_prof    44#define __NR_brk    45#define __NR_setgid    46#define __NR_getgid    47#define __NR_signal    48#define __NR_geteuid    49#define __NR_getegid    50#define __NR_acct    51#define __NR_phys    52#define __NR_lock    53#define __NR_ioctl    54#define __NR_fcntl    55#define __NR_mpx    56#define __NR_setpgid    57#define __NR_ulimit    58#define __NR_uname    59#define __NR_umask    60#define __NR_chroot    61#define __NR_ustat    62#define __NR_dup2    63#define __NR_getppid    64#define __NR_getpgrp    65#define __NR_setsid    66#define __NR_sigaction    67#define __NR_sgetmask    68#define __NR_ssetmask    69#define __NR_setreuid    70#define __NR_setregid    71   /*Linux system_call total 72*/#define __NR_iam    72     /*new system_call 72 and 73*/#define __NR_whoami    73</code></pre><p>(6).修改kernel/systeam_call.s中代表系统调用总个数的变量 nr_systeam_calls的值（原值是72，改为74）<br></p><blockquote></blockquote><pre><code>sa_handler = 0sa_mask = 4sa_flags = 8sa_restorer = 12nr_system_calls = 74</code></pre><p>(7).自此大功告成，cd 进入oslab中执行 ./run运行系统，<br>在boch中编译iam.c和whoam.c。</p><blockquote></blockquote><pre><code>gcc -o iam iam.c gcc -o whoami whoami.c </code></pre><p>运行./iam 和 ./whoami 。</p>]]></content>
    
    
    <categories>
      
      <category>哈工大-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>系统调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的常用指令</title>
    <link href="undefined2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h1><blockquote><p>hexo n “我的博客” == hexo new “我的博客” —–&gt;新建文章<br><br>hexo p == hexo publish <br><br>hexo g == hexo generate —-&gt;生成<br><br>hexo s == hexo server —–&gt; 启动服务预览<br><br>hexo d == hexo deploy —–&gt;部署到博客上<br></p></blockquote><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><blockquote><p>hexo clean —&gt;清除缓存<br><br>hexo g —-&gt;生成静态网页<br><br>hexo d —-&gt;开始部署<br></p></blockquote><h1 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h1><blockquote><p>hexo generate –watch –&gt;监视文件变动</p></blockquote><h1 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h1><blockquote><p>hexo generate –deploy == hexo g -d<br><br>hexo deploy –generate == hexo d -g<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>