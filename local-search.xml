<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>process-switch-base-on-stack-switch</title>
    <link href="/2020/02/16/process-switch-base-on-stack-switch/"/>
    <url>/2020/02/16/process-switch-base-on-stack-switch/</url>
    
    <content type="html"><![CDATA[<h1 id="基于内核栈切换的进程切换"><a href="#基于内核栈切换的进程切换" class="headerlink" title="基于内核栈切换的进程切换"></a>基于内核栈切换的进程切换</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>深入理解进程和进程切换的概念；</li><li>综合应用进程、CPU 管理、PCB、LDT、内核栈、内核态等知识解决实际问题；</li><li>开始建立系统认识。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>现在的 Linux 0.11 采用 TSS（后面会有详细论述）和一条指令就能完成任务切换，虽然简单，但这指令的执行时间却很长，在实现任务切换时大概需要 200 多个时钟周期。</p><p>而通过堆栈实现任务切换可能要更快，而且采用堆栈的切换还可以使用指令流水的并行优化技术，同时又使得 CPU 的设计变得简单。所以无论是 Linux 还是 Windows，进程/线程的切换都没有使用 Intel 提供的这种 TSS 切换手段，而都是通过堆栈实现的。</p><p>本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 <code>switch_to</code> 实现去掉，写成一段基于堆栈切换的代码。</p><p>本次实验包括如下内容：</p><ul><li>编写汇编程序 <code>switch_to</code>：</li><li>完成主体框架；</li><li>在主体框架下依次完成 PCB 切换、内核栈切换、LDT 切换等；</li><li>修改 <code>fork()</code>，由于是基于内核栈的切换，所以进程需要创建出能完成内核栈切换的样子。</li><li>修改 PCB，即 <code>task_struct</code> 结构，增加相应的内容域，同时处理由于修改了 task_struct 所造成的影响。</li><li>用修改后的 Linux 0.11 仍然可以启动、可以正常使用。</li><li>（选做）分析实验 3 的日志体会修改前后系统运行的差别。</li></ul><h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h2><p>回答下面三个题：</p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h4><p>针对下面的代码片段：</p><pre><code>movl tss,%ecxaddl $4096,%ebxmovl %ebx,ESP0(%ecx)</code></pre><p>回答问题：</p><ul><li><p>（1）为什么要加 4096；</p><p>答：因为一页内存低地址存进程PCB，高地址是堆栈，linux-0.11 一页内存大小为4Kb,所以+4096。</p></li><li><p>（2）为什么没有设置 tss 中的 ss0。</p><p>答</p></li></ul><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h4><p>针对代码片段：</p><pre><code class="lang-c">*(--krnstack) = ebp;*(--krnstack) = ecx;*(--krnstack) = ebx;*(--krnstack) = 0;</code></pre><p>回答问题：</p><ul><li><p>（1）子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？</p><p>答：子进程第一次执行是eax =0;，为了让代码<code>if (!fork()) {....}</code>区分子进程和父进程。</p></li><li><p>（2）这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？</p><p>答：这段代码中的ebx和ecx是栈切换执行switch_to时压入的值，我觉得是为了切换进程时保护现场而压入的，在fork创建新进程（子进程）时添加这些代码进新进程内核栈是为了模拟父进程的内核栈。</p></li><li><p>（3）这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？</p><p>答：ebp也是来自基于栈切换的switch_to（）时压入的，是当前进程在进行切换时保存当前进程现场的操作，为什么要这样设置呢？因为创建新的子进程当进程切换时需要pop所以这里是为了模拟父进程的内核栈.</p></li></ul><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h4><p>为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？</p><p>答：因为需要重新设置fs对应的隐藏寄存器的段基址和段限长，所以需要重设操作，出现在LDT之前则没有任何意义不会有任何改变。</p><h2 id="TSS的切换"><a href="#TSS的切换" class="headerlink" title="TSS的切换"></a>TSS的切换</h2><h3 id="TSS-task-state-segment"><a href="#TSS-task-state-segment" class="headerlink" title="TSS (task state segment)"></a>TSS (task state segment)</h3><p>The <strong>task state segment (TTS)</strong> is a structure on x86-based computers which holds information about a task, it is used by the operating system kernel for task managenment. specifically, the following information is stored in the TSS:</p><ul><li>processor register state</li><li>I/O port permissions</li><li>Inner-lever stack pointers (内部堆栈指针)</li><li>Previous TSS link</li></ul><p>All this information should be stored at specific locations within the TSS as specified in the IA-32 manuals.</p><h3 id="TR-task-register"><a href="#TR-task-register" class="headerlink" title="TR (task register)."></a>TR (task register).</h3><p>The TR register is a 16-bit register which holds a segment selector for the TSS. It may be loaded through the LTR instruction. LTR is a privileged instruction and acts in a manner similar to other segment register loads. The task register has two parts: a portion visible and accessible by the programmer and an invisible one that is automatically loaded from the TSS descriptor.<br></p><p>In the current Linux 0.11,the real completion of the  process switch is accomplished by the task state segment(Task State Segment,TSS for short).</p><p>Specifically, when designing the “Intel architecture”(that is the x86 system structure),</p><p>each task(process or thread) corresponds to an independent TSS. TSS is a  corresponds</p><p>to an independent TSS. TSS is a structure in memory that contains almost all CPU registers Image. There is a Task Register(TR for short) pointing to the TSS structure corresponding to the current process. </p><p>The so-called TSS switch is copies almost all the registers in the CPU(current) to the TSS </p><p>structure pointed  by TR.</p><p>At the same time a target TSS is found ,that is the TSS corresponding to the next process to be switched to, and the register image of TSS structure of next process  stored in CPU.</p><p>In here  the execution site switching  is completed.</p><p>as shown in the figure  blow:</p><p><img src="/2020/02/16/process-switch-base-on-stack-switch/wm.png" srcset="/img/loading.gif" alt></p><p>Inter architecture provides the command ljmp to achieve the process switch .</p><p>The specific working process is:</p><ul><li>First, use the segment selector in TR to find the current TSS structure memory location in GDT table.</li><li>second,  the register image of current CPU  store to the TSS structure memory  of finding before.(store the current site !)</li><li>Now, we need to find the target process site and copy the register image of the target   process to the CPU. This just means we need to find TSS of the next process in  GDT table and copy the context of TSS structure memory to CPU.</li><li>when the register image of TSS structure of the target process store in CPU completely, that means achieve switch to target process site, now, the target process becomes the current process. </li><li>Finally , TR should be changed to point to the location of the target TSS segment in the GDT table.<br></li></ul><p>all explain above  through one sentence execute  (ljmp segment selector : intra-segment offset).</p><p>So switch_to (a instruction) base on TSS for process and thread switching is actually a ljmp instruction：</p><pre><code class="lang-assembly">#define switch_to(n) {\struct {long a,b;} __tmp; \__asm__(&quot;cmpl %%ecx,current\n\t&quot; \         &quot;je 1f\n\t&quot; \    &quot;movw %%dx,%1\n\t&quot; \    &quot;xchgl %%ecx,current\n\t&quot; \    &quot;ljmp *%0\n\t&quot; \    &quot;cmpl %%ecx,last_task_used_math\n\t&quot; \    &quot;jne 1f\n\t&quot; \    &quot;clts\n&quot; \    &quot;1:&quot; \    ::&quot;m&quot; (*&amp;__tmp.a),&quot;m&quot; (*&amp;__tmp.b), \    &quot;d&quot; (_TSS(n)),&quot;c&quot; ((long) task[n])); \}#define FIRST_TSS_ENTRY 4#define TSS(n) (((unsigned long) n) &lt;&lt; 4) + (FIRST_TSS_ENTRY &lt;&lt; 3))</code></pre><p>Each process is divided into two part which correspond to TSS and LDT, respectively. </p><p>TSS and LDT are both 64-bit(8 bytes).</p><p>so  _TSS(n) = n <em> 16 + 4 </em> 8 (bytes).</p><p><strong>ljmp instruction can be used in two ways, which are “ljmp $ segment selector, $ offset” and “ljmp <em> mem48” respectively. In here “ljmp </em>% 0” used the second way, “ljmp <em> mem48” mean jump to Logical address (48 bits) of the mem48 contain (mem48 also is an address), the hight 16 bits of 48 bits correspond to segment_selector, the low 32 bits of 48 bits correspond to offset. So ,the core of switch_to is ljmp 0 , n\</em>16+4*8  </strong></p><p><strong>!! it is worth out attention:</strong></p><p>The ‘*‘ of the “ljmp <em>mem48” is different from ‘\</em>‘ of C language . The ‘*‘ of the “ljmp *mem48”  is mean indirect jump.</p><h2 id="本次实验的内容"><a href="#本次实验的内容" class="headerlink" title="本次实验的内容"></a>本次实验的内容</h2><p>Although ，the task switching can be completed with one instruction, the execution time of the instruction is very long . It take almost 200 time cycles to complete the task switch using the ljmp instruction. if we want to increase the switching speed ,we can use the heap_stack switch instead of ljmp instruction.</p><p>Moreover. The use of heap_stack switching can also use the parallel optimization technology of instruction pipeline, while making design of the CPU simple.</p><p>Therefore, both Windows and Linux use the heap_stack switching technology to handle process switching.</p><p>Therefore rewriter the code of “switch_to” to  use the heap_stack switch instead of TSS is my task.</p><p>To achieve a process switch base on kernel , we need do three things :</p><ol><li>Rewrite “switch_to”</li><li>Connect the rewritten “switch_to” and schedule() functions together.</li><li>Modify the current fork().</li></ol><h2 id="schedule-与-switch-to"><a href="#schedule-与-switch-to" class="headerlink" title="schedule 与 switch_to"></a>schedule 与 switch_to</h2><h3 id="modify-shcedule"><a href="#modify-shcedule" class="headerlink" title="modify shcedule()"></a>modify shcedule()</h3><p>The task of schedule( ) is finding the position “next” of the next process in the array.  The “next” is equal to “n” of the GDT table(TSS[n]=n*16+4*8).  if we get the “next” in the schedule function, we can use “switch_to (next)” function move to another process.</p><p>Now, we use heap_stack switching instead of TSS switching ,and so we need informations of  current process PCB 、target process PCB、current process kernel stack and target process kernel stack.</p><p> The kernel stack of the Linux 0.11 process and the PCB of process are stored on the same page of memory (a 4kB size page of memory).The PCB is located at the low address of this page of memory ,and the stack is located at the high address of this page of memory.</p><p>In addition, since the PCB of the current process is pointed with a global variable “current”, we  need to tell new switch_to () function a pointer to the target process PCB and we need to tell new switch_to function LDT(next) instead of TSS (next). Just mean ,we don’t need TSS in each process now（we can delete code about TSS），but  also need LDT of  process.</p><p>In summary ,the current schedule() function (in kernel/sched.c) needs to be slightly modified, that is the following code:</p><pre><code class="lang-C">if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)     c = (*p)-&gt;counter, next = i; //......switch_to(next);</code></pre><p>modify:</p><pre><code class="lang-C">if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)     c = (*p)-&gt;counter, next = i, pnext = *p;//.......switch_to(pnext, LDT(next));</code></pre><h3 id="Rewrite-switch-to"><a href="#Rewrite-switch-to" class="headerlink" title="Rewrite switch_to()"></a>Rewrite switch_to()</h3><p>Rewrite switch_to() function is the most important step in this experiment.</p><p>This function, in turn, completes the following functions:</p><ul><li>first, we need to handle the stack by the assembly language. just handle the ebp register.</li><li>second, we need to compare the parameter of stack about the next process’s PCB with the current process.</li><li>third, we need in turn to complete PCB switch, rewrite kernel stack pointer of TSS, switch kernel stack, switch LDT and switch PC pointer (CS:EIP).</li></ul><pre><code class="lang-assembly">switch_to:    pushl %ebp    movl %esp,%ebp    pushl %ecx    pushl %ebx    pushl %eax    movl 8(%ebp),%ebx    cmpl %ebx,current    je 1f! 切换PCB    ! ...! TSS中的内核栈指针的重写    ! ...! 切换内核栈    ! ...! 切换LDT    ! ...    movl $0x17,%ecx    mov %cx,%fs! 和后面的 clts 配合来处理协处理器，由于和主题关系不大，此处不做论述    cmpl %eax,last_task_used_math     jne 1f    clts1:    popl %eax    popl %ebx    popl %ecx    popl %ebpret</code></pre><p><strong>Switch PCB pointer</strong></p><p>ebx register is next process’s PCB pointer.</p><p>The function of xchgl instruction  is to exchange contents between  two register.</p><pre><code class="lang-assembly">movl %ebx,%eaxxchgl %eax,current</code></pre><p><strong>Rewrite pointer of kernel stack stored in  TSS</strong></p><p>The current TSS is different from TSS before. Before TSS is a global array but current TSS is a global variable. We need to redefine TSS pointer through two sentences.</p><pre><code>#define ESP0 =4struct tss_struct *tss = (init_task.task.tss);</code></pre><p>current TSS pointer <code>tss</code> similar current process pointer <code>current</code>.</p><p>This has already discussed in detail before. In the system interrupt ,we need to find and determine the location of the kernel stack. and push the five register SS : ESP, CS: EIP and EFLAGS in user mode onto kernel stack. This is the key bridge between the user mode (user stack) and kernel mode (kernel stack). The key of find kernel stack position is use the TR register point to current TSS.</p><p>Although we don’t need to use TSS for switch process in now.  We still stay the intel interrupt system. So we still need it that is we define global variable <code>tss</code>. All processes share that variable.</p><pre><code class="lang-assembly">movl tss,%ecxaddl $4096,%ebxmovl %ebx,ESP0(%ecx)</code></pre><p>ESP0 = 4 ,the ecx + ESP0 equal to position of kernel stack pointer in TSS (esp0).</p><pre><code class="lang-C">struct tss_struct {    long    back_link;    /* 16 high bits zero */    long    esp0;    long    ss0;        /* 16 high bits zero */    long    esp1;    long    ss1;        /* 16 high bits zero */    long    esp2;    long    ss2;        /* 16 high bits zero */    long    cr3;    long    eip;    long    eflags;    long    eax,ecx,edx,ebx;    long    esp;    long    ebp;    long    esi;    long    edi;    long    es;        /* 16 high bits zero */    long    cs;        /* 16 high bits zero */    long    ss;        /* 16 high bits zero */    long    ds;        /* 16 high bits zero */    long    fs;        /* 16 high bits zero */    long    gs;        /* 16 high bits zero */    long    ldt;        /* 16 high bits zero */    long    trace_bitmap;    /* bits: trace 0, bitmap 16-31 */    struct i387_struct i387;};</code></pre><p><strong>switch kernel stack :</strong></p><p>It’s also simple to complete the kernel stack switch. we just need to store value of esp register of the current process  onto the current PCB , and take corresponding esp value of next PCB out and put it into esp register.</p><p>since Linux -0.11  didn’t define the variable of kernel stack pointer in PCB(task_struct). so we need to add a variable <code>kernelstack</code> to Linux-0.11 PCB, we still need define another variable <code>KERNEL_STACK = 12</code>  for determine variable of  <code>kernelstack</code> position in PCB.</p><p><strong>Why KERNEL_STACK equal to 12 ?</strong></p><p>because the kernel code have many  assembly hardcodes about manipulating this structure, so,if we add the variable <code>kernelstack</code> in other position, we need to modify kernel code in many difference place. </p><pre><code class="lang-C">KERNEL_STACK = 12movl %esp,KERNEL_STACK(%eax)    ! 保存上一个进程的栈顶指针! 再取一下 ebx，因为前面修改过 ebx 的值,此时eax的值等于上一个进程的PCB指针movl 8(%ebp),%ebx    movl KERNEL_STACK(%ebx),%esp    ！取下个进程的栈顶指针放入esp</code></pre><p>task_struct:</p><pre><code class="lang-C">// 在 include/linux/sched.h 中struct task_struct {    long state;    long counter;    long priority;    long kernelstack;//......</code></pre><p>because we modify the PCB structure,  we also need to modify initialization code of 0 process PCB structure .Modify <code>#define INIT_TASK { 0,15,15, 0,{ { },},0,...</code>  to <code>#define INIT_TASK { 0,15,15,PAGE_SIZE+(long)&amp;init_task, 0,{ { },},0,...</code></p><p><strong>switch LDT</strong></p><pre><code class="lang-assembly">movl 12(%ebp),%ecxlldt %cx!上面使改LDT代码movl $0x17,%ecxmov %cx,%fs</code></pre><p>Why we have to add two code <code>movl $0x17,%ecx</code> <code>mov %cx,%fs</code> behind that code of switch LDT.</p><p>because we need to change the segment base address and segment length limit in the hidden register about fs.</p><p>Examlpe with CS. The hidden register for increase CPU processing speed.</p><p><img src="/2020/02/16/process-switch-base-on-stack-switch/wm (1" srcset="/img/loading.gif" alt>.png)</p><p><strong>switch PC （switch to next process）</strong></p><pre><code class="lang-assembly">1:    popl %eax    popl %ebx    popl %ecx    popl %ebpret</code></pre><p><strong>kernel stack  now</strong></p><p><img src="https://img-blog.csdnimg.cn/20190819230403925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc2MTQ3OA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt></p><p>Execute those codes to turn to the next process. Because we have been changed the kernel stack before. we <code>pop  (eax ,ebx,ecx,ebp)</code> is register of next process.   ret instruction equal to <code>pop IP</code>.So we execute <code>ret</code> turn to schedule() function tail of next process. Now ! we completed stack switch perfectly.</p><h2 id="modify-fork"><a href="#modify-fork" class="headerlink" title="modify fork()"></a>modify fork()</h2><p><strong>Why we need to modify fork() function ?</strong></p><p><strong>Because, we need to simulate the parent process’s kernel stack for the newly created child process. </strong></p><p>Now, we need to modify the fork() function. it is to associate the process’s user stack, user program to its kernel stack with SS: ESP, CS: IP, which is pushed in the kernel stack.</p><p>In addition, since fork() function-core is let the child process to use code, data, and stack of the parent process . the fork core has not changed, although we use the stack switching.</p><p><img src="/2020/02/16/process-switch-base-on-stack-switch/wm2.png" srcset="/img/loading.gif" alt></p><p>Don’t hard to imagine. modify fork which  mean  initialize child process’s kernel stack. In <code>copy_process ()</code>as the core code of <code>fork ()</code>, it used to apply a page of memory as process PCB. The kernel stack address position equal pointer p position add the one page of memory size.  so the code <code>krnstack = (*long)(PAGE_SIZE + (long)p)</code> can find the child process kernel stack position. next step is to initialize the content of krnstack pointer .</p><pre><code class="lang-C">long *krnstack;p = (struct task_struct *) get_free_page();krnstack = (long)(PAGE_SIZE +(long)p); *(--krnstack) = ss &amp; 0xffff; *(--krnstack) = esp; *(--krnstack) = eflags; *(--krnstack) = cs &amp; 0xffff; *(--krnstack) = eip; *(--krnstack) = ds &amp; 0xffff; *(--krnstack) = es &amp; 0xffff; *(--krnstack) = fs &amp; 0xffff; *(--krnstack) = gs &amp; 0xffff; *(--krnstack) = esi; *(--krnstack) = edi; *(--krnstack) = edx; *(--krnstack) = (long)first_return_from_kernel; *(--krnstack) = ebp; *(--krnstack) = ecx; *(--krnstack) = ebx; *(--krnstack) = 0; p-&gt;kernelstack = krnstack; ......</code></pre><p>Those code for simulate parent kernel stack for child process! </p><p>Make a attention !</p><pre><code class="lang-c">*(--krnstack) = (long)first_return_from_kernel;*(--krnstack) = 0;</code></pre><p>We need to code a first_return_from_kernel as a mark! If we return to address first_return_from_kernel. We need to execute those code following.</p><pre><code class="lang-assembly">popl %edxpopl %edipopl %esipop %gspop %fspop %espop %dsiret</code></pre><p>instruction <code>iret</code> equal to </p><pre><code class="lang-assembly">pop eippop cspop eflagspop esppop ss</code></pre><p> instruction <code>*(--krnstack) = 0;</code>  Means eax =0 for distinguish parent process and child process.</p>]]></content>
    
    
    
    <tags>
      
      <tag>-操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
