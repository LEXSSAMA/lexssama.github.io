<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>哈工大-操作系统(实验二）-系统调用</title>
    <link href="undefined2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>2019/10/27/%E5%93%88%E5%B7%A5%E5%A4%A7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>此次实验的基本内容是：在linux-0.11上添加两个系统调用，并编写两个简单的应用程序测试他们。<br><br>感谢两位大佬的博客指点：<br><br><a href="https://www.jianshu.com/p/5786cd42b152" target="_blank" rel="noopener" title="寒夏凉秋">https://www.jianshu.com/p/5786cd42b152</a>  <br><br>  <a href="https://github.com/Wangzhike/HIT-Linux-0.11" target="_blank" rel="noopener" title="qiuyu_mac">https://github.com/Wangzhike/HIT-Linux-0.11</a><br></p><h1 id="应用程序怎么调用系统调用？"><a href="#应用程序怎么调用系统调用？" class="headerlink" title="应用程序怎么调用系统调用？"></a>应用程序怎么调用系统调用？</h1><blockquote><p>通常情况下，调用系统调用与调用一个普通的自定义代码没什么区别，但是调用后发生的事情不同，调用自定义函数通常通过call指令直接跳转到目标函数的地址处，继续运行，但是调用系统调用，是调用系统库中为系统调用编写的一个接口函数，叫做API（Application Programming Interface）（它对应一个宏_syscallx，在unistd.h中）。<br>API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用。</p><h2 id="（1）系统调用的基本过程"><a href="#（1）系统调用的基本过程" class="headerlink" title="（1）系统调用的基本过程"></a>（1）系统调用的基本过程</h2><p>1.应用程序调用库函数（API）<br><br>2.API函数要么通过自己添加含有int $0x80的嵌入汇编代码,要么调用syscall0到syscall3这四个宏函数（这四个函数在include/unistd.h中定义）将系统调用号存入EAX寄存器，通过int $0x80编程异常处理进入到内核态的<strong>系统调用</strong>处理函数system_call<br><br>3.<strong>系统调用</strong> 处理函数system_call根据系统调用号，调用对应的内核函数（真正的<strong>系统调用</strong>实现函数）<br><br>4.system_call处理完成后返回API函数中，并将内核函数的返回值通过EAX寄存器传递给API函数<br><br>5.API函数将返回值返回给应用程序</p><h2 id="（2）在Linux-0-11中添加一个系统调用foo（）的步骤："><a href="#（2）在Linux-0-11中添加一个系统调用foo（）的步骤：" class="headerlink" title="（2）在Linux 0.11中添加一个系统调用foo（）的步骤："></a>（2）在Linux 0.11中添加一个系统调用foo（）的步骤：</h2><p>1.编写API函数 foo()，根据器参数的个数，调用syscall0到syscall3这四个宏函数的其中一个，或者手动添加含有int $0x80的嵌入汇编代码，通过EAX寄存器传入系统调用号，进入内核。<br><br>2.在内核中实现 真正的系统调用函数sys_foo，并修改对应的makefile文件<br><br>3.同时在sys_call_table中加入sys_foo()函数的函数名，既入口地址，在该头文件中声明sys_foo()函数<br><br>4.在include/unistd.h中定义sys_foo()函数的系统调用号<br><br>5.修改kernel/system_call.s中代表系统调用总数的变量nr_system_calls的值<br><br>6.编写测试程序，修改添加了foo（）系统调用的Linux 0.11的文件系统下的unistd.h的文件，加入foo（）的系统调用号，运行测试程序，检验效果。</p><h3 id="实操："><a href="#实操：" class="headerlink" title="实操："></a>实操：</h3><p>(1).在虚拟机中编写号iam.c跟whoami.c两个文件（这两个文件就是我们全部完成实验步骤后在boch中运行的程序）<br><br>写好这两个文件后，在oslab中运行<br><br><code>sudo ./mount-hdc</code><br><br>可以把虚拟机硬盘挂载在oslab/hdc目录下然后再将文件复制到oslab/hdc/usr/root/下，usr/root/就是你的linux 0.11开机后所在的目录&lt;就相当于window的桌面上的东西&gt;<br><br>iam.c<br></p></blockquote><pre><code>#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;_syscall1(int,iam,const char*,name)int main(int argc,char* argv[]){    iam(argv[1]);    return 0;}</code></pre><p>whoami.c<br></p><blockquote></blockquote><pre><code>#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt; _syscall2(int, whoami, char*, name, unsigned int, size);int main(int argc, char ** argv){char t[30];whoami(t, 30);printf(&quot;%s\n&quot;, t);return 0;}</code></pre><p>(2).编写who.c文件（里面包括sys_iam()和sys_whoami()文件),将完成的who.c放进linux-0.11/kernel目录下<br><br>who.c<br></p><blockquote></blockquote><pre><code>#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;asm/segment.h&gt;char msg[24]; int sys_iam(const char * name){char tep[26];int i = 0;for(; i &lt; 26; i++){tep[i] = get_fs_byte(name+i);if(tep[i] == &#39;\0&#39;)  break;}if (i &gt; 23) return -(EINVAL);strcpy(msg, tep);return i;    }int sys_whoami(char * name, unsigned int size){int len = 0;for (;msg[len] != &#39;\0&#39;; len++);if (len &gt; size) {return -(EINVAL);}int i = 0;for(i = 0; i &lt; size; i++){put_fs_byte(msg[i], name+i);if(msg[i] == &#39;\0&#39;) break;}return i;}</code></pre><p>(3).修改linux-0.11/kernel中的makefile文件。<br><br>修改makefile文件为的是让添加的who.c文件可以和其他Linux代码链接在一起。<br><br>修改完成后“make all”就能自动把who.c加入到内核中了</p><blockquote></blockquote><pre><code>OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o改为：OBJS  = sched.o system_call.o traps.o asm.o fork.o \panic.o printk.o vsprintf.o sys.o exit.o \signal.o mktime.o who.o另一处：### Dependencies:exit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h改为：### Dependencies:who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.hexit.s exit.o: exit.c ../include/errno.h ../include/signal.h \  ../include/sys/types.h ../include/sys/wait.h ../include/linux/sched.h \  ../include/linux/head.h ../include/linux/fs.h ../include/linux/mm.h \  ../include/linux/kernel.h ../include/linux/tty.h ../include/termios.h \  ../include/asm/segment.h</code></pre><p>(4).在sys_call_table中(sys_call_table是一个指针变量存在于linux-0.11/include/linux/sys.h)加入sys_iam和sys_whoami函数的函数名，即入口地址，在改头文件中声明sys_iam和sys_whoami函数。</p><blockquote><pre><code>extern int sys_setup();extern int sys_exit();extern int sys_fork();extern int sys_read();extern int sys_write();extern int sys_open();extern int sys_close();extern int sys_waitpid();extern int sys_creat();extern int sys_link();extern int sys_unlink();extern int sys_execve();extern int sys_chdir();extern int sys_time();extern int sys_mknod();extern int sys_chmod();extern int sys_chown();extern int sys_break();extern int sys_stat();extern int sys_lseek();extern int sys_getpid();extern int sys_mount();extern int sys_umount();extern int sys_setuid();extern int sys_getuid();extern int sys_stime();extern int sys_ptrace();extern int sys_alarm();extern int sys_fstat();extern int sys_pause();extern int sys_utime();extern int sys_stty();extern int sys_gtty();extern int sys_access();extern int sys_nice();extern int sys_ftime();extern int sys_sync();extern int sys_kill();extern int sys_rename();extern int sys_mkdir();extern int sys_rmdir();extern int sys_dup();extern int sys_pipe();extern int sys_times();extern int sys_prof();extern int sys_brk();extern int sys_setgid();extern int sys_getgid();extern int sys_signal();extern int sys_geteuid();extern int sys_getegid();extern int sys_acct();extern int sys_phys();extern int sys_lock();extern int sys_ioctl();extern int sys_fcntl();extern int sys_mpx();extern int sys_setpgid();extern int sys_ulimit();extern int sys_uname();extern int sys_umask();extern int sys_chroot();extern int sys_ustat();extern int sys_dup2();extern int sys_getppid();extern int sys_getpgrp();extern int sys_setsid();extern int sys_sigaction();extern int sys_sgetmask();extern int sys_ssetmask();extern int sys_setreuid();extern int sys_setregid();</code></pre></blockquote><pre><code>extern int sys_iam();//需要新增的地方extern int sys_whoami();</code></pre><blockquote><pre><code>fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid,sys_setregid, sys_iam, sys_whoami };//记得在中断向量表的最后填上系统调用</code></pre><p>(5).在include/unistd.h中定义sys_iam和sys_whoami的函数系统调用号。<br><br>注意unistd.h不能直接在oslab中修改，需要运行<br></p></blockquote><p><code>sudo ./mount-hdc</code><br><br>把虚拟机硬盘挂载在oslab/hdc目录下，在hdc/usr/include目录中修改unistd.h。<br></p><blockquote></blockquote><pre><code>#define __NR_setup    0   /* used only by init, to get system going */#define __NR_exit    1#define __NR_fork    2#define __NR_read    3#define __NR_write    4#define __NR_open    5#define __NR_close    6#define __NR_waitpid    7#define __NR_creat    8#define __NR_link    9#define __NR_unlink    10#define __NR_execve    11#define __NR_chdir    12#define __NR_time    13#define __NR_mknod    14#define __NR_chmod    15#define __NR_chown    16#define __NR_break    17#define __NR_stat    18#define __NR_lseek    19#define __NR_getpid    20#define __NR_mount    21#define __NR_umount    22#define __NR_setuid    23#define __NR_getuid    24#define __NR_stime    25#define __NR_ptrace    26#define __NR_alarm    27#define __NR_fstat    28#define __NR_pause    29#define __NR_utime    30#define __NR_stty    31#define __NR_gtty    32#define __NR_access    33#define __NR_nice    34#define __NR_ftime    35#define __NR_sync    36#define __NR_kill    37#define __NR_rename    38#define __NR_mkdir    39#define __NR_rmdir    40#define __NR_dup    41#define __NR_pipe    42#define __NR_times    43#define __NR_prof    44#define __NR_brk    45#define __NR_setgid    46#define __NR_getgid    47#define __NR_signal    48#define __NR_geteuid    49#define __NR_getegid    50#define __NR_acct    51#define __NR_phys    52#define __NR_lock    53#define __NR_ioctl    54#define __NR_fcntl    55#define __NR_mpx    56#define __NR_setpgid    57#define __NR_ulimit    58#define __NR_uname    59#define __NR_umask    60#define __NR_chroot    61#define __NR_ustat    62#define __NR_dup2    63#define __NR_getppid    64#define __NR_getpgrp    65#define __NR_setsid    66#define __NR_sigaction    67#define __NR_sgetmask    68#define __NR_ssetmask    69#define __NR_setreuid    70#define __NR_setregid    71   /*Linux system_call total 72*/#define __NR_iam    72     /*new system_call 72 and 73*/#define __NR_whoami    73</code></pre><p>(6).修改kernel/systeam_call.s中代表系统调用总个数的变量 nr_systeam_calls的值（原值是72，改为74）<br></p><blockquote></blockquote><pre><code>sa_handler = 0sa_mask = 4sa_flags = 8sa_restorer = 12</code></pre><blockquote></blockquote><pre><code>nr_system_calls = 74 //这里72改为74.</code></pre><p>(7).自此大功告成，cd 进入oslab中执行 ./run运行系统，<br>在boch中编译iam.c和whoam.c。</p><blockquote><pre><code>gcc -o iam iam.c gcc -o whoami whoami.c </code></pre><p>运行./iam 和 ./whoami 。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo的常用指令</title>
    <link href="undefined2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>2019/10/26/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h1><blockquote><p>hexo n “我的博客” == hexo new “我的博客” —–&gt;新建文章<br><br>hexo p == hexo publish <br><br>hexo g == hexo generate —-&gt;生成<br><br>hexo s == hexo server —–&gt; 启动服务预览<br><br>hexo d == hexo deploy —–&gt;部署到博客上<br></p></blockquote><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><blockquote><p>hexo clean —&gt;清除缓存<br><br>hexo g —-&gt;生成静态网页<br><br>hexo d —-&gt;开始部署<br></p></blockquote><h1 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h1><blockquote><p>hexo generate –watch –&gt;监视文件变动</p></blockquote><h1 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h1><blockquote><p>hexo generate –deploy == hexo g -d<br><br>hexo deploy –generate == hexo d -g<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>