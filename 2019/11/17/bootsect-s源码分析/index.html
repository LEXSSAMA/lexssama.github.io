<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/spider.png">
  <link rel="icon" type="image/png" href="/img/spider.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>bootsect.s源码分析 ~ lexssama</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >
  
  <link rel="stylesheet" href="/css/main.css"  >

  
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>lexssama</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/136457.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              <p class="mt-3">星期日, 十一月 17日 2019, 1:24 凌晨</p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto">
          <div class="markdown-body">
            <p>本博客大部分搬运于《Linux内核完全注释》赵烔编著，小部分增加一些自己阅读源码过程中遇到问题的解答。<br><br>目的是：希望在自己搬运的过程中，可以加深对Linux-0.11内核的理解和印象。<br><br>感谢：<a href="https://blog.csdn.net/longintchar/article/details/79323783" target="_blank" rel="noopener">https://blog.csdn.net/longintchar/article/details/79323783</a><br><a href="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md" target="_blank" rel="noopener" title="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md">https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/1-boot/OS-booting.md</a></p>
<h1 id="Bootsect-s"><a href="#Bootsect-s" class="headerlink" title="Bootsect.s"></a>Bootsect.s</h1><p>bootsect.s代码时磁盘引导块程序，驻留在磁盘的第一个扇区中（引导扇区，0磁道（柱面），0磁头，第一个扇区）。在PC机加电ROM BIOS自检后，引导扇区由BIOS加载到内存，0x7C00处，然后将自己移动到内存0x90000处，该程序的主要作用是首先将setup模块（由setup.s编译成），从磁盘加载到内存，紧接在bootsect的后面位（0x90200），然后利用BIOS中断0x13取磁盘参数表中当前启动引导盘的参数，接着在屏幕上显示“Loading system…”字符串，再将system模块从磁盘上加载到内存0x10000开始的地方，随后确定根文件系统的设备号，若没有指定，则根据所保存的引导盘的每磁道扇区数判别出盘的类型和种类（是1.44MB的A盘？）并保存其设备号于root_dev（引导块的508地址处），最后长跳到setup程序的开始处（0x90200）执行setup程序。<br></p>
<pre><code>SYSSIZE = 0x3000  ;system模块的长度


.globl begtext, begdata, begbss, endtext, enddata, endbss
.text
begtext:
.data
begdata:
.bss
begbss:
.text

SETUPLEN = 4                ! setup模块的长度，4个扇区
BOOTSEG  = 0x07c0           ! original address of boot-sector
INITSEG  = 0x9000           ! bootsect把自身搬运到0x90000
SETUPSEG = 0x9020           ! setup模块被加载到 0x90200
SYSSEG   = 0x1000           ! system模块被加载到0x10000
ENDSEG   = SYSSEG + SYSSIZE ! where to stop loading, 0x1000 + 0x3000 = 0x4000, 停止加载的段地址(加载system模块时使用)

ROOT_DEV = 0x306            !第2个硬盘的第1个分区

   !这里开始把bootsect.s程序复制到0x90000去。
entry _start
_start:
    mov ax,#BOOTSEG 
    mov ds,ax      !ds = 0x07c0
    mov ax,#INITSEG
    mov es,ax      !ex = 0x9000
    mov cx,#256    !搬运256次
    sub si,si      !si = 0
    sub di,di      !di = 0
                   !ds:si=0x07c0:0x0, es:di=0x9000:0x0
    rep
    movw           !每次搬运2个字节
    jmpi go,INITSEG   !跳转到 0x9000:go （jmpi是段内跳转指令跳转目的地是INITSEG:go）
  ! 这里开始设置栈，为的是待会装入setup程序
go: mov ax,cs
    mov ds,ax
    mov es,ax     !ds=es=cs=0x9000
    mov ss,ax
    mov sp,#0xFF00  
                  !es:sp = 0x9000:0xff00 ，栈的设置  

  ! dx，cx，bx，ax都是传递给in0x13中断服务程序的参数
load_setup:
    mov dx,#0x0000      ! 驱动器号(DL)0，磁头号(DH)0
    mov cx,#0x0002      ! 起始扇区号CL=2, 磁道号（柱面号），CH=0
    mov bx,#0x0200      ! 偏移地址0x200,(setup程序读入的开始地址es：bx，es在上面程序已经设置成0x9000，所以就是将setup程序读到0x90200处)
    mov ax,#0x0200+SETUPLEN ! 功能号AH=0x02,AL=要读的扇区数目=SETUPLEN=4 （in0x13的AH=0x02的中断服务程序功能是读软盘或硬盘上的若干物理扇区到内存的ES:BX处）
    int 0x13            ! read it（当载入出现错误则把CF置成1，把出错的代码位置送到AH，返回实际读到的扇区数给AL）
    jnc ok_load_setup   ! ok - continue（如果CF（进位标志）=0，则跳转，因为上面中断服务程序如果出错就把CF置为1,CF=0代表没有出错则跳转）

    ! 如果上面载入出错则执行这一步
    mov dx,#0x0000      !需要复位的驱动器号=DL=0
    mov ax,#0x0000      !功能号AH=0（int0x13的AH=0，执行中断服务程序中的复位程序）
    int 0x13            ! 复位磁盘
    j   load_setup

    !如果没有出错则跳到这一步执行,这一步的目的主要是把一些磁盘信息存入到0x90000处。
ok_load_setup:

! Get disk drive parameters, specifically nr of sectors/track

    mov dl,#0x00    !驱动器号为0，说明是软盘
    mov ax,#0x0800  ! AH=8 is get drive parameters（INT 13H AH=08H：读取驱动器参数）
    int 0x13
    mov ch,#0x00    !这里用不上软盘的最大磁道号，可以使CH=0
    seg cs          !把段超越前缀设置为cs,（段超越指的是把默认的段地址寄存器改成自己希望的段地址寄存器）只影响下一条语句
    mov sectors,cx  ! 把cx寄存器中的内容装入cs:[sectors]处。（sectors在后面有定义）
    !保存每磁道最大扇区数。对于软盘，最大磁道号不会超过256，所以CH足以表示，CL[7:6]为0
    mov ax,#INITSEG
    mov es,ax       !因为上面ES的值被修改，所以令ES=0x9000

    mov ah,#0x03    !读光标的位置
    xor bh,bh       !bh=页号
    int 0x10        ! INT 10H AH=03H：获取光标位置和形状

    mov cx,#24          ! 24个字符
    mov bx,#0x0007      ! page 0, attribute 7 (normal)
    mov bp,#msg1        ! 在代码后面有定义
    mov ax,#0x1301      ! write string, move cursor
    int 0x10
 ! ok, we&#39;ve written the message, now
 ! # we want to load the system (at 10000h)  现在开始将system 模块加载到10000h(64k)处。

    mov    ax,SYSSEG
    mov    es,ax        ;! segment of 010000h  es = 存放system的段地址。
    call read_it            ; !读磁盘上system模块，es为输入参数。
    call kill_motor        ;! 关闭驱动器马达，这样就可以知道驱动器的状态了。
 !call read_it时程序跳到下面read_it处执行
!call kill_motor时程序跳到kill_motor处执行


!此后，我们检查要使用哪个根文件系统设备（简称根设备）。如果已经指定了设备（!=0）
! 就直接使用给定的设备。否则就需要根据BIOS报告的每磁道扇区数来
! 确定到底使用/dev/PS0(2,28)还是/dev/at0(2,8)。
!        上面一行中两个设备文件的含义：
!        在Linux中软驱的主设备号是2（参加第43行注释），次设备号 = type*4 + nr, 其中
!        nr为0－3分别对应软驱A、B、C或D；type是软驱的类型（2-&gt;1.2M或7-&gt;1.44M等）。
!        因为7*4 + 0 = 28，所以/dev/PS0(2,28)指的是1.44M A驱动器，其设备号是021c
!    同理 /dev/at0(2,8)指的是1.2M A驱动器，其设备号是0208。

    seg cs
    mov    ax,root_dev
    cmp ax,#0
    jne    root_defined    ! 如果 ax != 0, 转到root_defined
    seg cs
    mov    bx,sectors        !取上面保存的每磁道扇区数。如果sectors=15
                        !则说明是1.2Mb的驱动器；如果sectors=18，则说明是
                        ! 1.44Mb软驱。因为是可引导的驱动器，所以肯定是A驱。
    mov    ax,#0x0208        ! /dev/ps0 - 1.2Mb
    cmp bx,#15            ! 判断每磁道扇区数是否=15
    je    root_defined    !如果等于，则ax中就是引导驱动器的设备号。
    mov    ax,#0x021c            ! /dev/PS0 - 1.44Mb
    cmp     bx,#18
    je    root_defined
undef_root:                ! 如果都不一样，则死循环（死机）。
    jmp undef_root
root_defined:
    seg cs
    mov    root_dev,ax        ! 将检查过的设备号保存起来。

! 到此，所有程序都加载完毕，我们就跳转到被
! 加载在bootsect后面的setup程序去。

    jmpi    0,SETUPSEG        !跳转到9020:0000（setup程序的开始处）。


sread:  .word 1+SETUPLEN !当前磁道已经读取的扇区数, 前面的1表示引导扇区bootsect.s
head:   .word 0          ! current head，当前磁头号
track:  .word 0          ! current track，当前磁道号

read_it:
    mov ax,es
    test ax,#0x0fff     !使ax与0xfff按位与，测试es是否为0x1000的整数倍
die:    jne die         !结果不为0（说明es不是0x1000的整数倍）则陷入死循环
    xor bx,bx           ! bx（作为段内偏移地址）清零
rp_read:
    mov ax,es
    cmp ax,#ENDSEG      ! 实际上求(ax-ENDSEG)
    jb ok1_read         ! 当CF=1（ax&lt;ENDSEG, 有借位）时跳转到ok1_read
    ret                 ! 当ax&gt;=ENDSEG时返回（我认为不会出现大于的情况）
ok1_read:
    seg cs
    mov ax,sectors      ! 这两句相当于 mov ax, cs:[sectors]; 获得每磁道扇区数
    sub ax,sread        ! ax = ax - sread, 得出本磁道未读扇区数
    mov cx,ax
    shl cx,#9           ! cx乘以512，求出字节数
    add cx,bx           ! 以上3行相当于 cx = ax * 512 + bx
                        ! 假设再读ax个扇区，cx就是段内共读入的字节数
    jnc ok2_read        ! 若cx &lt; 0x10000（CF=0,没有进位）则跳转到ok2_read
    je ok2_read         ! 若cx = 0（ZF=1），说明刚好读入64KB，则跳转到ok2_read
    xor ax,ax            ! ax = 0x0000
    sub ax,bx            ! 求bx对0x10000的补数，结果在ax中
    shr ax,#9            ! 除以512,得到扇区数，AL作为参数，传给read_track
ok2_read:               
    call read_track  ！调用read_track过程，用AL传参,读取AL个扇区到ES:BX
    mov cx,ax        ！cx是该次操作已经读取的扇区数
    add ax,sread     ！ax是当前磁道已经读取的扇区数
    seg cs
    cmp ax,sectors   
    jne ok3_read     ！如果当前磁道还有扇区未读，跳转到ok3_read
    mov ax,#1        ！说明当前磁道的扇区都已读完
    sub ax,head      ！ax = 1 - 磁头号
    jne ok4_read     ！不为0则跳转到 ok4_read，说明磁头号为0
    inc track        ！说明磁头号为1，磁道号增加1
ok4_read:
    mov head,ax  !更新磁头号（如果是37行跳转过来，则 head=1；否则 head=0）
    xor ax,ax    !ax=0, 因为更换了磁道，所以当前磁道已读扇区数置0
ok3_read:
    mov sread,ax      ！更新当前磁道已经读取的扇区数
    shl cx,#9           ! ok2_read处有更新cx。
    add bx,cx         ！更新偏移地址
    jnc rp_read       ！没有进位，则跳转到rp_read
    mov ax,es         ！有进位，说明BX达到了64KB边界
    add ax,#0x1000    
    mov es,ax         ！es增加0x1000
    xor bx,bx         ！bx = 0
    jmp rp_read       ！继续读取

! 读当前磁道上指定开始扇区和需读扇区数的数据到es:bx开始处。
! al － 需读扇区数； es:bx － 缓冲区开始位置。
read_track:
    push ax
    push bx
    push cx
    push dx
!dx,cx,ax都是传给中断服务程序的参数。
    mov dx,track        !取当前磁道号。（磁道号其实存在低8位也就是dl的位置，dh都为0）
    mov cx,sread        ! 取当前磁道上已读扇区数。（已读扇区不会超过255所以已读扇区号其实存在cl，ch都为0）
    inc cx                ! cl = 开始读扇区号，inc为加一指令。
    mov ch,dl            ! ch = 当前磁道号（用ch来存当前的磁道号）。
    mov dx,head            ! 取当前磁头号。（同理磁头号也不可能超出255所以磁头号这时实际上时存在dl中，dh为0）
    mov dh,dl            ! dh = 磁头号。（把磁头号放到dh上，dl在下面改为驱动器号）
    mov dl,#0            ! dl = 驱动器号（为0表示当前驱动器）。
    and dx,#0x0100        ! 磁头号不大于1
    mov ah,#2            ! ah = 2, 读磁盘扇区功能号。
    int 0x13
    jc bad_rt            ! 若出错，则跳转至bad_rt。
    pop dx
    pop cx
    pop bx
    pop ax
    ret
! 执行驱动器复位操作（磁盘中断功能号0），再跳转到read_track处重试。
bad_rt:    
    mov ax,#0
    mov dx,#0
    int 0x13（磁盘复位中断程序）
    pop dx
    pop cx
    pop bx
    pop ax
    jmp read_track

kill_motor:
    push dx
    mov dx,# 0x3f2！ 软驱控制卡的驱动端口，只写。
    mov al,#0            ! A驱动器，关闭FDC，禁止DMA和中断请求，关闭马达。
    outb        ! 将al中的内容输出到dx指定的端口去。outb:I/O端口操作函数,I/O 上写入 8 位数据 ( 1 字节 )；
    pop dx
    ret

sectors: 
            .word 0                ! 存放当前启动软盘每磁道的扇区数。

msg1:
.byte 13,10            ! 回车、换行的ASCII码。
     .ascll &quot;Loading my system ...&quot;! 我加了my，共有27个字符了
     byte 13,10,13,10    ! 共24个ASCII码字符。

org 508:        ! 表示下面语句从地址508(1FC)开始，所以root_dev
            ！ 在启动扇区的第508开始的2个字节中。
root_dev 
         .word  ROOT_DEV    ！ 这里存放根文件系统所在的设备号（init/main.c中会用）。
boot_flag ：
            .word  0xAA55h        ！ 硬盘有效标识。

.text 
endtext：
.data
enddata
.bss
endbss:</code></pre><p><img src="https://i.imgur.com/GKftX8i.png" srcset="/img/loading.gif" alt></p>

            <hr>
          </div>
          <br>
          <div>
            
              <p>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>
                  &nbsp;
                
                  <a class="hover-with-bg" href="/categories/Linux-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-源码分析</a>
                  &nbsp;
                
              </p>
            
            <p>
              <i class="iconfont icon-tag"></i>
              
                <a class="hover-with-bg" href="/tags/Linux-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-源码分析</a>
              
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>

  <script src="/js/lazyload.js" ></script>


  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>


  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "bootsect.s源码分析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script>
    if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) || (/Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent))) {
      $("#background").css("background-attachment", "scroll");
    }
  </script>

</body>
</html>
