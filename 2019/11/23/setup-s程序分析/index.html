<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/spider.png">
  <link rel="icon" type="image/png" href="/img/spider.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>setup.s程序分析 ~ lexssama</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >
  
  <link rel="stylesheet" href="/css/main.css"  >

  
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>lexssama</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/136457.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              <p class="mt-3">星期六, 十一月 23日 2019, 7:49 晚上</p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto">
          <div class="markdown-body">
            <h1 id="Setup-s程序"><a href="#Setup-s程序" class="headerlink" title="Setup.s程序"></a>Setup.s程序</h1><ol>
<li>Setup.s程序的主要作用是利用ROM BIOS中断读取系统数据，并将这些数据保存在0x90000开始的位置（覆盖掉了bootsect程序所在的地方），所取得的参数和保留的内存位置如下图。这些参数将被内核中相关的程序使用。<br><br><img src="https://i.imgur.com/eASugFV.jpg" srcset="/img/loading.gif" alt><br></li>
<li>然后setup.s程序将system模块从0x10000-0x8ffff（当时认为内核系统模块system模块的长度不会超过此值：512KB）整块下移到内存绝对地址0x00000处。</li>
<li>接下来加载中断描述符寄存器（IDTR）和全局描述符表寄存器（GDTR），开启A20地址线，重新设置两个中断控制芯片8259A(主芯片和从芯片)将硬件中断号重新设置为0x20-0x2f。<br></li>
<li>最后设置CPU控制器CR0（也称机器状态字），从而进入32位保护模式运行，并跳转到位于system模块最前面部分的head.s程序。<br></li>
</ol>
<p>为了能让head.s在32位保护模式下运行，setup.s程序中临时设置了中断描述符表（IDT）和全局描述符表（GDT），并在GDT中设置了当前内核代码段的描述符和数据段描述符，当进去head.s程序中会根据内核需要重新设置这些描述符表<br><br>因此在进入保护模式之前，必须首先设置好要用的段描述符，例如全局描述符表GDT，然后使用指令LGDT把描述符表的基地址告知CPU（GDT表基地址存入GDTR寄存器），再将机器状态字的保护模式标志置位即可进入32位保护模式。<br></p>
<pre><code>INITSEG = 0x9000         ! 原来的bootsect所处的段
SYSSEG = 0x1000          ！system 在 0x10000（64KB）处
SETUPSEG = 0x9020      ！本程序所在的段地址

.globl begtext , begdata , begbss , endtext , enddata , endbss
.text                     !代码段
begtext：
.data                     !数据段
begdata:
.bss                        ！未初始化数据段
begbss:
.text

entry start
start:</code></pre><br>

<h2 id="读光标位置"><a href="#读光标位置" class="headerlink" title="读光标位置:"></a><strong>读光标位置:</strong></h2><pre><code>mov    ax,#INITSEG
mov    ds,ax
mov    ah,#0x03    ! BIOS中断0x10的读光标功能号 ah=0x03。输入：bh=页号；
xor        bh,bh
int        0x10        ! 返回：ch=扫描开始线；cl=扫描结束线；dh=行号（0x00最顶端）；dl=列号（0x00最左端）
mov    [0],dx        ! 把dx的存入ds：0，长度为两个字节。</code></pre><h2 id="读取扩展内存大小"><a href="#读取扩展内存大小" class="headerlink" title="读取扩展内存大小:"></a><strong>读取扩展内存大小:</strong></h2><pre><code>mov    ah,#0x88    ! 调用BIOS中断0x15，功能号：ah=0x88；获取从1M处开始的扩展内存的大小（KB）
int        0x15        ! 返回：ax=从0x100000（1M）处开始的扩展内存的大小。
mov    [2],ax        ! 将扩展内存大小存储到 ds：[2];</code></pre><h2 id="取显示卡当前的显示模式："><a href="#取显示卡当前的显示模式：" class="headerlink" title="取显示卡当前的显示模式："></a><strong>取显示卡当前的显示模式：</strong></h2><pre><code>mov    ah,#0x0f        ! 调用 BIOS 中断 0x10，功能号 ah = 0x0f
int    0x10            ! 返回： ah=字符列数； al=显示模式；bh=当前显示页
mov    [4],bx
mov    [6],ax</code></pre><h2 id="检查显示方式-EGA-VGA-并获取参数"><a href="#检查显示方式-EGA-VGA-并获取参数" class="headerlink" title="检查显示方式(EGA/VGA)并获取参数"></a><strong>检查显示方式(EGA/VGA)并获取参数<br></strong></h2><p>返回的：<br></p>
<ol>
<li>bh=显示状态（0x00-&gt;彩色模式,I/O端口=0x3dX；0x01-&gt;单色模式，I/O端口=0x3bX）；<br></li>
<li>bl=安装的显示内存（0x00-&gt;64k，0x01-&gt;128k，0x02-&gt;192k，0x03-&gt;256k）；<br></li>
<li>cx = 显示卡特性参数</li>
</ol>
<pre><code>mov    ah,#0x12    
mov    bl,#0x10        ! 调用 BIOS 中断 0x10，功能号： ah = 0xl2，子功能号： bl = 0xl0
int        0x10        ! 返回：bh=显示状态；bl=安装的显示内存；cx显卡特性参数
mov    [8],ax
mov    [10],bx
mov    [12],cx</code></pre><h2 id="取第硬盘信息-Get-hd0-data"><a href="#取第硬盘信息-Get-hd0-data" class="headerlink" title="取第硬盘信息(Get hd0 data)"></a><strong>取第硬盘信息(Get hd0 data)<br></strong></h2><p>取第一个硬盘的信息（复制硬盘参数表），第一个硬盘参数表的首地址是中断向量0x41的向量值(<strong>注意：中断向量0x41存放并不是中断服务向量服务程序的地址</strong>)，第二个硬盘参数表紧接第一个表的后面，中断向量0x46的向量值也指向这第2个硬盘的参数的参数表首地址，表总共的长度是16个字节(0x10)。下面两段程序分别复制BIOS有关两个硬盘的参数表，0x90080处存放第一个硬盘的表，0x90090处存放第2个硬盘的表。<br></p>
<pre><code>! Get hd0 data
mov    ax,#0x0000
mov    ds,ax
lds        si,[4*0x41]     ! hd0参数表的地址：-&gt; ds:si。
                        ! LDS DI,[BX]指令的功能是把BX所指的32位地址指针的段地址送入DS,偏移地址送入DI.
                        ! 这里等于si&lt;-[4*0x41]
mov    ax,#INITSEG
mov    es,ax
mov    di,#0x0080
mov    cx,#0x10
rep                
movsb    !  move string byte，意思是搬移一个字节，它是把 DS:SI 所指地址的一个字节搬移到 ES:DI 所指的地址上

! Get hd1 data
mov    ax,#0x0000
mov    ds,ax
lds        si,[4*0x46]
mov    ax,#INITSEG
mov    es,ax
mov    di,0x0090
mov    cx,#0x10
rep
movsb</code></pre><p>接下来就是检查系统是否存在第2个硬盘，如果不存在则第2个表（0x90090）清零<br><br>利用BIOS中断调用0x13的取盘类型功能。功能号ah=0x15；<br><br><strong>输入：</strong>dl=驱动器号（0x8X是硬盘：0x80指第1个硬盘，0x81指第2个硬盘）<br><br><strong>返回：</strong>ah=类型码（00-没有这个盘，CF置位），01-是软驱，没有change-line支持；02-是软驱（或者其他可移动设备），有change-line 支持；03-硬盘。<br></p>
<pre><code>mov    ax,#0x01500
mov    dl,#0x81
int        0x13
jc        no_disk1    ! 如果进位标志位（CF）被置位则跳转，即CF被置为1则跳转。表示没有第2个硬盘。
cmp        ah,#3
je        is_disk1    !如果ah=3则跳转证明是硬盘。</code></pre><p>如果没有硬盘2：<br></p>
<pre><code>no_disk1:
    mov    ax,#INITSEG
    mov    es,ax
    mov    di,#0x0090
    mov    cx,#0x10
    mov    ax,#0x00
    rep    ! rep和stosb配合使用就是把ax中的内容复制到es：di中，重复cx次。
    stosb    </code></pre><p>如果存在硬盘2：<br><br>如果存在硬盘2那就要开始移动system模块移动正确的位置。<br><br>bootsect引导程序是将system模块读入到0x10000（64KB）开始的位置。由于当时的假设system模块最大长度不会超过0x80000（512KB）,即其末端不会超过内存地址0x90000，所以bootsect会将自己移动到0x90000开始的地方，然后把setup加载到它的后面。下面这段程序的用途是再把整个system模块移动到0x00000位置，即把从0x10000到0x8ffff的内存数据块（512KB），整块地向内存低端移动了 0x10000（64KB）的位置。<br></p>
<pre><code>is_disk1:
    cli    !关中断
    mov    ax,#0x0000    
    cld        
!cld相对应的指令是std，二者均是用来操作方向标志位DF（Direction Flag）。
! cld使DF 复位，即是让DF=0，std使DF置位，即DF=1.这两个指令用于串操作指令中。
! 通过执行cld或std指令可以控制方向标志DF，决定内存地址是增大（DF=0，向高地址增加）还是减小（DF=1，向地地址减小）。
do_move:
    mov    es,ax    ! es=0x0000
    add        ax,#0x1000
    cmp        ax,#0x9000
    jz        end_move     ! 如果零标志被置位就跳转（即ZF=1跳转）,如果已经把0x8000开始的64KB代码移动完就跳转。
    mov    ds,ax    ! ds=0x
    sub        di,di
    sub        si,si
    mov    cx,#8000    !每次移动0x8000个字（64KB个字节）
    rep
    movsw
    jmp        do_move</code></pre><p>lidt指令用于加载中断描述符（idt）寄存器，它的操作数是6个字节<br><br>lgdt指令用来加载全局描述符表（gdt）寄存器，其操作数格式与lidt指令相同。全局描述符表中的每个描述符项（8B）描述了保护模式下数据和代码块的信息。<br><br><img src="https://i.imgur.com/JbRKVfW.png" srcset="/img/loading.gif" alt></p>
<pre><code>end_move
    mov    ax,#SETUPSEG
    mov    ds,ax
    lidt        idt_48    ! 把idt_48的内容装入IDTR寄存器中（48bit）
    lgdt        gdt_48    !  把gdt_48的内容装入GDTR寄存器中（48bit）</code></pre><p>idt_48和gdt_48在实际代码中并不是紧随在end_move我为了好看所以提上来。<br><br>.word<br><br>Syntax: .word expressions<br><br>This directive expects zero or more expressions, of any section, separated by commas. For each expression, as emits a 16-bit number for this target.<br><br>我对.word的理解是放一个expression或者多个expression在idt_48(gdt_48)的位置，每个expression用逗号隔开，每个expression占16个bit。<br></p>
<pre><code>idt_48:
    .word     0    ! idt limit=0
    .word    0,0    ! idt base=0L
gdt_48:
    .word    0x800    !    gdt limit=2048, 256 GDT entries.
    .word    512+gdt,0x9    ! 按照GDTR寄存器顺序写入512+gdt在16~32为，0x9在33~47位，那就是相当于0x900...(16个0)+512+gdt。</code></pre><p><img src="https://i.imgur.com/Cq5niWc.jpg" srcset="/img/loading.gif" alt></p>
<h2 id="开启A20地址线"><a href="#开启A20地址线" class="headerlink" title="开启A20地址线"></a>开启A20地址线</h2><p>在8086/8088中，只有20根地址总线，所以可以访问的地址是2<sup>20</sup>=1M,但由于8086/8088是16位地址模式（16根数据线，20根地址总线），能够表示的地址范围是0-64K，所以为了在8086/8088下能够访问1M内存，inter采取了分段的模式：16位段基地址：16位偏移。其绝对地址（物流地址）的计算方法为：16位基地址左偏移4位+16位偏移=20位地址。<br></p>
<p>但是这种方式引起了新的问题，通过上述的分段模式，能够表示的最大内存为：FFFFh：FFFFh=FFFF0h+FFFFh=10FFEFh=1M+64K-16Bytes.(1M多余出来的部分被称作高端内存区HMA)。但是8086/8080只有20位地址线，<strong>当程序员给出超过1M（100000h-10FFEFh）地址时系统并不认为其访问越界产生异常，而是自动重新从0开始计算，也就是说系统计算实际地址的时候是按照1M求模的方式进行的</strong>，这种技术被称为wrap-around<br></p>
<p>到了80286，系统地址总线发展为24根，这样能够访问的内存可达到2<sup>24</sup>。intel 在设计80286时提出的目标是，在实地址模式下，80286以及后续系列，应该和8086/8088完全兼容，但最终80286芯片却存在一个BUG：如果程序员访问100000h-10FFEFh之间内存时，系统将实际访问这块内存，而不是像8086/8088一样重新从0开始。这就存在不兼容问题了<br></p>
<p>为了解决上述问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数时第20根线），被称作A20Gate：如果A20Gate被打开，则当程序员给出100000h-10FFEFh之间的地址的时候，系统将真正访问这块区域；如果A20Gate被禁止，则程序员给出100000h-10FFEFh之间的地址时，系统仍然使用8086/8088的方式（回卷）<br></p>
<p><strong>开启A20Gate对保护模式的意义：</strong><br><br>从80286开始，系统出现了一种新的机制，被称作保护模式。到了80386，保护模式得到了进一步的完善和发展，并且对80386以后的芯片，保护模式的变化就非常小了。<br></p>
<p>如果要访问更多的内存，则必须进入保护模式（<strong>16位寻址变为32位寻址</strong>），那么在保护模式下，A20Gate对内存访问有什么影响？<br></p>
<p>为了搞清楚这一点，我们先来看一看A20的工作原理，A20其实它就是对于20-bit(从0开始数)的特殊处理（也就是第21根地址线的处理）如果A20Gate被禁止，对于80286来说其地址是24bit，其地址表示为EFFFFF（A20gate被禁止，20位只能为0）；对于80386及其随后的32-bit芯片来说，其地址表示为FFEFFFFF（A20gate被禁止，20位只能为0）。这种表示的意思是如果A20Gate被禁止，则其第20-bit在CPU做地址访问的时候是无效的，永远只能被作为0；如果A20Gate被打开，则其第20-bit是有效的，其值即可以是0，又可以是1.<br></p>
<p>所以若保护模式下A20被关闭其访问的内存范围：<br><br>0000 00000<del>0000 FFFFF=[0</del>1M-1]bytes<br><br>0010 00000<del>0010 FFFFF=[2</del>2M+1M-1]bytes<br><br>0100 00000<del>0100 FFFFF=[4</del>4M+1M-1]bytes<br><br>0110 00000<del>0110 FFFFF=[6</del>6M+1M-1]bytes<br><br>…………<br><br>综上所述：可以访问的内存范围是：<br><br>0<del>1M,2M</del>3M-1,4M<del>5M-1,6M</del>7M-1<br></p>
<p><strong>下面程序不认识0x64和0x60端口的可以参考这篇博客：</strong><a href="https://lexssama.github.io/2019/11/20/%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8/" target="_blank" rel="noopener" title="键盘控制器（8042）">键盘控制器（8042）</a></p>
<pre><code>call    empty_8042    ! 等待输入缓冲器空，只有当输入缓冲器空的时才可以写命令。
mov        al,#0xD1    
! 写0x64端口 0xD1命令码，表示准备写Output端口。随后通过60h端口写入的字节，会被放置在Output Port中。
out        #64,al    
call    empty_8042    ! 等待输入缓冲器空
mov        al,#0xDF
out        #0x60,al    !通过60h端口写的0xDF被放置再output port中，output port 第二位（1号位）为1代表A20开启
call    empty_8042    !输入缓冲器为空，则表示A20地址线已经被开通</code></pre><p>下面是empty_8042,源代码中两者不是相连的<br></p>
<pre><code>empty_8042:
        .word    0x00eb,0x00eb    ! 这是两个跳转指令的机器码（跳转到下一句）作为延时空操作
! 这是一道命令，功能是读键盘控制器（8042）状态寄存器，把键盘控制器（8042）的状态寄存器读入al
        in    al,#0x64
! 测试8042状态寄存器的第二位（位1）该位的功能是：判断键盘的输入缓存器是否满了，满了置1，取走了则是0
        text    al,#2
        jnz    empty_8042    !输入缓存器满了就跳转回到程序开始，再执行一遍，直到输入缓存器位置0.
        ret    </code></pre><h2 id="设置8259芯片"><a href="#设置8259芯片" class="headerlink" title="设置8259芯片"></a>设置8259芯片</h2><p>可编程中断控制器（8259）：具体看这篇博客：<a href="https://lexssama.github.io/2019/11/19/8259A/" target="_blank" rel="noopener">https://lexssama.github.io/2019/11/19/8259A/</a><br></p>
<pre><code>--------写ICW1----------
mov    al,#0x11        ! 0x11表示初始化命令开始是ICW1命令字，表示边沿触发，多片8259级联，最后要发ICW4命令字
out        #0x20,al    !写8259A主芯片
.word    0x00eb,0x00eb    ! 两条跳转指令，跳到下一条指令，起延时作用
out        #0xA0,al    ! 写8259A从芯片
.word    0x00eb,0x00eb
-------写ICW2----------
mov    al,#0x20    
out        #0x21,al    ! 写8259A主芯片，送主芯片ICW2命令字，起始中断号，送奇地址
.word    0x00eb,0x00eb
mov    al,#0x28
out        #0xAl,al    ! 写8259A从芯片，送从芯片ICW2命令字的起始中断号
.word    0x00eb,0x00eb
------写ICW3----------
mov    al,#0x04
out        #0x21,al    !送主芯片ICW3命令字，主芯片的IR2连从芯片INT 
.word    0x00eb，0x00eb
mov    al,#0x02    
out        #0xA1,al    ! 写8259A从芯片，送从芯片ICW2命令字的起始中断号
.word    0x00eb,0x00eb
-------写ICW4---------
mov    al,#0x01
out        #0x21,al    ! 送主芯片ICW4命令字。8086模式;普通EOI方式
.word    0x00eb,0x00eb
out        #0xA1,al    ! 送从芯片ICW4命令字，内容同主芯片
.word    0x00eb,0x00eb
------写OCW1---------
mov    al，#0xFF    
out        #0x21，al    ! 屏蔽主芯片所有中断请求
.word    0x00eb,0x00eb
out        #0xA1，al    ! 屏蔽从芯片所有的中断请求
--------end-----------</code></pre><h2 id="进入保护模式跳转到system模块"><a href="#进入保护模式跳转到system模块" class="headerlink" title="进入保护模式跳转到system模块"></a>进入保护模式跳转到system模块</h2><p>这里要设置进入32位保护模式运行。首先要加载机器状态字也称控制寄存器CR0，其比特位0置为1将导致CPU进去保护模式工作。<br></p>
<pre><code>mov    ax，#0x0001    !保护模式比特位（PE）
lmsw    ax    ! lmsw把ax内容装入控制寄存器(CR0)
jmpi    0,8    ! 跳转到system模块，这个跳转是保护模式下的跳转和实模式的跳转不同。</code></pre><p><img src="https://i.imgur.com/mMkHGDB.jpg" srcset="/img/loading.gif" alt><br><br>x86_32的CR0为32bit。X86_64下为64bit，其中低32bit与x86_32的CR0保持一致，高32bit没有定义，作保留使用，除了bit 4其他所有位都是可读可写的。</p>
<p>Protected-Mode Enable (PE) Bit. Bit0. PE=0,表示CPU处于实模式; PE=1表CPU处于保护模式，并使用分段机制。</p>
<p>Paging Enable (PG) Bit. Bit 31. 该位控制分页机制，PG=1，启动分页机制；PG=0,不使用分页机制。</p>

            <hr>
          </div>
          <br>
          <div>
            
              <p>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>
                  &nbsp;
                
                  <a class="hover-with-bg" href="/categories/Linux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux源码分析</a>
                  &nbsp;
                
              </p>
            
            <p>
              <i class="iconfont icon-tag"></i>
              
                <a class="hover-with-bg" href="/tags/Linux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux源码分析</a>
              
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>

  <script src="/js/lazyload.js" ></script>


  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>


  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "setup.s程序分析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script>
    if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) || (/Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent))) {
      $("#background").css("background-attachment", "scroll");
    }
  </script>

</body>
</html>
