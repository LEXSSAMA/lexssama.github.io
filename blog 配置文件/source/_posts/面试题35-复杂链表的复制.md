---
title: 面试题35. 复杂链表的复制
date: 2020-04-27 00:55:45
index_img: /Picture/line.png
categories:
- 力扣
tags:
- 力扣
---

题目在此[面试题35．复杂的链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)<br>

有三种方法可以做这一道题<br>
- 迭代法
- BFS
- DFS
unordered_map<key,value>是无序的哈希函数<br>	
*unordered_map<Node\*,Node\*> copylist 其实是用来同步复制结点和原结点，例如，原结点到达了head.那么head的复制结点就是copylist\[head\],相当于把原结点和复制节点绑定了起来*<br>
	**这样做的好处是:**<br>
举个例子若不使用unordered_map函数，我们创建3个复制结点就需要创建3个指针(例如：p1,p2,p3)去指向它，以备后续建立结点相互链接关系时再次访问，但是如果我原节点有10000个，那么我就需要手动创建10000个指针，而用了unordered_map就可以将创建的复制结点与原结点绑定起来，结点间建立链接关系时只需要通过原节点就可以访问相应的复制结点(原结点head的复制节点copylist\[head\])<br>

*下面方法除了优化迭代法的时间复杂度为O(n)，空间复杂度为O(1)，其他的时间空间复杂度都为O(n)*

### 迭代法<br>
```
class Solution {
public:
    Node* copyRandomList(Node* head) {
       if(head==NULL) //防止传入head就是NULL
       return head;
       unordered_map<Node*,Node*>copylist;
       Node* temp = head;
       while(temp!=NULL) //先把所有结点复制一遍
       {
           copylist[temp]=new Node(temp->val);
           temp=temp->next;
       }
       temp=head;
       while(temp!=NULL) //复制每个结点的next关系
       {
               copylist[temp]->next=copylist[temp->next];
               temp=temp->next;
       } 
       temp=head;
       while(temp!=NULL){ //复制每个结点的random关系
           copylist[temp]->random=copylist[temp->random];
           temp=temp->next;
       }
       return copylist[head];
    }
};
```
### 优化版迭代
![优化版迭代](优化迭代法-图解.png)<br>

**这个版本的迭代和普通的迭代有什么区别呢？**<br>
*其实这个版本的用原节点的next指针代替了unordered_map，用来绑定(定位)复制结点*<br>
```
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==NULL)
        return head;
        Node* cphead;
        Node* start;
        Node* end;
        Node* temp=head;
        while(temp!=NULL)
        {
            Node* copyhead=new Node(temp->val);
            copyhead->next=temp->next;
            temp->next=copyhead;
            temp=temp->next->next;
        }
        //建立random链接
        temp=head;
        while(temp!=NULL)
        {
            if(temp->random!=NULL)
            temp->next->random=temp->random->next;
            else
            temp->next->random=NULL;
            temp=temp->next->next;
        }
        //建立next链接
        cphead=head->next; //记录复制头节点的位置，以便return
        start=head;
        end=head->next;
        while(end!=NULL)
        {
            start->next=end->next;
            start=end;
            end=end->next;
        }
        return cphead;
    }
};
```

### DFS<br>
因为链表可以变相的可以看为一个图，所以我们可以用DFS解决，DFS递归就相当于保存了上一个节点的信息　(递归就像是一个另类的栈，隐藏的栈和linux0.11进程切换的隐藏栈差不多)．<br>
DFS传递进去的参数是**DFS(期望建立链接的结点，哈希表)**<br>
DFS递归的创建复杂结点，在返回的时候用copylist\[head\]->next 和 copylist\[head\]->random 来建立前后结点的链接关系．<br>
```
class Solution {
public:
 //注意unordered_map<Node*,Node*> &copylist这里使用了引用
    Node* DFS(Node* head,unordered_map<Node*,Node*> &copylist)
    {
        if(head==NULL)
        return head;
        //copylist[head].count用来计算head在哈希表中出现几次，因为unordered_map是不允许重复的所以只会返回0或１.
				if(copylist.count(head)) return copylist[head];  //如果已经创建过了所以就直接返回
        copylist[head]=new Node(head->val);
				copylist[head]->next=DFS(head->next,copylist); //这一句和下面一句就是结点之间建立链接关系的语句．
        copylist[head]->random=DFS(head->random,copylist);
        return copylist[head];
    }

   Node* copyRandomList(Node* head) {
       unordered_map<Node*,Node*>copylist;
       return DFS(head,copylist);
    }
};
```
### BFS<br>
*其实和DFS差不多，就是换了一种遍历的方法，有一点和DFS不同就是BFS是在便利途中结点之间就建立了链接，但是DFS是在遍历完结后回退的过程中建立链接*<br>

```
class Solution {
public:
    Node* BFS(Node*head)
    {
        if(head==NULL)
        return head;
        unordered_map<Node*,Node*>copylist;
        copylist[head]=new Node(head->val);
				queue<Node*> q; //队列
        q.push(head);
        while(!q.empty()){
            Node* temp=q.front();
            q.pop();
						//建立next链接
            if(temp->next!=NULL && copylist.count(temp->next))　//首先要判断下一个结点存不存在(存在则直接建立链接，不存在则是NULL或者还没建立)
            {
                copylist[temp]->next=copylist[temp->next];
            }
            else
            {
                if(temp->next!=NULL){　//下一个结点非NULL而是还没遍历到
                copylist[temp->next]=new Node(temp->next->val);
                copylist[temp]->next=copylist[temp->next];
                q.push(temp->next);
                }
								else　//下一个结点为NULL
                copylist[temp]->next=NULL;
            }
						//建立random 链接
            if(temp->random!=NULL && copylist.count(temp->random))
            {
                copylist[temp]->random=copylist[temp->random];
            }
            else
            {
                if(temp->random!=NULL){
                copylist[temp->random]=new Node(temp->random->val);
                copylist[temp]->random= copylist[temp->random];
                q.push(temp->random);
                }
                else
                copylist[temp]->random=NULL;
            }
        }
        return copylist[head];
    }

    Node* copyRandomList(Node* head) {
        return BFS(head);
    }
};
```
