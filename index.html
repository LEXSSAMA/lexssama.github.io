<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/spider.png">
  <link rel="icon" type="image/png" href="/img/spider.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>lexssama</title>
  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
  <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
  <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
  
    <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >
  
  <link rel="stylesheet" href="/css/main.css"  >

  
</head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>lexssama</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/136443.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="fa fa-angle-down scroll-down-arrow"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      <div class="container nopadding-md">
        <div class="py-5 z-depth-3" id="board">
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                


  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/01/02/get-free-page%EF%BC%88%EF%BC%89/">
        <p class="h4 index-header">get_free_page（）</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">get_free_page()get_free_page()定义在kernel/mm/memory.c中get_free_page和free_page用来管理主内存区中物理内存的占用和空闲情况，与每个进程的线性地址无关get_free_page（）函数的作用：get_free_page()函数用于主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。它首先扫描内存页面字节图数组mem_map[]，寻找值是0的字节项（0代表整个页面为空闲页面）。若无则返回0结束，表示物理内存已经使用完，若找到值为0的字节，则将其置1，并换算出对应空闲页面的起始地址。然后对该内存进行清零操作。最后返回该空闲页面的物理内存起始地址。
这里解释一下mem_map[]：对于内核代码和数据所占物理内存区域以外的内存（1MB以上的内存），内核使用了一个字节数组mem_map[]来表示物理内存页面的状态，每个字节描述一个物理内存页的占用状态。其中的值表示被占用的次数，0表示对于的物理内存空闲着。当申请一页物理内存时，就将对应字节的值增1。在内存管理初始化过程中，系统首先计算出1MB以上内存区域对于的内存页面数(P</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-01-02&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/01/02/copy-process/">
        <p class="h4 index-header">copy_process</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">copy_processcopy_process定义在kernel/fork.c中在sys_fork中执行了find_empty_process找到空闲的任务结构后压入一些寄存器就执行copy_process它的作用是：复制系统进程信息（task[nr]），并且设置必要的寄存器，它还整个地复制数据段。
sys_fork函数执行到copy_process时其栈内容如下图，正好对应copy_process函数的参数调用。
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
        long ebx,long ecx,long edx,
        long fs,long es,long ds,
        long eip,long cs,long eflags,long esp,long ss)
{
    struct task_struct *p;
    int i;
    struct file *f;首先为新任务数据结构分配内存(get_free_page（）,用来取得空</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-01-02&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/01/02/find-empty-process/">
        <p class="h4 index-header">find_empty_process</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">find_empty_processfind_empty_process定义在kernel/fork.c中,函数的作用时为新进程取得不重复的进程号last_pid。函数返回任务数组中的任务号（数组项）首先获取新的进程号，如果last_pid增1后超出进程号的正数表示范围，则重新从1开始使用pid号，然后再任务数组中搜索刚设置的pid号是否已经被任何任务使用。如果是则跳转到函数开始处重新获得一个pid号。接着再任务数组中为新任务寻找一个空闲项，并返回项号。last_pid是一个全局变量（定义在kernel/fork.c中，long last_pid=0）不用返回。如果此时任务数组中64个项64个项已经被全部占用，则返回出错码。
task[]定义在kernel/sched.c中是一个指针数组，即数组里的值都是指针，NR_TASK=64，第一项是进程0的任务结构的地址。这里不展开讲。
struct task_struct *task[NR_TASKS]={&amp;(init_task.task),} /—————————————————————————————–
int find_empt</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-01-02&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/01/02/fork%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/">
        <p class="h4 index-header">fork（）函数解析</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">这里主要用Linux-0.11源码中的main.c中使用的fork来讲解#fork（）在main.c中经过函数move_to_user_mode()后进入用户模式（进程0开始执行）。进程0开始执行后马上进入fork()函数，目的是创建出子进程1。在main.c中需要注意的是fork函数是用内联函数（inline）的方式实现的！为什么要用内联的方式实现呢？因为在创建新进程init（即进程1）的过程中，系统对其进行了一些特殊的处理。进程0和进程1实际上同时使用着内核代码区内（小于1MB的物理内存）相同的代码和数据物理内存页面（640KB），只是执行的代码不在一处，因此实际上它们也同时使用着相同的用户堆栈区。在为新进程init复制其父进程（进程0）的页目录和页表项时，进程0的640KB页表项属性没有改动过（仍然可读写），但是进程1的640KB对应的页表项却被设置成了只读，因此进程1开始执行时，其对用户栈的出入栈操作将导致页面写保护异常，从而会使内核的内存管理程序为进程1在主内存区分配一内存页面，并且把从任务0栈中相应页面内容复制到此新页面上。从此时起，任务1的用户态栈开始有自己独立的内存页面</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-01-02&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/19/move-to-user-mode%EF%BC%88%EF%BC%89/">
        <p class="h4 index-header">move_to_user_mode（）</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">move_to_user_mode() 源码move_to_user_mode()被定义在include/asm/system.h
函数move_to_user_mode()是用于内核在初始化结束时人工切换（移动）到初始进程（任务0）去执行，即从特权级0转移到特权级3的代码去执行。所使用的方法是模拟中断调用返回过程，即利用iret指令来实现特权级的变更和堆栈的切换，从而把CPU执行控制流移动到初始任务0的环境中运行。(标志位NT已经在sched_init()中被复位。在NT复位时执行iret指令不会造成CPU执行任务切换操作)

#define move_to_user_mode() \
_asm_( &quot;movl %%esp,%%eax\n\t&quot;\        //保存堆栈指针esp到eax寄存器中，esp=&amp;user_stack[PAGE_SIZE&gt;&gt;2]在head.s中已经被设置好。
        &quot;pushl $0x17\n\t&quot;\            //首先将堆栈段选择符（SS）入栈    （ss其实也head</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-19&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/18/sched-init/">
        <p class="h4 index-header">sched_init()</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">sched_init()//sched_init()源码：
 int i;
struct desc_struct *p;  //描述符结构指针。desc_struct 结构被定义在include/linux/head.h中,具体如下:
typedef struct desc_struct 
{   //定义了段描述符的数据结构，该结构仅说明每个描述符
    unsigned long a,b;  //符由8个字节直接构成，每个描述符表共有256项
}desc_table[256];Linux 系统开发之初，内核不成熟。内核代码会经常被修改linus怕自己无意中修改了这些关键性的数据结构，造成POSIX标准的不兼容。这里加入的这个判断语句并无必要，纯粹是为了提醒自己以及其他修改内核代码的人。
//sched_init()源码：
if(sizeof(struct sigaction)!=16)    //sigaction是存放有关信号状态的结构
panic(&quot;Struct sigaction MUST be 16 bytes&quot;);panic定义在kernel/pan</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-18&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/16/8253%E5%AE%9A%E6%97%B6%E5%99%A8-%E8%AE%A1%E6%95%B0%E5%99%A8/">
        <p class="h4 index-header">8253定时器/计数器</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">感谢：《微机原理与接口技术》 主编：陈光军 傅越千和SuPhoebe的博客《可编程定时/计数器 8253/8254》
8253定时器/计时器微机应用系统常常需要为处理机和外部设备提供实时时钟，以实现延时控制和定时或对外部输入脉冲进行计数，实现这种功能的器件称为定时器/计数器。
8253的功能与引脚8253的基本功能
8253的基本功能是对外部输入脉冲进行计数，若外部输入的脉冲式连续而均匀的则利用脉冲个数乘以脉冲周期可以计算出时间，从而实现了定时功能。若外部输入脉冲式不均匀的，不连续的非周期脉冲，则8253起计时作用，8253芯片内具有3个独立的16位减法计数器（或称为计数通道），每个计数器性能如下：（1）.最高计数频率2.6MHZ（2）.可编程设定为二进制计数或BCD码计数，有6种工作方式，可编程确定是哪一种工作方式。8253的内部结构
数据总线缓存器（Data Bus Buffer）：该缓冲器为8位双向三态，是CPU与8253内部之间的数据传输通道。
读写逻辑电路（Read/Write Logic）：接收CPU送来的读写，片选及地址信号，对8253内部各部件进行操控。
控制字寄存器（</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-16&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
            <a href="/categories/main%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">main（）函数</a>&nbsp;
          
            <a href="/categories/sched_init()%E5%87%BD%E6%95%B0">sched_init()函数</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
            <a href="/tags/main%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0">main（）函数</a>&nbsp;
          
            <a href="/tags/sched_init()%E5%87%BD%E6%95%B0">sched_init()函数</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/03/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95%E9%A1%B9/">
        <p class="h4 index-header">文件类型，属性和目录项</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">文件的类型和属性UNIX 类操作系统中的文件通常可分为6类。如果在shell下执行“ls -l”命令我们就可以从所列出的文件状态信息中知道文件的类型。见下图文件类型有“- ，d ，s ，p ，c ，b”六种类型。正规文件“-”：是一类文件系统对其不作解释的文件，包括有任何长度的字节流。例如源文件，二进制执行文件，文档，以及脚本文件。目录（d）：在UNIX文件系统中也是一种文件，但文件系统管理会对其内容进行解释，以使人们可以看到有哪些文件包含在一个目录中，以及它们使如何组织在一起构成一个分层次的文件系统的。符号连接（s）：用于使用一个不同文件名来引用另一个文件。符号连接可以跨越一个文件系统而连接到另一个文件系统中的一个文件上，删除一个符号连接并不影响被连接的文件。另外的还有一种连接方式称为“硬连接” 。它与这里所说的符号连接中的被连接文件的抵为相同，被作为一般文件对待，但是不能跨越文件系统，（一个磁盘上可以有多个文件系统）或设备进行连接，并且会递增文件的连接计数值（下面解释什么是连接计数值）。命名管道（p）： 文件是系统创建有名管道时建立的文件，可以用于无关进程之间的通信。（还不是很懂，</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-03&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
            <a href="/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/Linux-0.11">Linux-0.11</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/02/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88fs%EF%BC%89%E6%A6%82%E8%BF%B0/">
        <p class="h4 index-header">文件系统（fs）概述</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">本博客大部分搬运于《Linux内核完全注释》赵烔编著，小部分增加一些自己阅读源码过程中遇到问题的解答。目的是：希望在自己搬运的过程中，可以加深对Linux-0.11内核的理解和印象。
文件系统总体功能FS目录中的各程序中函数之间的引用关系，我们可也把它们从功能上分为四个部分加以讨论：第一部分： 是关于高速缓冲区的管理程序，主要实现了对硬盘等块设备进行数据高速存取的函数，该部分内容集中在buffer.c程序中实现。第二部分： 代码描述了文件系统的低层通用函数，说明了文件索引节点的管理，磁盘，数据块的分配和释放以及文件名与i节点的转换算法。第三部分：程序是有关对文件中数据进行读写操作，包括对字符设备，管道，块读写文件中的数据的访问。第四部分： 程序主要涉及文件的系统调用接口的实现，主要涉及文件的打开，关闭，创建以及有关文件目录操作等的系统调用。
MINIX文件系统在开发Linux-0.11内核文件时，使用的时1.0版本的MINIX文件系统。对于一个360K的软盘，图中整个磁盘被划分为以1KB为单位的磁盘块，因此上图中共有360个磁盘块，每个方格表示一个磁盘块，在MINIX1.0文件系统中，</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-02&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
            <a href="/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/Linux-0.11">Linux-0.11</a>&nbsp;
          
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/11/24/head-s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
        <p class="h4 index-header">head.s源码分析</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">感谢：《Linux内核完全注释》作者：赵烔。感谢:“ARM的程序员敲着诗歌的梦”的博客：https://blog.csdn.net/longintchar/article/details/79513086
head.s程序head.s程序在被编译后，会被连接成system模块的最前面的开始部分，这也就是为什么称其为头部（head）程序的原因。从这里开始，内核完全都是在保护模式下运行了。head.s汇编程序与前面的语法格式不同，它采用的是AT&amp;T的汇编语言格式，并且需要使用GNU的gas和gld进行编译连接，因此需要注意代码的赋值的方向是从左到右。这段程序实际上处于内存绝对地址（物理地址）0处开始的地方，这个程序的功能比较单一。

首先是加载各个数据段寄存器，重新设置中断描述符表idt，共256项，并使各个表项均指向一个只报错误的哑中断程序。
然后重新设置全局描述符表gdt.
接着使用物理地址0与1M开始处的内容相比较的方法，检测A20地址线是否真的开启（如果没有开启，访问高于1MB物理内存地址使CPU实际上只会访问（IP MOD 1MB）地址的内容）
然后程序测试PC机是否含有</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-11-24&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>&nbsp;
          
            <a href="/categories/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/Linux-0.11%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Linux-0.11源码分析</a>&nbsp;
          
        
      </div>
    </div>
  </div>



  <nav aria-label="index posts navigation">
    <ul class="pagination pg-blue justify-content-center mt-5">
      
      
        <li class="page-item">
          <a class="page-link" href="/page/2/#board">下一页</a>
        </li>
      
    </ul>
  </nav>



              </div>
            </div>
          </div>
        </div>
      </div>
    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>

  <script src="/js/lazyload.js" ></script>



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Stay hungry Stay foolish&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script>
    if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) || (/Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent))) {
      $("#background").css("background-attachment", "scroll");
    }
  </script>

</body>
</html>
